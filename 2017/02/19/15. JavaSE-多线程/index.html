<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>15. JavaSE-多线程 | SomnambulistOfChina</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java SE,">
  

  <meta name="description" content="15.1 程序、进程、线程的概念 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。  如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的   线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径">
<meta name="keywords" content="Java SE">
<meta property="og:type" content="article">
<meta property="og:title" content="15. JavaSE-多线程">
<meta property="og:url" content="http://yoursite.com/2017/02/19/15. JavaSE-多线程/index.html">
<meta property="og:site_name" content="SomnambulistOfChina">
<meta property="og:description" content="15.1 程序、进程、线程的概念 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。  如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的   线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径">
<meta property="og:locale" content="Java EE">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154431.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154639.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155642.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155722.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155810.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603160032.png">
<meta property="og:updated_time" content="2019-06-04T01:27:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="15. JavaSE-多线程">
<meta name="twitter:description" content="15.1 程序、进程、线程的概念 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。  如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的   线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径">
<meta name="twitter:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154431.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">更多</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">更多</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#15-1-程序、进程、线程的概念"><span class="toc-text">15.1 程序、进程、线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-1-进程与多线程"><span class="toc-text">15.1.1 进程与多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-2-何时需要多线程"><span class="toc-text">15.1.2 何时需要多线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-2-Java中多线程的创建和使用"><span class="toc-text">15.2 Java中多线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-1-多线程的创建和启动"><span class="toc-text">15.2.1 多线程的创建和启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-2-子线程的创建和启动过程"><span class="toc-text">15.2.2 子线程的创建和启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-3-Thread类"><span class="toc-text">15.2.3 Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的两种方式"><span class="toc-text">创建线程的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一-继承Thread类"><span class="toc-text">一 继承Thread类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二-实现Runnable接口"><span class="toc-text">二 实现Runnable接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-4-继承方式和实现方式的联系与区别"><span class="toc-text">15.2.4 继承方式和实现方式的联系与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-6-Thread类的有关方法-1"><span class="toc-text">15.2.6 Thread类的有关方法(1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-7-Thread类的有关方法-2"><span class="toc-text">15.2.7 Thread类的有关方法(2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-8-使用多线程的优点"><span class="toc-text">15.2.8 使用多线程的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-3-线程的生命周期"><span class="toc-text">15.3 线程的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-4-线程的同步"><span class="toc-text">15.4 线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-1例-题"><span class="toc-text">15.4.1例  题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-2-Synchronized的使用方法"><span class="toc-text">15.4.2 Synchronized的使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-3-同步锁-Lock"><span class="toc-text">15.4.3 同步锁(Lock)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-4-互斥锁"><span class="toc-text">15.4.4 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-6-小结：释放锁的操作"><span class="toc-text">15.4.6 小结：释放锁的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-7-线程的死锁问题"><span class="toc-text">15.4.7 线程的死锁问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-5-线程的通信"><span class="toc-text">15.5 线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-1-wait-方法"><span class="toc-text">15.5.1 wait() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-2-notify-notifyAll"><span class="toc-text">15.5.2 notify()/notifyAll()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-3-例-题"><span class="toc-text">15.5.3 例 题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-6-线程池"><span class="toc-text">15.6 线程池</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-15. JavaSE-多线程" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">15. JavaSE-多线程</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.02.19</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>SomnambulistOfChina</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaSE基础笔记/">JavaSE基础笔记</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="15-1-程序、进程、线程的概念"><a href="#15-1-程序、进程、线程的概念" class="headerlink" title="15.1 程序、进程、线程的概念"></a>15.1 程序、进程、线程的概念</h1><ul>
<li>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</li>
<li><p>进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。</p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器</li>
<li>程序是静态的，进程是动态的</li>
</ul>
</li>
<li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p>
<ul>
<li>若一个程序可同一时间执行多个线程，就是支持多线程的</li>
</ul>
</li>
</ul>
<h2 id="15-1-1-进程与多线程"><a href="#15-1-1-进程与多线程" class="headerlink" title="15.1.1 进程与多线程"></a>15.1.1 进程与多线程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154431.png" alt></p>
<h2 id="15-1-2-何时需要多线程"><a href="#15-1-2-何时需要多线程" class="headerlink" title="15.1.2 何时需要多线程"></a>15.1.2 何时需要多线程</h2><ul>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时。</li>
</ul>
<h1 id="15-2-Java中多线程的创建和使用"><a href="#15-2-Java中多线程的创建和使用" class="headerlink" title="15.2 Java中多线程的创建和使用"></a>15.2 Java中多线程的创建和使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">	public void method1(String str)&#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method2(String str)&#123;</span><br><span class="line">		method1(str);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Sample  s = new Sample();</span><br><span class="line">		s.method2(&quot;hello!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-2-1-多线程的创建和启动"><a href="#15-2-1-多线程的创建和启动" class="headerlink" title="15.2.1 多线程的创建和启动"></a>15.2.1 多线程的创建和启动</h2><ul>
<li>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。</li>
<li>Thread类的特性<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li>
<li>通过该Thread对象的start()方法来调用这个线程</li>
</ul>
</li>
</ul>
<h2 id="15-2-2-子线程的创建和启动过程"><a href="#15-2-2-子线程的创建和启动过程" class="headerlink" title="15.2.2 子线程的创建和启动过程"></a>15.2.2 子线程的创建和启动过程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154639.png" alt></p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154701.png" alt></p>
<h2 id="15-2-3-Thread类"><a href="#15-2-3-Thread类" class="headerlink" title="15.2.3 Thread类"></a>15.2.3 Thread类</h2><ul>
<li>构造方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread()：创建新的Thread对象</span><br><span class="line">Thread(String threadname)：创建线程并指定线程实例名</span><br><span class="line">Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法</span><br><span class="line">Thread(Runnable target, String name)：创建新的Thread对象</span><br></pre></td></tr></table></figure>
<h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><h4 id="一-继承Thread类"><a href="#一-继承Thread类" class="headerlink" title="一 继承Thread类"></a>一 继承Thread类</h4><p> 1)  定义子类继承Thread类。<br> 2)  子类中重写Thread类中的run方法。<br> 3)  创建Thread子类对象，即创建了线程对象。<br> 4)  调用线程对象start方法：启动线程，调用run方法  </p>
<h4 id="二-实现Runnable接口"><a href="#二-实现Runnable接口" class="headerlink" title="二 实现Runnable接口"></a>二 实现Runnable接口</h4><p>1）定义子类，实现Runnable接口。<br>2）子类中重写Runnable接口中的run方法。<br>3）通过Thread类含参构造器创建线程对象。<br>4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。<br>5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。  </p>
<h2 id="15-2-4-继承方式和实现方式的联系与区别"><a href="#15-2-4-继承方式和实现方式的联系与区别" class="headerlink" title="15.2.4 继承方式和实现方式的联系与区别"></a>15.2.4 继承方式和实现方式的联系与区别</h2><p>【区别】  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）继承Thread:       线程代码存放Thread子类run方法中。</span><br><span class="line">2）实现Runnable：线程代码存在接口的子类的run方法</span><br></pre></td></tr></table></figure>
<p>。<br>【实现方法的好处】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）避免了单继承的局限性</span><br><span class="line">2）多个线程可以共享同一个接口子类的对象，非常适合多个相同线程来处理同一份资源。</span><br></pre></td></tr></table></figure>
<h2 id="15-2-6-Thread类的有关方法-1"><a href="#15-2-6-Thread类的有关方法-1" class="headerlink" title="15.2.6 Thread类的有关方法(1)"></a>15.2.6 Thread类的有关方法(1)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   void start():  启动线程，并执行对象的run()方法</span><br><span class="line">run():  线程在被调度时执行的操作</span><br><span class="line">String getName():  返回线程的名称</span><br><span class="line">void setName(String name):设置该线程名称</span><br><span class="line">static currentThread(): 返回当前线程</span><br></pre></td></tr></table></figure>
<p>线程的调度</p>
<ul>
<li>调度策略<br>时间片</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155028.png" alt><br>抢占式：高优先级的线程抢占CPU </p>
<ul>
<li>Java的调度方法</li>
</ul>
<blockquote>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
</blockquote>
<p>线程的优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   MAX_PRIORITY（10）;    </span><br><span class="line">MIN _PRIORITY （1）;  </span><br><span class="line">NORM_PRIORITY （5）;</span><br><span class="line">涉及的方法：</span><br><span class="line">getPriority() ：返回线程优先值 </span><br><span class="line">setPriority(int newPriority) ：改变线程的优先级</span><br><span class="line">线程创建时继承父线程的优先级</span><br></pre></td></tr></table></figure>
<h2 id="15-2-7-Thread类的有关方法-2"><a href="#15-2-7-Thread类的有关方法-2" class="headerlink" title="15.2.7 Thread类的有关方法(2)"></a>15.2.7 Thread类的有关方法(2)</h2><p>static  void  yield()：线程让步</p>
<blockquote>
<ul>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</blockquote>
<p>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止   </p>
<blockquote>
<ul>
<li>低优先级的线程也可以获得执行 </li>
</ul>
</blockquote>
<p>static  void  sleep(long millis)：(指定时间:毫秒)</p>
<blockquote>
<ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</li>
<li>抛出InterruptedException异常</li>
</ul>
</blockquote>
<p>stop(): 强制线程生命期结束<br>boolean isAlive()：返回boolean，判断线程是否还活着</p>
<h2 id="15-2-8-使用多线程的优点"><a href="#15-2-8-使用多线程的优点" class="headerlink" title="15.2.8 使用多线程的优点"></a>15.2.8 使用多线程的优点</h2><p>背景：只使用单个线程完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？<br>多线程程序的优点：</p>
<ol>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。  </li>
<li>提高计算机系统CPU的利用率  </li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改  </li>
</ol>
<h1 id="15-3-线程的生命周期"><a href="#15-3-线程的生命周期" class="headerlink" title="15.3 线程的生命周期"></a>15.3 线程的生命周期</h1><p>JDK中用Thread.State枚举表示了线程的几种状态</p>
<ul>
<li>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件</li>
<li>运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止   </li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155642.png" alt></p>
<h1 id="15-4-线程的同步"><a href="#15-4-线程的同步" class="headerlink" title="15.4 线程的同步"></a>15.4 线程的同步</h1><p>问题的提出</p>
<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155722.png" alt></p>
<h2 id="15-4-1例-题"><a href="#15-4-1例-题" class="headerlink" title="15.4.1例  题"></a>15.4.1例  题</h2><p>模拟火车站售票程序，开启三个窗口售票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Ticket implements Runnable &#123;</span><br><span class="line">	private int tick = 100;</span><br><span class="line"></span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			if (tick &gt; 0) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot;售出车票，tick号为：&quot; + tick--);</span><br><span class="line">			&#125; else</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Ticket t = new Ticket();</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(t);</span><br><span class="line">		Thread t2 = new Thread(t);</span><br><span class="line">		Thread t3 = new Thread(t);</span><br><span class="line">		t1.setName(&quot;t1窗口&quot;);</span><br><span class="line">		t2.setName(&quot;t2窗口&quot;);</span><br><span class="line">		t3.setName(&quot;t3窗口&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155810.png" alt></p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155831.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private int tick = 100;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			if (tick &gt; 0) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(10);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot;售出车票，tick号为：&quot; + tick--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1）    多线程出现了安全问题<br>2）    问题的原因：<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。<br>3）    解决办法<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p>
<h2 id="15-4-2-Synchronized的使用方法"><a href="#15-4-2-Synchronized的使用方法" class="headerlink" title="15.4.2 Synchronized的使用方法"></a>15.4.2 Synchronized的使用方法</h2><ul>
<li>Java对于多线程的安全问题提供了专业的解决方式： 同步代码块</li>
</ul>
<p>1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象)&#123;</span><br><span class="line">          // 需要被同步的代码；</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>2）    synchronized还可以放在方法声明中，表示整个方法<br>      为同步方法。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void show (String name)&#123; </span><br><span class="line">            ….</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603160032.png" alt></p>
<h2 id="15-4-3-同步锁-Lock"><a href="#15-4-3-同步锁-Lock" class="headerlink" title="15.4.3 同步锁(Lock)"></a>15.4.3 同步锁(Lock)</h2><ul>
<li>从Java 5开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>Lock是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>在实现线程安全的控制中，比较常用的是ReentrantLock(可重入锁)，可以显式加锁、释放锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	private final ReentrantLock lock = new ReenTrantLock();</span><br><span class="line"></span><br><span class="line">	public void m() &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">			// 保证线程安全的代码;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-4-4-互斥锁"><a href="#15-4-4-互斥锁" class="headerlink" title="15.4.4 互斥锁"></a>15.4.4 互斥锁</h2><ul>
<li>在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。<ul>
<li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li>
<li>关键字synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。</li>
<li>同步的局限性：导致程序的执行效率要降低</li>
<li>同步方法（非静态的）的锁为this。</li>
<li>同步方法（静态的）的锁为当前类本身。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">	private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">	private Singleton() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if (instance == null) &#123;</span><br><span class="line">			synchronized (Singleton.class) &#123;</span><br><span class="line">				if (instance == null) &#123;</span><br><span class="line">					instance = new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSingleton &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Singleton s1 = Singleton.getInstance();</span><br><span class="line">		Singleton s2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(s1 == s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-4-6-小结：释放锁的操作"><a href="#15-4-6-小结：释放锁的操作" class="headerlink" title="15.4.6 小结：释放锁的操作"></a>15.4.6 小结：释放锁的操作</h2><ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ul>
<h2 id="15-4-7-线程的死锁问题"><a href="#15-4-7-线程的死锁问题" class="headerlink" title="15.4.7 线程的死锁问题"></a>15.4.7 线程的死锁问题</h2><ul>
<li><p>死锁</p>
<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestDeadLock &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final StringBuffer s1 = new StringBuffer();</span><br><span class="line">		final StringBuffer s2 = new StringBuffer();</span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (s1) &#123;</span><br><span class="line">					s2.append(&quot;A&quot;);</span><br><span class="line">					synchronized (s2) &#123;</span><br><span class="line">						s2.append(&quot;B&quot;);</span><br><span class="line">						System.out.print(s1);</span><br><span class="line">						System.out.print(s2);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (s2) &#123;</span><br><span class="line">					s2.append(&quot;C&quot;);</span><br><span class="line">					synchronized (s1) &#123;</span><br><span class="line">						s1.append(&quot;D&quot;);</span><br><span class="line">						System.out.print(s2);</span><br><span class="line">						System.out.print(s1);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="15-5-线程的通信"><a href="#15-5-线程的通信" class="headerlink" title="15.5 线程的通信"></a>15.5 线程的通信</h1><ul>
<li><p>wait() 与 notify() 和 notifyAll()</p>
<ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.</li>
</ul>
</li>
<li><p>Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常</p>
</li>
</ul>
<h2 id="15-5-1-wait-方法"><a href="#15-5-1-wait-方法" class="headerlink" title="15.5.1 wait() 方法"></a>15.5.1 wait() 方法</h2><ul>
<li>在当前线程中调用方法：  对象名.wait()</li>
<li>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
<li>调用此方法后，当前线程将释放对象监控权  ，然后进入等待</li>
<li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
</ul>
<h2 id="15-5-2-notify-notifyAll"><a href="#15-5-2-notify-notifyAll" class="headerlink" title="15.5.2 notify()/notifyAll()"></a>15.5.2 notify()/notifyAll()</h2><ul>
<li>在当前线程中调用方法：  对象名.notify()</li>
<li>功能：唤醒等待该对象监控权的一个线程。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
<h2 id="15-5-3-例-题"><a href="#15-5-3-例-题" class="headerlink" title="15.5.3 例 题"></a>15.5.3 例 题</h2><p>使用两个线程打印 1-100. 线程1, 线程2 交替打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Communication implements Runnable &#123;</span><br><span class="line">	int i = 1;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				notify();</span><br><span class="line">				if (i &lt;= 100) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);</span><br><span class="line">				&#125; else</span><br><span class="line">					break;</span><br><span class="line">				try &#123;</span><br><span class="line">					wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典例题：生产者/消费者问题</p>
<ul>
<li><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
</li>
<li><p>这里可能出现两个问题：</p>
<ul>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li>
<li>消费者比生产者快时，消费者会取相同的数据。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class TestProduct &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Clerk clerk = new Clerk();</span><br><span class="line">		Thread productorThread = new Thread(new Productor(clerk));</span><br><span class="line">		Thread consumerThread = new Thread(new Consumer(clerk));</span><br><span class="line">		productorThread.start();</span><br><span class="line">		consumerThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clerk &#123; // 售货员</span><br><span class="line">	private int product = 0;</span><br><span class="line"></span><br><span class="line">	public synchronized void addProduct() &#123;</span><br><span class="line">		if (product &gt;= 20) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			product++;</span><br><span class="line">			System.out.println(&quot;生产者生产了第&quot; + product + &quot;个产品&quot;);</span><br><span class="line">			notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public synchronized void getProduct() &#123;</span><br><span class="line">		if (this.product &lt;= 0) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			System.out.println(&quot;消费者取走了第&quot; + product + &quot;个产品&quot;);</span><br><span class="line">			product--;</span><br><span class="line">			notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Productor implements Runnable &#123; // 生产者</span><br><span class="line">	Clerk clerk;</span><br><span class="line"></span><br><span class="line">	public Productor(Clerk clerk) &#123;</span><br><span class="line">		this.clerk = clerk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;生产者开始生产产品&quot;);</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep((int) Math.random() * 1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			clerk.addProduct();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable &#123; // 消费者</span><br><span class="line">	Clerk clerk;</span><br><span class="line"></span><br><span class="line">	public Consumer(Clerk clerk) &#123;</span><br><span class="line">		this.clerk = clerk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;消费者开始取走产品&quot;);</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep((int) Math.random() * 1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			clerk.getProduct();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.5.4 练习1<br>模拟银行取钱的问题<br>1.定义一个Account类<br>1）该Account类封装了账户编号（String）和余额（double）两个属性<br>2）设置相应属性的getter和setter方法<br>3）提供无参和有两个参数的构造器<br>4）系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写<br>2.提供一个取钱的线程类<br>1）提供了Account类的account属性和double类的取款额的属性<br>2）提供带线程名的构造方法<br>3）run()方法中提供取钱的操作<br>3.在主类中创建线程进行测试。考虑线程安全问题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">	private String accountId;</span><br><span class="line">	private double balance;</span><br><span class="line"></span><br><span class="line">	public Account() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Account(String accountId, double balance) &#123;</span><br><span class="line">		this.accountId = accountId;</span><br><span class="line">		this.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getAccountId() &#123;</span><br><span class="line">		return accountId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAccountId(String accountId) &#123;</span><br><span class="line">		this.accountId = accountId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double getBalance() &#123;</span><br><span class="line">		return balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setBalance(double balance) &#123;</span><br><span class="line">		this.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Account [accountId=&quot; + accountId + &quot;, balance=&quot; + balance + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		final int prime = 31;</span><br><span class="line">		int result = 1;</span><br><span class="line">		result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());</span><br><span class="line">		long temp;</span><br><span class="line">		temp = Double.doubleToLongBits(balance);</span><br><span class="line">		result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (this == obj)</span><br><span class="line">			return true;</span><br><span class="line">		if (obj == null)</span><br><span class="line">			return false;</span><br><span class="line">		if (getClass() != obj.getClass())</span><br><span class="line">			return false;</span><br><span class="line">		Account other = (Account) obj;</span><br><span class="line">		if (accountId == null) &#123;</span><br><span class="line">			if (other.accountId != null)</span><br><span class="line">				return false;</span><br><span class="line">		&#125; else if (!accountId.equals(other.accountId))</span><br><span class="line">			return false;</span><br><span class="line">		if (Double.doubleToLongBits(balance) != Double.doubleToLongBits(other.balance))</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public class WithDrawThread extends Thread &#123;</span><br><span class="line">		Account account;</span><br><span class="line">		// 要取款的额度</span><br><span class="line">		double withDraw;</span><br><span class="line"></span><br><span class="line">		public WithDrawThread(String name, Account account, double amt) &#123;</span><br><span class="line">			super(name);</span><br><span class="line">			this.account = account;</span><br><span class="line">			this.withDraw = amt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void run() &#123;</span><br><span class="line">			synchronized (account) &#123;</span><br><span class="line">				if (account.getBalance() &gt; withDraw) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + &quot;:取款成功，取现的金额为：&quot; + withDraw);</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(50);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					account.setBalance(account.getBalance() - withDraw);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					System.out.println(&quot;取现额度超过账户余额，取款失败&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(&quot;现在账户的余额为：&quot; + account.getBalance());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public class WithDrawThread extends Thread &#123;</span><br><span class="line">		Account account;</span><br><span class="line">		// 要取款的额度</span><br><span class="line">		double withDraw;</span><br><span class="line"></span><br><span class="line">		public WithDrawThread(String name, Account account, double amt) &#123;</span><br><span class="line">			super(name);</span><br><span class="line">			this.account = account;</span><br><span class="line">			this.withDraw = amt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void run() &#123;</span><br><span class="line">			synchronized (account) &#123;</span><br><span class="line">				if (account.getBalance() &gt; withDraw) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + &quot;:取款成功，取现的金额为：&quot; + withDraw);</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(50);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					account.setBalance(account.getBalance() - withDraw);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					System.out.println(&quot;取现额度超过账户余额，取款失败&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(&quot;现在账户的余额为：&quot; + account.getBalance());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;public class TestWithDrawThread &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Account account = new Account(&quot;1234567&quot;, 10000);</span><br><span class="line">		Thread t1 = new WithDrawThread(&quot;小明&quot;, account, 8000);</span><br><span class="line">		Thread t2 = new WithDrawThread(&quot;小明&apos;s wife&quot;, account, 2800);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="15-6-线程池"><a href="#15-6-线程池" class="headerlink" title="15.6 线程池"></a>15.6 线程池</h1><ul>
<li>系统启动一个新线程的成本是比较高的，因为它涉及与os交互。这种情况下，系统启动时即创建大量空闲的线程，就可以很好地提高性能，尤其是当程序需要创建大量生存期很短暂的线程时。</li>
<li>除此之外，使用线程池可以有效地控制系统中并发线程的数量。避免因并发创建的线程过多，导致系统性能下降，JVM崩溃。</li>
<li>Java 5以前，需要手动创建自己的线程池；Java 5开始，新增了Executors工厂类产生线程池。<br>使用线程池执行线程任务的步骤如下：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.调用Executors 类的静态方法newFixedThreadPool(int nThreads)，</span><br><span class="line">    创建一个可重用的、具有固定线程数的线程池ExecutorService对象  </span><br><span class="line">2.创建Runnable实例，作为线程执行任务  </span><br><span class="line">3.调用ExecutorService对象的submit()提交Runnable实例  </span><br><span class="line">4.调用ExecutorService对象的shutDown()方法关闭线程池。</span><br></pre></td></tr></table></figure>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpeg" alt>
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpeg" alt>
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/02/16/14. JavaSE-Java反射机制/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/02/26/16. JavaSE-网络编程/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment"></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "b8cfVAxSX9whYsIOMmxwCicp-gzGzoHsz",
            appKey: "klYDKAeEh6GPa0wnf22lQd96",
            avatar:'identicon',
            placeholder: "ヾﾉ≧∀≦)o 来呀！快活呀！~",
            guest_info:guest_info,
            pageSize:'10'
        });
    </script>
  
    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '277317290454635afa73',
  clientSecret: '78223c859304da5e8d71bfce136d436c6ff95c37',
  repo: 'blog-comment',
  owner: 'forsigner',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: location.pathname,
  admin: ['forsigner'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>

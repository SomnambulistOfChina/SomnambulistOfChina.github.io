<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>14. JavaSE-Java反射机制 | SomnambulistOfChina</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java SE,">
  

  <meta name="description" content="14.1 Java反射机制概述 Java Reflection   Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。   Java反射机制提供的功能  在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意">
<meta name="keywords" content="Java SE">
<meta property="og:type" content="article">
<meta property="og:title" content="14. JavaSE-Java反射机制">
<meta property="og:url" content="http://yoursite.com/2017/02/16/14. JavaSE-Java反射机制/index.html">
<meta property="og:site_name" content="SomnambulistOfChina">
<meta property="og:description" content="14.1 Java反射机制概述 Java Reflection   Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。   Java反射机制提供的功能  在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意">
<meta property="og:locale" content="Java EE">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604003545.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151527.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151722.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151830.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153731.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153928.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153949.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154040.png">
<meta property="og:updated_time" content="2019-06-04T01:26:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="14. JavaSE-Java反射机制">
<meta name="twitter:description" content="14.1 Java反射机制概述 Java Reflection   Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。   Java反射机制提供的功能  在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意">
<meta name="twitter:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604003545.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?99d997f72fffd95d0fd1477dd657eafc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
  
</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">更多</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">更多</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#14-1-Java反射机制概述"><span class="toc-text">14.1 Java反射机制概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-2-理解Class类并获取Class的实例"><span class="toc-text">14.2 理解Class类并获取Class的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-Class-类"><span class="toc-text">14.2.1 Class 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-2-Class类的常用方法"><span class="toc-text">14.2.2 Class类的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-3"><span class="toc-text">14.2.3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-4-实例化Class类对象-四种方法"><span class="toc-text">14.2.4 实例化Class类对象(四种方法)</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#14-3-类的加载与ClassLoader的理解"><span class="toc-text">14.3 类的加载与ClassLoader的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-1-了解：类的加载过程"><span class="toc-text">14.3.1 了解：类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-2-了解：ClassLoader"><span class="toc-text">14.3.2 了解：ClassLoader</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-4-创建运行时类的对象"><span class="toc-text">14.4 创建运行时类的对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-5-获取运行时类的完整结构"><span class="toc-text">14.5 获取运行时类的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-1-通过反射获取运行时类的完整结构"><span class="toc-text">14.5.1 通过反射获取运行时类的完整结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-2-通过反射获取运行时类的完整结构"><span class="toc-text">14.5.2 通过反射获取运行时类的完整结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-6-调用运行时类的指定属性、指定方法等"><span class="toc-text">14.6 调用运行时类的指定属性、指定方法等</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-6-1-通过反射调用类中的指定方法、指定属性"><span class="toc-text">14.6.1 通过反射调用类中的指定方法、指定属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-7-反射的应用：动态代理"><span class="toc-text">14.7 反射的应用：动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-7-1-Java动态代理"><span class="toc-text">14.7.1 Java动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-7-2-动态代理步骤"><span class="toc-text">14.7.2 动态代理步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-7-3-动态代理与AOP（Aspect-Orient-Programming"><span class="toc-text">14.7.3 动态代理与AOP（Aspect Orient Programming)</span></a></li></ol></li>
  </div>



<div class="content content-post CENTER">
   <article id="post-14. JavaSE-Java反射机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">14. JavaSE-Java反射机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.02.16</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>SomnambulistOfChina</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaSE基础笔记/">JavaSE基础笔记</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="14-1-Java反射机制概述"><a href="#14-1-Java反射机制概述" class="headerlink" title="14.1 Java反射机制概述"></a>14.1 Java反射机制概述</h1><ul>
<li>Java Reflection<br>   Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</li>
</ul>
<ul>
<li><p>Java反射机制提供的功能</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>生成动态代理</li>
</ul>
</li>
<li><p>反射相关的主要API：</p>
<ul>
<li>java.lang.Class:代表一个类</li>
<li>java.lang.reflect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造方法</li>
<li>。。。</li>
</ul>
</li>
</ul>
<h1 id="14-2-理解Class类并获取Class的实例"><a href="#14-2-理解Class类并获取Class的实例" class="headerlink" title="14.2 理解Class类并获取Class的实例"></a>14.2 理解Class类并获取Class的实例</h1><h3 id="14-2-1-Class-类"><a href="#14-2-1-Class-类" class="headerlink" title="14.2.1 Class 类"></a>14.2.1 Class 类</h3><p>在Object类中定义了以下的方法，此方法将被所有子类继承：<br>●  public final Class getClass()<br>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。  </p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604003545.png" alt></p>
<ul>
<li>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。</li>
<li>Class本身也是一个类</li>
<li>Class 对象只能由系统建立对象</li>
<li>一个类在 JVM 中只会有一个Class实例 </li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>
<li>通过Class可以完整地得到一个类中的完整结构 </li>
</ul>
<h2 id="14-2-2-Class类的常用方法"><a href="#14-2-2-Class类的常用方法" class="headerlink" title="14.2.2 Class类的常用方法"></a>14.2.2 Class类的常用方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151527.png" alt></p>
<h2 id="14-2-3"><a href="#14-2-3" class="headerlink" title="14.2.3"></a>14.2.3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">•	String str = &quot;test4.Person&quot;;</span><br><span class="line">•	Class clazz = Class.forName(str);</span><br><span class="line">•	Object obj = clazz.newInstance();</span><br><span class="line">•	Field field = clazz.getField(&quot;name&quot;);</span><br><span class="line">•	field.set(obj, &quot;Peter&quot;);</span><br><span class="line">•	Object obj2 = field.get(obj);</span><br><span class="line">•	System.out.println(obj2);</span><br></pre></td></tr></table></figure>
<h2 id="14-2-4-实例化Class类对象-四种方法"><a href="#14-2-4-实例化Class类对象-四种方法" class="headerlink" title="14.2.4 实例化Class类对象(四种方法)"></a>14.2.4 实例化Class类对象(四种方法)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）前提：若已知具体的类，通过类的class属性获取，该方法 </span><br><span class="line">                    最为安全可靠，程序性能最高</span><br><span class="line">       实例：Class clazz = String.class;</span><br><span class="line">2）前提：已知某个类的实例，调用该实例的getClass()方法获</span><br><span class="line">                    取Class对象</span><br><span class="line">       实例：Class clazz = “www.atguigu.com”.getClass();</span><br><span class="line">3）前提：已知一个类的全类名，且该类在类路径下，可通过</span><br><span class="line">       Class类的静态方法forName()获取，可能抛出ClassNotFoundException</span><br><span class="line">       实例：Class clazz = Class.forName(“java.lang.String”);</span><br><span class="line">4）其他方式(不做要求)</span><br><span class="line">ClassLoader cl = this.getClass().getClassLoader();</span><br><span class="line">Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure>
<h1 id="14-3-类的加载与ClassLoader的理解"><a href="#14-3-类的加载与ClassLoader的理解" class="headerlink" title="14.3 类的加载与ClassLoader的理解"></a>14.3 类的加载与ClassLoader的理解</h1><h2 id="14-3-1-了解：类的加载过程"><a href="#14-3-1-了解：类的加载过程" class="headerlink" title="14.3.1 了解：类的加载过程"></a>14.3.1 了解：类的加载过程</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151722.png" alt></p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151758.png" alt></p>
<h2 id="14-3-2-了解：ClassLoader"><a href="#14-3-2-了解：ClassLoader" class="headerlink" title="14.3.2 了解：ClassLoader"></a>14.3.2 了解：ClassLoader</h2><p>类加载器是用来把类(class)装载进内存的。JVM 规范定义了两种类型的类加载器：启动类加载器(bootstrap)和用户自定义加载器(user-defined class loader)。 JVM在运行时会产生3个类加载器组成的初始化加载器层次结构 ，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151830.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">•	//1.获取一个系统类加载器</span><br><span class="line">•	ClassLoader classloader = ClassLoader.getSystemClassLoader();</span><br><span class="line">•	System.out.println(classloader);</span><br><span class="line">•	//2.获取系统类加载器的父类加载器，即扩展类加载器</span><br><span class="line">•	classloader = classloader.getParent();</span><br><span class="line">•	System.out.println(classloader);</span><br><span class="line">•	//3.获取扩展类加载器的父类加载器，即引导类加载器</span><br><span class="line">•	classloader = classloader.getParent();</span><br><span class="line">•	System.out.println(classloader);</span><br><span class="line">•	//4.测试当前类由哪个类加载器进行加载</span><br><span class="line">•	classloader = </span><br><span class="line">•	Class.forName(&quot;exer2.ClassloaderDemo&quot;).getClassLoader();</span><br><span class="line">•	System.out.println(classloader);</span><br><span class="line">•	//5.测试JDK提供的Object类由哪个类加载器加载</span><br><span class="line">•	classloader = </span><br><span class="line">•	Class.forName(&quot;java.lang.Object&quot;).getClassLoader();</span><br><span class="line">•	System.out.println(classloader);</span><br><span class="line">•	//*6.关于类加载器的一个主要方法：</span><br><span class="line">    getResourceAsStream(String str):获取类路径下的指定文件的输入流</span><br><span class="line">•	InputStream in = null;</span><br><span class="line">•	in = this.getClass().getClassLoader().getResourceAsStream(&quot;exer2\\test.properties&quot;);</span><br><span class="line">•	System.out.println(in);</span><br></pre></td></tr></table></figure>
<h1 id="14-4-创建运行时类的对象"><a href="#14-4-创建运行时类的对象" class="headerlink" title="14.4 创建运行时类的对象"></a>14.4 创建运行时类的对象</h1><p>[问题] 有了Class对象，能做什么？</p>
<p>创建类的对象：调用Class对象的newInstance()方法<br>要  求：  </p>
<p>1）类必须有一个无参数的构造器。<br>2）类的构造器的访问权限需要足够。  </p>
<p>难道没有无参的构造器就不能创建对象了吗？<br>不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。步骤如下：<br>1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<br>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。<br>3）在Constructor类中存在一个方法:<br>     Public T newInstance(Object … initargs);<br>以上是反射机制用的最多的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.根据全类名获取对应的Class对象</span><br><span class="line">String name = “atguigu.java.Person&quot;;</span><br><span class="line">Class clazz = null;</span><br><span class="line">clazz = Class.forName(name);</span><br><span class="line">//2.调用指定参数结构的构造器，生成Constructor的实例</span><br><span class="line">Constructor con = clazz.getConstructor(String.class,Integer.class);</span><br><span class="line">//3.通过Constructor的实例创建对应类的对象，并初始化类属性</span><br><span class="line">Person p2 = (Person) 	con.newInstance(&quot;Peter&quot;,20);</span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure>
<h1 id="14-5-获取运行时类的完整结构"><a href="#14-5-获取运行时类的完整结构" class="headerlink" title="14.5 获取运行时类的完整结构"></a>14.5 获取运行时类的完整结构</h1><h2 id="14-5-1-通过反射获取运行时类的完整结构"><a href="#14-5-1-通过反射获取运行时类的完整结构" class="headerlink" title="14.5.1 通过反射获取运行时类的完整结构"></a>14.5.1 通过反射获取运行时类的完整结构</h2><p>Field、Method、Constructor、Superclass、Interface、Annotation</p>
<ul>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
</ul>
<h2 id="14-5-2-通过反射获取运行时类的完整结构"><a href="#14-5-2-通过反射获取运行时类的完整结构" class="headerlink" title="14.5.2 通过反射获取运行时类的完整结构"></a>14.5.2 通过反射获取运行时类的完整结构</h2><p>使用反射可以取得：<br>1 实现的全部接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt;[] getInterfaces()     </span><br><span class="line">确定此对象所表示的类或接口实现的接口。</span><br></pre></td></tr></table></figure>
<p>2 所继承的父类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;? Super T&gt; getSuperclass()</span><br><span class="line">返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</span><br></pre></td></tr></table></figure>
<p>3 全部的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt;[] getConstructors()</span><br><span class="line">返回此 Class 对象所表示的类的所有public构造方法。</span><br><span class="line">public Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br><span class="line">返回此 Class 对象表示的类声明的所有构造方法。</span><br></pre></td></tr></table></figure>
<ul>
<li>Constructor类中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   取得修饰符: public int getModifiers();</span><br><span class="line">取得方法名称: public String getName();</span><br><span class="line">取得参数的类型：public Class&lt;?&gt;[] getParameterTypes();</span><br></pre></td></tr></table></figure>
<p>4 全部的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public Method[] getDeclaredMethods()</span><br><span class="line">返回此Class对象所表示的类或接口的全部方法</span><br><span class="line">	public Method[] getMethods()  </span><br><span class="line">返回此Class对象所表示的类或接口的public的方法</span><br></pre></td></tr></table></figure>
<p>Method类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   public Class&lt;?&gt; getReturnType()取得全部的返回值</span><br><span class="line">public Class&lt;?&gt;[] getParameterTypes()取得全部的参数</span><br><span class="line">public int getModifiers()取得修饰符</span><br><span class="line">public Class&lt;?&gt;[] getExceptionTypes()取得异常信息</span><br></pre></td></tr></table></figure>
<p>5.全部的Field</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Field[] getFields() </span><br><span class="line">	返回此Class对象所表示的类或接口的public的Field。</span><br><span class="line">public Field[] getDeclaredFields() </span><br><span class="line">	返回此Class对象所表示的类或接口的全部Field。</span><br></pre></td></tr></table></figure>
<p>Field方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int getModifiers() </span><br><span class="line">	以整数形式返回此Field的修饰符</span><br><span class="line">public Class&lt;?&gt; getType()</span><br><span class="line">    得到Field的属性类型</span><br><span class="line">public String getName() </span><br><span class="line">	返回Field的名称。</span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>Annotation相关</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get Annotation(Class&lt;T&gt; annotationClass) </span><br><span class="line">getDeclaredAnnotations()</span><br></pre></td></tr></table></figure>
<p>7.泛型相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取父类泛型类型：Type getGenericSuperclass()</span><br><span class="line">泛型类型：ParameterizedType</span><br><span class="line">获取实际的泛型类型参数数组：getActualTypeArguments()</span><br></pre></td></tr></table></figure>
<p>8.类所在的包    Package getPackage() </p>
<p>小 结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在实际的操作中，取得类的信息的操作代码，并不会经常开发。</span><br><span class="line">2.一定要熟悉java.lang.reflect包的作用，反射机制。</span><br><span class="line">3.如何取得属性、方法、构造器的名称，修饰符等。</span><br></pre></td></tr></table></figure>
<h1 id="14-6-调用运行时类的指定属性、指定方法等"><a href="#14-6-调用运行时类的指定属性、指定方法等" class="headerlink" title="14.6 调用运行时类的指定属性、指定方法等"></a>14.6 调用运行时类的指定属性、指定方法等</h1><h2 id="14-6-1-通过反射调用类中的指定方法、指定属性"><a href="#14-6-1-通过反射调用类中的指定方法、指定属性" class="headerlink" title="14.6.1 通过反射调用类中的指定方法、指定属性"></a>14.6.1 通过反射调用类中的指定方法、指定属性</h2><p>1.调用指定方法<br>通过反射，调用类中的方法，通过Method类完成。步骤： </p>
<ul>
<li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153110.png" alt></p>
<p>2.通过反射调用类中的指定方法、指定属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object obj, Object …  args)</span><br></pre></td></tr></table></figure>
<p>1）说明：</p>
<blockquote>
<p>   1.Object 对应原方法的返回值，若原方法无返回值，此时返回null<br>   2.若原方法若为静态方法，此时形参Object obj可为null<br>   3.若原方法形参列表为空，则Object[] args为null<br>   4.若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</p>
</blockquote>
<p>2）调用指定属性  </p>
<ul>
<li>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public Field getField(String name)</span><br><span class="line">返回此Class对象表示的类或接口的指定的public的Field。</span><br><span class="line">    public Field getDeclaredField(String name)</span><br><span class="line">返回此Class对象表示的类或接口的指定的Field。</span><br></pre></td></tr></table></figure>
<ul>
<li>在Field中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object obj)</span><br><span class="line">    取得指定对象obj上此Field的属性内容</span><br><span class="line">public void set(Object obj,Object value)</span><br><span class="line">	设置指定对象obj上此Field的属性内容</span><br></pre></td></tr></table></figure>
<p>注：在类中属性都设置为private的前提下，在使用set()和get()方法时，首先要使用Field类中的setAccessible(true)方法将需要操作的属性设置为可以被外部访问。</p>
<ul>
<li>public void setAccessible(true)访问私有属性时，让这个属性可见。 </li>
</ul>
<h1 id="14-7-反射的应用：动态代理"><a href="#14-7-反射的应用：动态代理" class="headerlink" title="14.7 反射的应用：动态代理"></a>14.7 反射的应用：动态代理</h1><h2 id="14-7-1-Java动态代理"><a href="#14-7-1-Java动态代理" class="headerlink" title="14.7.1 Java动态代理"></a>14.7.1 Java动态代理</h2><ul>
<li>之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</li>
<li>最好可以通过一个代理类完成全部的代理功能</li>
<li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</li>
<li><p>动态代理使用场合:</p>
<ul>
<li>调试</li>
<li>远程方法调用</li>
</ul>
</li>
<li><p>代理设计模式的原理:<br>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上.</p>
</li>
<li><p>Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</p>
</li>
<li>提供用于创建动态代理类和动态代理对象的静态方法<ul>
<li>static Class&lt;?&gt;   getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces)  创建一个动态代理类所对应的Class对象</li>
<li>static Object   newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)  直接创建一个动态代理对象</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader : 类加载器</span><br><span class="line">Class&lt;?&gt;[] : 得到全部的接口</span><br><span class="line">InvocationHandler : 得到InvocationHandler接口的子类实例</span><br></pre></td></tr></table></figure>
<h2 id="14-7-2-动态代理步骤"><a href="#14-7-2-动态代理步骤" class="headerlink" title="14.7.2 动态代理步骤"></a>14.7.2 动态代理步骤</h2><p>1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object theProxy, Method method, Object[] params) throws Throwable&#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">         Object retval = method.invoke(targetObj, params);</span><br><span class="line">         // Print out the result</span><br><span class="line">           System.out.println(retval);</span><br><span class="line">            return retval;</span><br><span class="line">        &#125;</span><br><span class="line">      catch (Exception exc)&#123;&#125;</span><br><span class="line">Object theProxy : 被代理对象</span><br><span class="line">Method method : 要调用的方法</span><br><span class="line">Object[] params : 方法调用时所需要的参数</span><br></pre></td></tr></table></figure>
<p>2.创建被代理的类以及接口</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153731.png" alt></p>
<p>3.通过Proxy的静态方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个Subject接口代理</span><br><span class="line">   RealSubject target = new RealSubject();</span><br><span class="line">// Create a proxy to wrap the original implementation</span><br><span class="line">            DebugProxy proxy = new DebugProxy(target);</span><br><span class="line"> // Get a reference to the proxy through the Subject interface</span><br><span class="line">          Subject sub = (Subject) Proxy.newProxyInstance(</span><br><span class="line">            Subject.class.getClassLoader(),</span><br><span class="line">            new Class[] &#123; Subject.class &#125;, proxy);</span><br></pre></td></tr></table></figure>
<p>4.通过 Subject代理调用RealSubject实现类的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String info = sub.say(“Peter&quot;, 24);</span><br><span class="line"> System.out.println(info);</span><br></pre></td></tr></table></figure>
<h2 id="14-7-3-动态代理与AOP（Aspect-Orient-Programming"><a href="#14-7-3-动态代理与AOP（Aspect-Orient-Programming" class="headerlink" title="14.7.3 动态代理与AOP（Aspect Orient Programming)"></a>14.7.3 动态代理与AOP（Aspect Orient Programming)</h2><p>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下面介绍一种更实用的动态代理机制</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153928.png" alt></p>
<p>改进后的说明：代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和一个特定的方法A耦合了！最理想的效果是：代码块1、2、3既可以执行方法A，又无须在程序中以硬编码的方式直接调用深色代码的方法</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153949.png" alt></p>
<p>代码演示 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">public interface Dog &#123;</span><br><span class="line">	void info();</span><br><span class="line"></span><br><span class="line">	void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HuntingDog implements Dog &#123;</span><br><span class="line">	public void info() &#123;</span><br><span class="line">		System.out.println(&quot;我是一只猎狗&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;我奔跑迅速&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DogUtil &#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;=====模拟通用方法一=====&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method2() &#123;</span><br><span class="line">		System.out.println(&quot;=====模拟通用方法二=====&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DogUtil &#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;=====模拟通用方法一=====&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method2() &#123;</span><br><span class="line">		System.out.println(&quot;=====模拟通用方法二=====&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DogUtil &#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;=====模拟通用方法一=====&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method2() &#123;</span><br><span class="line">		System.out.println(&quot;=====模拟通用方法二=====&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">	// 需要被代理的对象</span><br><span class="line">	private Object target;</span><br><span class="line"></span><br><span class="line">	public void setTarget(Object target) &#123;</span><br><span class="line">		this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 执行动态代理对象的所有方法时，都会被替换成执行如下的invoke方法</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Exception &#123;</span><br><span class="line">		DogUtil du = new DogUtil();</span><br><span class="line">		// 执行DogUtil对象中的method1。</span><br><span class="line">		du.method1();</span><br><span class="line">		// 以target作为主调来执行method方法</span><br><span class="line">		Object result = method.invoke(target, args);</span><br><span class="line">		// 执行DogUtil对象中的method2。</span><br><span class="line">		du.method2();</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">	// 需要被代理的对象</span><br><span class="line">	private Object target;</span><br><span class="line"></span><br><span class="line">	public void setTarget(Object target) &#123;</span><br><span class="line">		this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 执行动态代理对象的所有方法时，都会被替换成执行如下的invoke方法</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Exception &#123;</span><br><span class="line">		DogUtil du = new DogUtil();</span><br><span class="line">		// 执行DogUtil对象中的method1。</span><br><span class="line">		du.method1();</span><br><span class="line">		// 以target作为主调来执行method方法</span><br><span class="line">		Object result = method.invoke(target, args);</span><br><span class="line">		// 执行DogUtil对象中的method2。</span><br><span class="line">		du.method2();</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyProxyFactory &#123;</span><br><span class="line">	// 为指定target生成动态代理对象</span><br><span class="line">	public static Object getProxy(Object target) throws Exception &#123;</span><br><span class="line">		// 创建一个MyInvokationHandler对象</span><br><span class="line">		MyInvokationHandler handler = new MyInvokationHandler();</span><br><span class="line">		// 为MyInvokationHandler设置target对象</span><br><span class="line">		handler.setTarget(target);</span><br><span class="line">		// 创建、并返回一个动态代理对象</span><br><span class="line">		return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyProxyFactory &#123;</span><br><span class="line">	// 为指定target生成动态代理对象</span><br><span class="line">	public static Object getProxy(Object target) throws Exception &#123;</span><br><span class="line">		// 创建一个MyInvokationHandler对象</span><br><span class="line">		MyInvokationHandler handler = new MyInvokationHandler();</span><br><span class="line">		// 为MyInvokationHandler设置target对象</span><br><span class="line">		handler.setTarget(target);</span><br><span class="line">		// 创建、并返回一个动态代理对象</span><br><span class="line">		return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">		throws Exception&#123;</span><br><span class="line">		// 创建一个原始的HuntingDog对象，作为target</span><br><span class="line">		Dog target = new HuntingDog();</span><br><span class="line">		// 以指定的target来创建动态代理</span><br><span class="line">		Dog dog = (Dog)MyProxyFactory.getProxy(target);</span><br><span class="line">		dog.info();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理</li>
<li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154040.png" alt></p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpeg" alt>
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpeg" alt>
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/01/29/13. JavaSE-IO流/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/02/19/15. JavaSE-多线程/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment"></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "b8cfVAxSX9whYsIOMmxwCicp-gzGzoHsz",
            appKey: "klYDKAeEh6GPa0wnf22lQd96",
            avatar:'identicon',
            placeholder: "ヾﾉ≧∀≦)o 来呀！快活呀！~",
            guest_info:guest_info,
            pageSize:'10'
        });
    </script>
  
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>

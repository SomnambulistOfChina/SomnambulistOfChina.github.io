<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>07 web-Servlet概述 | SomnambulistOfChina</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="JavaWeb概述,">
  

  <meta name="description" content="1    Why？我们为什么需要Servlet？1.1    Web应用基本运行模式①生活中的例子  ②Web应用运行模式  1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。 2    What？什么是Servlet？●如果把Web应用比作一个餐厅，Servlet就是餐厅中的服务员——负责接待顾客、上菜、结账。  ●从广义上来讲，Servlet规范是Sun公司">
<meta name="keywords" content="JavaWeb概述">
<meta property="og:type" content="article">
<meta property="og:title" content="07 web-Servlet概述">
<meta property="og:url" content="http://yoursite.com/2017/10/30/26 web-Servlet概述/index.html">
<meta property="og:site_name" content="SomnambulistOfChina">
<meta property="og:description" content="1    Why？我们为什么需要Servlet？1.1    Web应用基本运行模式①生活中的例子  ②Web应用运行模式  1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。 2    What？什么是Servlet？●如果把Web应用比作一个餐厅，Servlet就是餐厅中的服务员——负责接待顾客、上菜、结账。  ●从广义上来讲，Servlet规范是Sun公司">
<meta property="og:locale" content="Java EE">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110357.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110525.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111327.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111650.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606113122.png">
<meta property="og:updated_time" content="2019-06-06T15:07:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="07 web-Servlet概述">
<meta name="twitter:description" content="1    Why？我们为什么需要Servlet？1.1    Web应用基本运行模式①生活中的例子  ②Web应用运行模式  1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。 2    What？什么是Servlet？●如果把Web应用比作一个餐厅，Servlet就是餐厅中的服务员——负责接待顾客、上菜、结账。  ●从广义上来讲，Servlet规范是Sun公司">
<meta name="twitter:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110357.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?99d997f72fffd95d0fd1477dd657eafc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
  
</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">更多</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">更多</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Why？我们为什么需要Servlet？"><span class="toc-text">1    Why？我们为什么需要Servlet？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Web应用基本运行模式"><span class="toc-text">1.1    Web应用基本运行模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。"><span class="toc-text">1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-What？什么是Servlet？"><span class="toc-text">2    What？什么是Servlet？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-How？如何使用Servlet？"><span class="toc-text">3    How？如何使用Servlet？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-操作步骤"><span class="toc-text">3.1    操作步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-运行分析"><span class="toc-text">3.2    运行分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Servlet技术体系（了解）"><span class="toc-text">4    Servlet技术体系（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Servlet"><span class="toc-text">4.1    Servlet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-ServletConfig接口"><span class="toc-text">4.2    ServletConfig接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-ServletContext接口"><span class="toc-text">4.3    ServletContext接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-HttpServletRequest接口"><span class="toc-text">4.4    HttpServletRequest接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-HttpServletResponse接口"><span class="toc-text">4.5    HttpServletResponse接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Servlet生命周期"><span class="toc-text">5    Servlet生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Servlet生命周期的主要过程"><span class="toc-text">5.3    Servlet生命周期的主要过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#①Servlet对象的创建"><span class="toc-text">①Servlet对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#②Servlet对象初始化"><span class="toc-text">②Servlet对象初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#③处理请求"><span class="toc-text">③处理请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#④Servlet对象销毁"><span class="toc-text">④Servlet对象销毁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-ServletConfig接口"><span class="toc-text">6    ServletConfig接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-ServletConfig对象的主要功能"><span class="toc-text">6.2    ServletConfig对象的主要功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-ServletContext接口"><span class="toc-text">7    ServletContext接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-HttpServletRequest接口"><span class="toc-text">8    HttpServletRequest接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-HttpServletResponse接口"><span class="toc-text">9    HttpServletResponse接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-请求的转发与重定向"><span class="toc-text">10    请求的转发与重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-请求的转发"><span class="toc-text">10.2    请求的转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-请求的重定向"><span class="toc-text">10.3    请求的重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-对比请求的转发和重定向"><span class="toc-text">10.4    对比请求的转发和重定向</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-26 web-Servlet概述" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">07 web-Servlet概述</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.10.30</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>SomnambulistOfChina</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="1-Why？我们为什么需要Servlet？"><a href="#1-Why？我们为什么需要Servlet？" class="headerlink" title="1    Why？我们为什么需要Servlet？"></a>1    Why？我们为什么需要Servlet？</h1><h2 id="1-1-Web应用基本运行模式"><a href="#1-1-Web应用基本运行模式" class="headerlink" title="1.1    Web应用基本运行模式"></a>1.1    Web应用基本运行模式</h2><p>①生活中的例子</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110357.png" alt></p>
<p>②Web应用运行模式</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110604.png" alt></p>
<h2 id="1-2-通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。"><a href="#1-2-通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。" class="headerlink" title="1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。"></a>1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110525.png" alt></p>
<h1 id="2-What？什么是Servlet？"><a href="#2-What？什么是Servlet？" class="headerlink" title="2    What？什么是Servlet？"></a>2    What？什么是Servlet？</h1><p>●如果把Web应用比作一个餐厅，Servlet就是餐厅中的服务员——负责接待顾客、上菜、结账。</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110646.png" alt></p>
<p>●从广义上来讲，Servlet规范是Sun公司制定的一套技术标准，包含与Web应用相关的一系列接口，是Web应用实现方式的宏观解决方案。而具体的Servlet容器负责提供标准的实现。<br>●从狭义上来讲，Servlet指的是javax.servlet.Servlet接口及其子接口，也可以指实现了Servlet接口的实现类。<br>●Servlet作为服务器端的一个组件，它的本意是“服务器端的小程序”。Servlet的实例对象由Servlet容器负责创建；Servlet的方法由容器在特定情况下调用；Servlet容器会在Web应用卸载时销毁Servlet对象的实例。  </p>
<h1 id="3-How？如何使用Servlet？"><a href="#3-How？如何使用Servlet？" class="headerlink" title="3    How？如何使用Servlet？"></a>3    How？如何使用Servlet？</h1><h2 id="3-1-操作步骤"><a href="#3-1-操作步骤" class="headerlink" title="3.1    操作步骤"></a>3.1    操作步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①搭建Web开发环境  </span><br><span class="line">②创建动态Web工程  </span><br><span class="line">③创建javax.servlet.Servlet接口的实现类：com.atguigu.servlet.MyFirstServlet  </span><br><span class="line">④在service(ServletRequest, ServletResponse)方法中编写如下代码，输出响应信息：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		//1.编写输出语句，证明当前方法被调用</span><br><span class="line">		System.out.println(&quot;Servlet worked...&quot;);</span><br><span class="line">		//2.通过PrintWriter对象向浏览器端发送响应信息</span><br><span class="line">		PrintWriter writer = res.getWriter();</span><br><span class="line">		writer.write(&quot;Servlet response&quot;);</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>⑤在web.xml配置文件中注册MyFirstServlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 声明一个Servlet --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;!-- 为Servlet指定一个名称，以便于引用 --&gt;</span><br><span class="line">	&lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;!-- 注册Servlet实现类的全类名 --&gt;</span><br><span class="line">	&lt;servlet-class&gt;com.atguigu.servlet.MyFirstServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 建立一个从虚拟路径到Servlet之间的映射关系 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;!-- 引用Servlet名称 --&gt;</span><br><span class="line">	&lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;!-- 映射到Servlet的虚拟路径：“/MyFirstServlet” --&gt;</span><br><span class="line">	&lt;url-pattern&gt;/MyFirstServlet&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>⑥在WebContent目录下创建index.html<br>⑦在index.html中加入超链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;MyFirstServlet&quot;&gt;To Servlet&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>⑧点击超链接测试Servlet</p>
<h2 id="3-2-运行分析"><a href="#3-2-运行分析" class="headerlink" title="3.2    运行分析"></a>3.2    运行分析</h2><ul>
<li>index.html</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110954.png" alt>    </p>
<ul>
<li>web.xml</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111017.png" alt></p>
<h1 id="4-Servlet技术体系（了解）"><a href="#4-Servlet技术体系（了解）" class="headerlink" title="4    Servlet技术体系（了解）"></a>4    Servlet技术体系（了解）</h1><h2 id="4-1-Servlet"><a href="#4-1-Servlet" class="headerlink" title="4.1    Servlet"></a>4.1    Servlet</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111053.png" alt></p>
<p>①Servlet接口</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111115.png" alt></p>
<p>②GenericServlet抽象类</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111136.png" alt></p>
<p>●对Servlet功能进行了封装和完善，将service(ServletRequest req, ServletResponse res)保留为抽象方法，让使用者仅关心业务实现即可。  </p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111225.png" alt></p>
<p>③HttpServlet抽象类</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111248.png" alt></p>
<p>●对GenericServlet进行了进一步的封装和扩展，更贴近HTTP协议下的应用程序编写，在service(ServletRequest req, ServletResponse res)方法中，根据不同HTTP请求类型调用专门的方法进行处理。<br>●今后在实际使用中继承HttpServlet抽象类创建自己的Servlet实现类即可。重写doGet(HttpServletRequest req, HttpServletResponse resp)和doPost(HttpServletRequest req, HttpServletResponse resp)方法实现请求处理，不再需要重写service(ServletRequest req, ServletResponse res)方法了。  </p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111327.png" alt></p>
<h2 id="4-2-ServletConfig接口"><a href="#4-2-ServletConfig接口" class="headerlink" title="4.2    ServletConfig接口"></a>4.2    ServletConfig接口</h2><p>封装了Servlet配置信息</p>
<h2 id="4-3-ServletContext接口"><a href="#4-3-ServletContext接口" class="headerlink" title="4.3    ServletContext接口"></a>4.3    ServletContext接口</h2><p>封装了当前Web应用上下文信息</p>
<h2 id="4-4-HttpServletRequest接口"><a href="#4-4-HttpServletRequest接口" class="headerlink" title="4.4    HttpServletRequest接口"></a>4.4    HttpServletRequest接口</h2><p>封装了HTTP请求信息，ServletRequest的子接口</p>
<h2 id="4-5-HttpServletResponse接口"><a href="#4-5-HttpServletResponse接口" class="headerlink" title="4.5    HttpServletResponse接口"></a>4.5    HttpServletResponse接口</h2><p>封装了HTTP响应信息，ServletResponse的子接口</p>
<h1 id="5-Servlet生命周期"><a href="#5-Servlet生命周期" class="headerlink" title="5    Servlet生命周期"></a>5    Servlet生命周期</h1><p>5.1    应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。<br>5.2    Servlet对象是Servlet容器创建的，生命周期方法都是由容器调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。  </p>
<h2 id="5-3-Servlet生命周期的主要过程"><a href="#5-3-Servlet生命周期的主要过程" class="headerlink" title="5.3    Servlet生命周期的主要过程"></a>5.3    Servlet生命周期的主要过程</h2><h3 id="①Servlet对象的创建"><a href="#①Servlet对象的创建" class="headerlink" title="①Servlet对象的创建"></a>①Servlet对象的创建</h3><p>默认情况下，Servlet容器第一次收到HTTP请求时创建对应Servlet对象。容器之所以能做到这一点是由于我们在注册Servlet时提供了全类名，容器使用反射技术创建了Servlet的对象。</p>
<h3 id="②Servlet对象初始化"><a href="#②Servlet对象初始化" class="headerlink" title="②Servlet对象初始化"></a>②Servlet对象初始化</h3><p>●Servlet容器创建Servlet对象之后，会调用init(ServletConfig config)方法，对其进行初始化。在javax.servlet.Servlet接口中，public void init(ServletConfig config)方法要求容器将ServletConfig的实例对象传入，这也是我们获取ServletConfig的实例对象的根本方法。  </p>
<h3 id="③处理请求"><a href="#③处理请求" class="headerlink" title="③处理请求"></a>③处理请求</h3><p>●在javax.servlet.Servlet接口中，定义了service(ServletRequest req, ServletResponse res)方法处理HTTP请求，同时要求容器将ServletRequest对象和ServletResponse对象传入。</p>
<h3 id="④Servlet对象销毁"><a href="#④Servlet对象销毁" class="headerlink" title="④Servlet对象销毁"></a>④Servlet对象销毁</h3><p>●服务器重启或服务器停止执行时会销毁Servlet对象，而销毁之前为了执行一些诸如释放缓存、关闭连接、保存数据等操作，所以设计了public void destroy()方法。</p>
<h1 id="6-ServletConfig接口"><a href="#6-ServletConfig接口" class="headerlink" title="6    ServletConfig接口"></a>6    ServletConfig接口</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111546.png" alt></p>
<p>6.1    ServletConfig接口封装了Servlet配置信息，这一点从接口的名称上就能够看出来。但同时，代表当前Web应用的ServletContext对象也封装到了ServletConfig对象中，使ServletConfig对象成为了获取ServletContext对象的一座桥梁。  </p>
<h2 id="6-2-ServletConfig对象的主要功能"><a href="#6-2-ServletConfig对象的主要功能" class="headerlink" title="6.2    ServletConfig对象的主要功能"></a>6.2    ServletConfig对象的主要功能</h2><p>①获取Servlet名称<br>②获取Servlet初始化参数<br>③获取ServletContext对象  </p>
<h1 id="7-ServletContext接口"><a href="#7-ServletContext接口" class="headerlink" title="7    ServletContext接口"></a>7    ServletContext接口</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111633.png" alt></p>
<p>7.1    Web容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前Web应用——作用很像餐厅的经理。</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111650.png" alt></p>
<p>7.2    由于一个Web应用程序中的所有Servlet都共享同一个ServletContext对象，所以ServletContext对象也被称为 application 对象（Web应用程序对象）。<br>7.3    在应用程序中能够获取运行环境或容器信息的对象通常称之为“上下文对象”。<br>7.4    ServletContext对象的主要功能<br>①获取WEB应用程序的初始化参数<br>●设置Web应用初始化参数的方式是在web.xml的根标签下加入如下代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Web应用初始化参数 --&gt;</span><br><span class="line">	&lt;context-param&gt;</span><br><span class="line">		&lt;param-name&gt;ParamName&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;ParamValue&lt;/param-value&gt;</span><br><span class="line">	&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>
<p>●获取Web应用初始化参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		//1.获取ServletContext对象</span><br><span class="line">		ServletContext context = this.getServletContext();</span><br><span class="line">		//2.获取Web应用初始化参数</span><br><span class="line">		String paramValue = context.getInitParameter(&quot;ParamName&quot;);</span><br><span class="line">		System.out.println(&quot;paramValue=&quot;+paramValue);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>②获取虚拟路径所映射的本地路径<br>●虚拟路径：浏览器访问Web应用中资源时所使用的路径。<br>●本地路径：资源在文件系统中的实际保存路径。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		//1.获取ServletContext对象</span><br><span class="line">		ServletContext context = this.getServletContext();</span><br><span class="line">		//2.获取index.html的本地路径</span><br><span class="line">		//index.html的虚拟路径是“/index.html”,其中“/”表示当前Web应用的根目录，</span><br><span class="line">		//即WebContent目录</span><br><span class="line">		String realPath = context.getRealPath(&quot;/index.html&quot;);</span><br><span class="line">		//realPath=D:\DevWorkSpace\MyWorkSpace\.metadata\.plugins\</span><br><span class="line">		//org.eclipse.wst.server.core\tmp0\wtpwebapps\MyServlet\index.html</span><br><span class="line">		System.out.println(&quot;realPath=&quot;+realPath);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>③application域范围的属性</p>
<h1 id="8-HttpServletRequest接口"><a href="#8-HttpServletRequest接口" class="headerlink" title="8    HttpServletRequest接口"></a>8    HttpServletRequest接口</h1><p>①该接口是ServletRequest接口的子接口，封装了HTTP请求的相关信息，由Servlet容器创建其实现类对象并传入service(ServletRequest req, ServletResponse res)方法中。以下我们所说的HttpServletRequest对象指的是容器提供的HttpServletRequest实现类对象。<br>②HttpServletRequest对象的主要功能有<br>●获取请求参数。<br>●在请求域中保存数据。<br>●将请求转发给另外一个URL地址，参见[请求的转发与重定向]。<br>●获取项目虚拟路径。  </p>
<h1 id="9-HttpServletResponse接口"><a href="#9-HttpServletResponse接口" class="headerlink" title="9    HttpServletResponse接口"></a>9    HttpServletResponse接口</h1><p>①该接口是ServletResponse接口的子接口，封装了HTTP响应的相关信息，由Servlet容器创建其实现类对象并传入service(ServletRequest req, ServletResponse res)方法中。以下我们所说的HttpServletResponse对象指的是容器提供的HttpServletResponse实现类对象。<br>②主要功能<br>●使用PrintWriter对象向浏览器输出数据<br>●实现请求重定向，参见[请求的转发与重定向]。  </p>
<h1 id="10-请求的转发与重定向"><a href="#10-请求的转发与重定向" class="headerlink" title="10    请求的转发与重定向"></a>10    请求的转发与重定向</h1><p>10.1    请求的转发与重定向是Servlet控制页面跳转的主要方法，在Web应用中使用非常广泛。  </p>
<h2 id="10-2-请求的转发"><a href="#10-2-请求的转发" class="headerlink" title="10.2    请求的转发"></a>10.2    请求的转发</h2><p>①Servlet接收到浏览器端请求后，进行一定的处理，先不进行响应，而是在服务器端内部“转发”给其他Servlet程序继续处理。在这种情况下浏览器端只发出了一次请求，浏览器地址栏不会发生变化，用户也感知不到请求被转发了。<br>②转发请求的Servlet和目标Servlet共享同一个request对象。<br>③实现转发的API  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		//1.使用RequestDispatcher对象封装目标资源的虚拟路径</span><br><span class="line">		RequestDispatcher dispatcher = request</span><br><span class="line">				.getRequestDispatcher(&quot;/index.html&quot;);</span><br><span class="line">		//2.调用RequestDispatcher对象的forward()方法“前往”目标资源</span><br><span class="line">		//[注意：传入的参数必须是传递给当前Servlet的service方法的</span><br><span class="line">		//那两个ServletRequest和ServletResponse对象]</span><br><span class="line">		dispatcher.forward(request, response);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-3-请求的重定向"><a href="#10-3-请求的重定向" class="headerlink" title="10.3    请求的重定向"></a>10.3    请求的重定向</h2><p>①Servlet接收到浏览器端请求并处理完成后，给浏览器端一个特殊的响应，这个特殊的响应要求浏览器去请求一个新的资源，整个过程中浏览器端会发出两次请求，且浏览器地址栏会改变为新资源的地址。<br>②重定向的情况下，原Servlet和目标资源之间就不能共享请求域数据了。<br>③实现重定向的API  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		//1.调用HttpServletResponse对象的sendRedirect()方法</span><br><span class="line">		//2.传入的参数是目标资源的虚拟路径</span><br><span class="line">		response.sendRedirect(&quot;index.html&quot;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-4-对比请求的转发和重定向"><a href="#10-4-对比请求的转发和重定向" class="headerlink" title="10.4    对比请求的转发和重定向"></a>10.4    对比请求的转发和重定向</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606113122.png" alt></p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpeg" alt>
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpeg" alt>
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/10/27/25 web-HTTP协议/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/11/03/27 web-JSP概述/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment"></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "b8cfVAxSX9whYsIOMmxwCicp-gzGzoHsz",
            appKey: "klYDKAeEh6GPa0wnf22lQd96",
            avatar:'identicon',
            placeholder: "ヾﾉ≧∀≦)o 来呀！快活呀！~",
            guest_info:guest_info,
            pageSize:'10'
        });
    </script>
  
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>

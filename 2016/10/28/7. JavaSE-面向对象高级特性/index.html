<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>7. JavaSE-面向对象高级特性 | SomnambulistOfChina</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java SE,">
  

  <meta name="description" content="7.1 Object类7.1.1 Object类的特点 Object类是所有类的根父类, 也就是说如果一个类没有显式声明父类, 那么这个类的父类就是Object类,所以, Object类中的属性和方法会被所有类继承, 都可以直接调用.  7.1.2 类中的典型方法1. toString()1public String toString() 这个方法返回当前对象的一个字符串表示, 通常用于描述这个对">
<meta name="keywords" content="Java SE">
<meta property="og:type" content="article">
<meta property="og:title" content="7. JavaSE-面向对象高级特性">
<meta property="og:url" content="http://yoursite.com/2016/10/28/7. JavaSE-面向对象高级特性/index.html">
<meta property="og:site_name" content="SomnambulistOfChina">
<meta property="og:description" content="7.1 Object类7.1.1 Object类的特点 Object类是所有类的根父类, 也就是说如果一个类没有显式声明父类, 那么这个类的父类就是Object类,所以, Object类中的属性和方法会被所有类继承, 都可以直接调用.  7.1.2 类中的典型方法1. toString()1public String toString() 这个方法返回当前对象的一个字符串表示, 通常用于描述这个对">
<meta property="og:locale" content="Java EE">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100642.png">
<meta property="og:image" content="http://note.youdao.com/yws/res/5869/67679F24EB994B5487180C512B907812">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100959.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101645.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101723.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103212.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103339.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103531.png">
<meta property="og:updated_time" content="2019-06-06T15:12:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7. JavaSE-面向对象高级特性">
<meta name="twitter:description" content="7.1 Object类7.1.1 Object类的特点 Object类是所有类的根父类, 也就是说如果一个类没有显式声明父类, 那么这个类的父类就是Object类,所以, Object类中的属性和方法会被所有类继承, 都可以直接调用.  7.1.2 类中的典型方法1. toString()1public String toString() 这个方法返回当前对象的一个字符串表示, 通常用于描述这个对">
<meta name="twitter:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095828.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?99d997f72fffd95d0fd1477dd657eafc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
  
</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">更多</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">更多</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#7-1-Object类"><span class="toc-text">7.1 Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-1-Object类的特点"><span class="toc-text">7.1.1 Object类的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-2-类中的典型方法"><span class="toc-text">7.1.2 类中的典型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-toString"><span class="toc-text">1. toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-equals"><span class="toc-text">2. equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-hashCode"><span class="toc-text">3. hashCode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-3-Object的使用"><span class="toc-text">7.1.3 Object的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-4-Object的注意点"><span class="toc-text">7.1.4 Object的注意点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-2-static关键字"><span class="toc-text">7.2 static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-1-static关键字含义"><span class="toc-text">7.2.1 static关键字含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-为什么要使用static"><span class="toc-text">1. 为什么要使用static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-使用了static后的变化"><span class="toc-text">2. 使用了static后的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-使用范围："><span class="toc-text">3.使用范围：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-被修饰后的成员具备以下特点："><span class="toc-text">4.被修饰后的成员具备以下特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-2-static修饰属性"><span class="toc-text">7.2.2 static修饰属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-类属性"><span class="toc-text">1. 类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类属性的存储"><span class="toc-text">2. 类属性的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-类属性的使用"><span class="toc-text">3. 类属性的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-静态属性的特点"><span class="toc-text">4. 静态属性的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-3-static-修饰方法"><span class="toc-text">7.2.3 static 修饰方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-类方法-class-Method"><span class="toc-text">1. 类方法(class Method)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类方法特点"><span class="toc-text">2. 类方法特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-4单例设计模式"><span class="toc-text">7.2.4单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉式"><span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉式"><span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举例"><span class="toc-text">举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-3-代码块"><span class="toc-text">7.3 代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-1-什么是代码块"><span class="toc-text">7.3.1 什么是代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是代码块"><span class="toc-text">1. 什么是代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-静态代码块"><span class="toc-text">2.静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-非静态代码块"><span class="toc-text">3. 非静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-静态和非静态关系"><span class="toc-text">4 静态和非静态关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非静态的本质是什么"><span class="toc-text">非静态的本质是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态的本质是什么"><span class="toc-text">静态的本质是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何互相使用"><span class="toc-text">如何互相使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-2-执行顺序"><span class="toc-text">7.3.2 执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-创建对象时-在同一个类中执行顺序"><span class="toc-text">1. 创建对象时, 在同一个类中执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-创建对象时-有继承关系存在时执行顺序"><span class="toc-text">2. 创建对象时, 有继承关系存在时执行顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-4-final关键字"><span class="toc-text">7.4 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-1-final关键字的含义"><span class="toc-text">7.4.1 final关键字的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-final的作用"><span class="toc-text">1. final的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-2-final修饰类"><span class="toc-text">7.4.2 final修饰类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-3-final修饰方法"><span class="toc-text">7.4.3 final修饰方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-4-final修饰变量"><span class="toc-text">7.4.4 final修饰变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-5-空final量和final修饰局部变量"><span class="toc-text">7.7.5 空final量和final修饰局部变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-5-native关键字"><span class="toc-text">7.5 native关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-1-native含义"><span class="toc-text">7.5.1 native含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-2-native关键字使用场景"><span class="toc-text">7.5.2 native关键字使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-3-native关键字特点"><span class="toc-text">7.5.3 native关键字特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-6-抽象类"><span class="toc-text">7.6 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-1-抽象类概念"><span class="toc-text">7.6.1 抽象类概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-抽象类-abstract-class"><span class="toc-text">1.抽象类(abstract class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-抽象类和具体类"><span class="toc-text">2. 抽象类和具体类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-2特点"><span class="toc-text">7.6.2特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-3抽象类使用"><span class="toc-text">7.6.3抽象类使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-4-使用场景"><span class="toc-text">7.6.4 使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-7-接口"><span class="toc-text">7.7 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-1-接口的概念"><span class="toc-text">7.7.1 接口的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是接口"><span class="toc-text">1. 什么是接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-接口的组成"><span class="toc-text">2. 接口的组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-2-接口的使用"><span class="toc-text">7.7.2 接口的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-3-接口的注意事项"><span class="toc-text">7.7.3 接口的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-4-接口小结"><span class="toc-text">7.7.4 接口小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-5-接口和抽象类的关系"><span class="toc-text">7.7.5 接口和抽象类的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-6-接口在java8中的变化"><span class="toc-text">7.7.6 接口在java8中的变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-8-内部类"><span class="toc-text">7.8 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-1-什么是内部类"><span class="toc-text">7.8.1 什么是内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-2-成员内部类"><span class="toc-text">7.8.2 成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-普通内部类"><span class="toc-text">1. 普通内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-嵌套类"><span class="toc-text">2. 嵌套类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-3-局部内部类"><span class="toc-text">7.8.3 局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概念"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-普通局部内部类"><span class="toc-text">2. 普通局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-匿名内部类"><span class="toc-text">3. 匿名内部类</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-7. JavaSE-面向对象高级特性" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">7. JavaSE-面向对象高级特性</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.10.28</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>SomnambulistOfChina</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaSE基础/">JavaSE基础</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="7-1-Object类"><a href="#7-1-Object类" class="headerlink" title="7.1 Object类"></a>7.1 Object类</h1><h2 id="7-1-1-Object类的特点"><a href="#7-1-1-Object类的特点" class="headerlink" title="7.1.1 Object类的特点"></a>7.1.1 Object类的特点</h2><blockquote>
<p>Object类是所有类的根父类, 也就是说如果一个类没有显式声明父类, 那么这个类的父类就是Object类,<br>所以, Object类中的属性和方法会被所有类继承, 都可以直接调用.</p>
</blockquote>
<h2 id="7-1-2-类中的典型方法"><a href="#7-1-2-类中的典型方法" class="headerlink" title="7.1.2 类中的典型方法"></a>7.1.2 类中的典型方法</h2><h3 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString()"></a>1. toString()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String toString()</span><br></pre></td></tr></table></figure>
<p>这个方法返回当前对象的一个字符串表示, 通常用于描述这个对象的内容.<br>这个方法也会在对象被打印和与字符串拼接时自动调用, 结果还是一个字符串.</p>
<h3 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals()"></a>2. equals()</h3><p>表示两个对象内容是否相等, 通常情况下, 两个不同的对象是不相等的, 但是我们可以通过覆盖这个方法,实现两个内容相等, 但不同的对象之间具有等同性比较能力. </p>
<h3 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode()"></a>3. hashCode()</h3><p>当两个对象的内容相等时, <strong>equals方法的结果就应该返回true</strong>, 但同时这两个对象调用hashCode方法返回的哈希码值也必须要相等, 相同的道理, 两个hashCode码值不同的对象, <strong>equals方法一定返回false</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">	</span><br><span class="line">	private int x;</span><br><span class="line">	private int y;</span><br><span class="line">	</span><br><span class="line">	public Point() &#123;&#125;</span><br><span class="line">	public Point(int x, int y) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setX(int x) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getX() &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setY(int y) &#123;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getY() &#123;</span><br><span class="line">		return y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String say() &#123;</span><br><span class="line">		return &quot;X:&quot; + x + &quot;,Y:&quot; + y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override // 可以完成真实的比较</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (obj instanceof Point &amp;&amp; this.x == ((Point)obj).x &amp;&amp; this.y == ((Point)obj).y) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		return Integer.parseInt(x * 10 + &quot;&quot; + y * 10);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 返回对象的字符串表示, 通常在打印对象时调用</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;x:&quot; + x + &quot;,y:&quot; + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class PointTest &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Point p1 = new Point(10, 20);</span><br><span class="line">		Point p2 = new Point(10, 20);</span><br><span class="line">		System.out.println(p1 == p2); // 打印false, 因为比较两个对象的地址</span><br><span class="line">		boolean b = p1.equals(p2); // 返回true, 因为比较两个对象的内容</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		</span><br><span class="line">		System.out.println(p1.hashCode()); // 两个对象的哈希码也都一样</span><br><span class="line">		System.out.println(p2.hashCode());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		System.out.println(p1); // 打印对象时, 打印的其实是对象的toString()方法的结果</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-1-3-Object的使用"><a href="#7-1-3-Object的使用" class="headerlink" title="7.1.3 Object的使用"></a>7.1.3 Object的使用</h2><p>Object类型通常用于表示任意对象的引用类型, 使用Object类型可以兼容任意对象, 很灵活方便, 也因为Object类是根父类, 所以其中的方法具有普遍性, 便于统一处理.</p>
<h2 id="7-1-4-Object的注意点"><a href="#7-1-4-Object的注意点" class="headerlink" title="7.1.4 Object的注意点"></a>7.1.4 Object的注意点</h2><p>因为Object类型是父类类型, 所以Object类型的对象究竟是什么类型的对象就变得非常复杂, 所以想要处理不同的子类对象, 比较麻烦, 需要配合instanceof操作符和类型转换. </p>
<h1 id="7-2-static关键字"><a href="#7-2-static关键字" class="headerlink" title="7.2 static关键字"></a>7.2 static关键字</h1><h2 id="7-2-1-static关键字含义"><a href="#7-2-1-static关键字含义" class="headerlink" title="7.2.1 static关键字含义"></a>7.2.1 static关键字含义</h2><h3 id="1-为什么要使用static"><a href="#1-为什么要使用static" class="headerlink" title="1. 为什么要使用static"></a>1. 为什么要使用static</h3><blockquote>
<ul>
<li>有一些数据不必要隶属于每个对象, 例如Chinese类的country属性就应该是China,并且所有对象都应该是相同的, 这样的数据就可以声明成static的, 这样的数据就隶属于类, 通过类就可以直接访问, 当然通过对象也可以访问. </li>
<li>有一些方法也是相同的道理, 可以被static修饰, 这样的方法只需要通过类调用即可, 不需要创建对象.</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095828.png" alt></p>
<h3 id="2-使用了static后的变化"><a href="#2-使用了static后的变化" class="headerlink" title="2. 使用了static后的变化"></a>2. 使用了static后的变化</h3><p>使用了static以后的数据不再是不确定的, 就像对象的创建就是不确定的(也可称之为动态), static是确定的, 和动态形成对比, 所以称之为静态. </p>
<h3 id="3-使用范围："><a href="#3-使用范围：" class="headerlink" title="3.使用范围："></a>3.使用范围：</h3><p>在Java类中，可用static修饰属性、方法、代码块、内部类</p>
<h3 id="4-被修饰后的成员具备以下特点："><a href="#4-被修饰后的成员具备以下特点：" class="headerlink" title="4.被修饰后的成员具备以下特点："></a>4.被修饰后的成员具备以下特点：</h3><p>①    随着类的加载而加载<br>②    优先于对象存在<br>③    修饰的成员，被所有对象所共享<br>④    访问权限允许时，可不创建对象，直接被类调用  </p>
<h2 id="7-2-2-static修饰属性"><a href="#7-2-2-static修饰属性" class="headerlink" title="7.2.2 static修饰属性"></a>7.2.2 static修饰属性</h2><h3 id="1-类属性"><a href="#1-类属性" class="headerlink" title="1. 类属性"></a>1. 类属性</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095936.png" alt></p>
<h3 id="2-类属性的存储"><a href="#2-类属性的存储" class="headerlink" title="2. 类属性的存储"></a>2. 类属性的存储</h3><p>类属性保存在方法区的类信息数据区中</p>
<h3 id="3-类属性的使用"><a href="#3-类属性的使用" class="headerlink" title="3. 类属性的使用"></a>3. 类属性的使用</h3><p>类属性可以直接通过类名使用</p>
<h3 id="4-静态属性的特点"><a href="#4-静态属性的特点" class="headerlink" title="4. 静态属性的特点"></a>4. 静态属性的特点</h3><p>因为隶属于类, 所以静态属性通常是共享数据</p>
<h2 id="7-2-3-static-修饰方法"><a href="#7-2-3-static-修饰方法" class="headerlink" title="7.2.3 static 修饰方法"></a>7.2.3 static 修饰方法</h2><h3 id="1-类方法-class-Method"><a href="#1-类方法-class-Method" class="headerlink" title="1. 类方法(class Method)"></a>1. 类方法(class Method)</h3><ul>
<li>没有对象的实例时，可以用类名.方法名()的形式访问由static标记的类方法。</li>
<li>在static方法内部只能访问类的static属性，不能访问类的非static属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">private int id;</span><br><span class="line">       private static int total = 0;</span><br><span class="line">       public static int getTotalPerson() &#123; </span><br><span class="line">	    		id++;	//非法</span><br><span class="line">				return total;</span><br><span class="line">       &#125;</span><br><span class="line">       public Person() &#123;</span><br><span class="line">         	total++;</span><br><span class="line"> 				id = total;</span><br><span class="line">       &#125;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line"> 				System.out.println(&quot;Number of total is &quot; +Person.getTotalPerson());</span><br><span class="line">				//没有创建对象也可以访问静态方法</span><br><span class="line"> 				Person p1 = new Person();</span><br><span class="line">     			System.out.println( &quot;Number of total is &quot;+ p1.getTotalPerson());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-类方法特点"><a href="#2-类方法特点" class="headerlink" title="2. 类方法特点"></a>2. 类方法特点</h3><p>类方法隶属于类, 不能在其中直接访问对象属性, 如果想要访问对象属性, 必须先创建对象, 通过对象再访问对象属性. 而在非静态方法中, 可以直接调用类方法.</p>
<h2 id="7-2-4单例设计模式"><a href="#7-2-4单例设计模式" class="headerlink" title="7.2.4单例设计模式"></a>7.2.4单例设计模式</h2><blockquote>
<ul>
<li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。</li>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造方法的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</li>
</ul>
</blockquote>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100642.png" alt></p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><img src="http://note.youdao.com/yws/res/5869/67679F24EB994B5487180C512B907812" alt="image"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100824.png" alt></p>
<h1 id="7-3-代码块"><a href="#7-3-代码块" class="headerlink" title="7.3 代码块"></a>7.3 代码块</h1><h2 id="7-3-1-什么是代码块"><a href="#7-3-1-什么是代码块" class="headerlink" title="7.3.1 什么是代码块"></a>7.3.1 什么是代码块</h2><h3 id="1-什么是代码块"><a href="#1-什么是代码块" class="headerlink" title="1. 什么是代码块"></a>1. 什么是代码块</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100959.png" alt></p>
<h3 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2.静态代码块"></a>2.静态代码块</h3><ul>
<li>一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。</li>
<li>static块通常用于初始化static (类)属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	public static int total;</span><br><span class="line">	static &#123;</span><br><span class="line">	        total = 100;//为total赋初值 </span><br><span class="line">	&#125;</span><br><span class="line">	…… //其它属性或方法声明</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-非静态代码块"><a href="#3-非静态代码块" class="headerlink" title="3. 非静态代码块"></a>3. 非静态代码块</h3><ul>
<li>概念：没有static修饰的代码块</li>
<li>特点：<br>①    可以有输出语句。<br>②    可以对类的属性、类的声明进行初始化操作。<br>③    可以调用静态的变量或方法。<br>④    若有多个非静态的代码块，那么按照从上到下的顺序依次执行。<br>⑤    每次创建对象的时候，都会执行一次。且先于构造器执行  </li>
</ul>
<h3 id="4-静态和非静态关系"><a href="#4-静态和非静态关系" class="headerlink" title="4 静态和非静态关系"></a>4 静态和非静态关系</h3><h4 id="非静态的本质是什么"><a href="#非静态的本质是什么" class="headerlink" title="非静态的本质是什么"></a>非静态的本质是什么</h4><p>非静态也可以称为动态, 意思是确定的, 在程序中对象的创建是不确定的, 因为只要new就会产生对象, 所以非静态的概念必然是和对象相关的.</p>
<h4 id="静态的本质是什么"><a href="#静态的本质是什么" class="headerlink" title="静态的本质是什么"></a>静态的本质是什么</h4><p>静态的就是确定的, 唯一的, 在程序中是稳定的, 和有无对象无关, 也和有多少对象无关, 只和类相关, 所以, 所以静态成员是稳定并唯一的.</p>
<h4 id="如何互相使用"><a href="#如何互相使用" class="headerlink" title="如何互相使用"></a>如何互相使用</h4><p>在非静态环境中可以中直接使用静态成员, 因为在非静态环境中, 对象必然是已经创建了, 对象既然已经创建, 类也肯定已经加载过了, 所以在使用上并不会有问题.</p>
<blockquote>
<p>但是 在静态环境中却不可以直接使用非静态成员, 因为静态成员可以使用, 不要求对象,只要求类加载好就可以了, 但是类加载, 并不意味着一定要创建对象, 并且对象创建在哪里也不知道. 所以在静态环境中不可以直接访问非静态成员, 因为非静态成员隶属于对象, 所以在静态环境中只能通过创建对象, 并再通过对象来间接访问非静态成员.</p>
</blockquote>
<h2 id="7-3-2-执行顺序"><a href="#7-3-2-执行顺序" class="headerlink" title="7.3.2 执行顺序"></a>7.3.2 执行顺序</h2><h3 id="1-创建对象时-在同一个类中执行顺序"><a href="#1-创建对象时-在同一个类中执行顺序" class="headerlink" title="1. 创建对象时, 在同一个类中执行顺序"></a>1. 创建对象时, 在同一个类中执行顺序</h3><p>在同一个类中, 如果创建这个类的对象, 执行顺序是</p>
<blockquote>
<p>1静态属性声明<br>2静态语句块或静态属性的显式初始化<br>3非静态属性声明<br>4非静态语句块或非静态属性的显式初始化<br>构造器</p>
</blockquote>
<h3 id="2-创建对象时-有继承关系存在时执行顺序"><a href="#2-创建对象时-有继承关系存在时执行顺序" class="headerlink" title="2. 创建对象时, 有继承关系存在时执行顺序"></a>2. 创建对象时, 有继承关系存在时执行顺序</h3><p>a)    父类的静态属性声明<br>b)    父类的静态语句块或父类静态属性的显式赋值<br>c)    子类的静态属性声明<br>d)    子类的静态语句块或子类静态属性的显式赋值<br>e)    父类非静态属性的声明<br>f)    子类非静态属性的声明<br>g)    父类的非静态语句块或父类非静态属性的显式赋值<br>h)    父类构造器<br>i)    子类的非静态语句块或子类非静态属性的显式赋值<br>j)    子类构造器  </p>
<h1 id="7-4-final关键字"><a href="#7-4-final关键字" class="headerlink" title="7.4 final关键字"></a>7.4 final关键字</h1><h2 id="7-4-1-final关键字的含义"><a href="#7-4-1-final关键字的含义" class="headerlink" title="7.4.1 final关键字的含义"></a>7.4.1 final关键字的含义</h2><h3 id="1-final的作用"><a href="#1-final的作用" class="headerlink" title="1. final的作用"></a>1. final的作用</h3><ul>
<li>在Java中声明类、属性和方法时，可使用关键字final来修饰,表示“最终”。</li>
<li>final标记的类不能被继承。提高安全性，提高程序的可读性。<br><code>比如：String类、System类、StringBuffer类</code></li>
<li>final标记的方法不能被子类重写。<br><code>比如：Object类中的getClass()。</code></li>
<li>final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。</li>
<li>final标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。<br><code>比如：final double PI=3.14;</code></li>
</ul>
<h2 id="7-4-2-final修饰类"><a href="#7-4-2-final修饰类" class="headerlink" title="7.4.2 final修饰类"></a>7.4.2 final修饰类</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101645.png" alt></p>
<h2 id="7-4-3-final修饰方法"><a href="#7-4-3-final修饰方法" class="headerlink" title="7.4.3 final修饰方法"></a>7.4.3 final修饰方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101723.png" alt></p>
<h2 id="7-4-4-final修饰变量"><a href="#7-4-4-final修饰变量" class="headerlink" title="7.4.4 final修饰变量"></a>7.4.4 final修饰变量</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101918.png" alt></p>
<h2 id="7-7-5-空final量和final修饰局部变量"><a href="#7-7-5-空final量和final修饰局部变量" class="headerlink" title="7.7.5 空final量和final修饰局部变量"></a>7.7.5 空final量和final修饰局部变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static int totalNumber = 5 ;</span><br><span class="line">	public final int ID; // 空final量, 在构造器中初始化</span><br><span class="line">	</span><br><span class="line">	public Test()&#123;</span><br><span class="line">		ID = ++totalNumber;  //可在构造方法中给final变量赋值</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Test t = new Test();</span><br><span class="line">		System.out.println(t.ID);		</span><br><span class="line">		final int I = 10;</span><br><span class="line">		final int J;</span><br><span class="line">		J = 20;</span><br><span class="line">		J = 30; // 不可以再次赋值</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-5-native关键字"><a href="#7-5-native关键字" class="headerlink" title="7.5 native关键字"></a>7.5 native关键字</h1><h2 id="7-5-1-native含义"><a href="#7-5-1-native含义" class="headerlink" title="7.5.1 native含义"></a>7.5.1 native含义</h2><blockquote>
<p>native表示本地的意思, 可以修饰方法, 被native修饰的方法没有方法体, 所谓本地就是代码是和当前操作系统密切相关的. 方法没有java代码的方法体, 但是一定是使用了C/C++等编写成的, 并且封装在操作系统相关的库文件中. 在执行这样的方法时, 实际执行的是库中的代码.</p>
</blockquote>
<h2 id="7-5-2-native关键字使用场景"><a href="#7-5-2-native关键字使用场景" class="headerlink" title="7.5.2 native关键字使用场景"></a>7.5.2 native关键字使用场景</h2><p>有一些代码需要和底层设备交互, 而这些交互的功能并未由JDK提供现成的类库, 那么必须使用native方式让java程序和库交互, 再由库完成对底层设备的使用.</p>
<h2 id="7-5-3-native关键字特点"><a href="#7-5-3-native关键字特点" class="headerlink" title="7.5.3 native关键字特点"></a>7.5.3 native关键字特点</h2><p><strong>特点</strong>：用native修饰的方法是调用的库中的代码, 所以这样的代码如果再换一个平台就会出现问题, 无法实现跨平台.</p>
<h1 id="7-6-抽象类"><a href="#7-6-抽象类" class="headerlink" title="7.6 抽象类"></a>7.6 抽象类</h1><h2 id="7-6-1-抽象类概念"><a href="#7-6-1-抽象类概念" class="headerlink" title="7.6.1 抽象类概念"></a>7.6.1 抽象类概念</h2><h3 id="1-抽象类-abstract-class"><a href="#1-抽象类-abstract-class" class="headerlink" title="1.抽象类(abstract class)"></a>1.抽象类(abstract class)</h3><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类就可以声明为抽象类。</p>
<h3 id="2-抽象类和具体类"><a href="#2-抽象类和具体类" class="headerlink" title="2. 抽象类和具体类"></a>2. 抽象类和具体类</h3><p>抽象类与具体类</p>
<ul>
<li>具体类—对现实世界一种实体的抽象定义。</li>
<li>抽象类—对现实世界一种类型的多种实体的统一抽象定义。<br>例如： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pet类应定义为抽象类</span><br><span class="line">Bird类应定义为具体类</span><br><span class="line">抽象类中可声明抽象方法</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	public abstract class Pet &#123;</span><br><span class="line">            public abstract void speak();</span><br><span class="line">            ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-6-2特点"><a href="#7-6-2特点" class="headerlink" title="7.6.2特点"></a>7.6.2特点</h2><p>①用abstract关键字来修饰一个类时，这个类叫做抽象类；<br>②用abstract来修饰一个方法时，该方法叫做抽象方法。<br>抽象方法：只有方法的声明，没有方法的实现。以分号结束：<code>abstract int abstractMethod( int a );</code><br>含有抽象方法的类必须被声明为抽象类。</p>
<ul>
<li>抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。  </li>
<li>若没有重写全部的抽象方法，仍为抽象类。  </li>
<li>不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法。</li>
</ul>
<h2 id="7-6-3抽象类使用"><a href="#7-6-3抽象类使用" class="headerlink" title="7.6.3抽象类使用"></a>7.6.3抽象类使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Pet &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	private int weight;</span><br><span class="line"></span><br><span class="line">	public Pet(String name, int age, int weight) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.age = age;</span><br><span class="line">		this.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public abstract void speak(); // 抽象方法,仅有方法签名没有方法体,因此不能执行</span><br><span class="line"></span><br><span class="line">	public abstract void eat(); </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Bird extends Pet &#123;</span><br><span class="line">	private int flySpeed;</span><br><span class="line"></span><br><span class="line">	public Bird(String name, int age, int weight, int flySpeed) &#123;</span><br><span class="line">		super(name, age, weight);</span><br><span class="line">		this. flySpeed = flySpeed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getFlySpeed() &#123;</span><br><span class="line">		return flySpeed;</span><br><span class="line">	&#125;</span><br><span class="line">	public void speak() &#123;</span><br><span class="line">		System.out.println(&quot;布谷布谷...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;Eating...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestAbstract &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Pet pet = new Bird(&quot;小布&quot;, 1, 100, 20); // 抽象类适用于多态</span><br><span class="line">        pet.speak(); // 虚拟方法调用, 执行子类方法, 父类方法是抽象的, 无法执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-6-4-使用场景"><a href="#7-6-4-使用场景" class="headerlink" title="7.6.4 使用场景"></a>7.6.4 使用场景</h2><p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java允许类设计者指定：</span><br><span class="line">	    超类声明一个方法但不提供实现，</span><br><span class="line">	    该方法的实现由子类提供。</span><br><span class="line">	    这样的方法称为抽象方法。</span><br><span class="line">	    有一个或更多抽象方法的类称为抽象类。</span><br></pre></td></tr></table></figure>
<p>Vehicle是一个抽象类，有两个抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Vehicle&#123;</span><br><span class="line">	public abstract double calcFuelEfficiency();	//计算燃料效率的抽象方法</span><br><span class="line">	public abstract double calcTripDistance();	//计算行驶距离的抽象方法</span><br><span class="line">&#125;</span><br><span class="line">public class Truck extends Vehicle&#123;</span><br><span class="line">	public double calcFuelEfficiency( )   &#123; //写出计算卡车的燃料效率的具体方法   &#125;</span><br><span class="line">	public double calcTripDistance( )    &#123;  //写出计算卡车行驶距离的具体方法   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RiverBarge extends Vehicle&#123;</span><br><span class="line">	 public double calcFuelEfficiency( ) &#123; //写出计算驳船的燃料效率的具体方法  &#125;</span><br><span class="line">	 public double calcTripDistance( )  &#123;  //写出计算驳船行驶距离的具体方法&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：抽象类不能实例化   new Vihicle()是非法的</p>
<h1 id="7-7-接口"><a href="#7-7-接口" class="headerlink" title="7.7 接口"></a>7.7 接口</h1><h2 id="7-7-1-接口的概念"><a href="#7-7-1-接口的概念" class="headerlink" title="7.7.1 接口的概念"></a>7.7.1 接口的概念</h2><h3 id="1-什么是接口"><a href="#1-什么是接口" class="headerlink" title="1. 什么是接口"></a>1. 什么是接口</h3><p>   接口的用途是用来定义现实世界不同类型事物的共同行为特征。<br>    例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">飞行特征（包括起飞，飞行、着陆等行为）是鸟和飞机所共有的。</span><br><span class="line">	鸟和飞机可定义为具体类</span><br><span class="line">	它们的共同行为特征可被定义在接口中</span><br><span class="line">	接口中所有方法均为抽象方法</span><br><span class="line">	示例：</span><br><span class="line">	public interface Flyer &#123;</span><br><span class="line">		  public void takeoff();</span><br><span class="line">		  ……</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-接口的组成"><a href="#2-接口的组成" class="headerlink" title="2. 接口的组成"></a>2. 接口的组成</h3><p>接口可以包含以下成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">①属性</span><br><span class="line">	接口中的所有属性均被视静态常量。</span><br><span class="line">	例如，下面几种方式的声明是等效的：</span><br><span class="line">int num = 10;</span><br><span class="line">public int num = 10;</span><br><span class="line">public static final int num = 10;</span><br><span class="line">②抽象方法</span><br><span class="line">接口中所有方法均为抽象方法。</span><br><span class="line">例如，下面两种方式的声明是等效的：</span><br><span class="line">public abstract void takeoff();</span><br><span class="line"></span><br><span class="line">public interface Flyer &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void takeoff();</span><br><span class="line">    public void land();</span><br><span class="line">public void fly();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-7-2-接口的使用"><a href="#7-7-2-接口的使用" class="headerlink" title="7.7.2 接口的使用"></a>7.7.2 接口的使用</h2><p>1、有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。<br>2、一个类可以实现多个接口，<br>3、接口不能被实例化  </p>
<ul>
<li>具体类（子类）可以实现接口（父类） ，并实现接口中的全部抽象方法</li>
<li>class SubClass implements InterfaceA{ }</li>
</ul>
<p>4、具体类适用父接口的多态<br>5、接口也可以继承其它接口。<br>6、实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。<br>7、接口的主要用途就是被实现类实现。（面向接口编程）<br>8、一个类可以同时继承父类并实现接口</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103212.png" alt></p>
<h2 id="7-7-3-接口的注意事项"><a href="#7-7-3-接口的注意事项" class="headerlink" title="7.7.3 接口的注意事项"></a>7.7.3 接口的注意事项</h2><ul>
<li>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类 </li>
<li>接口也可以继承另一个接口，使用extends关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface&#123;</span><br><span class="line">			String s=“MyInterface”;</span><br><span class="line">			public void absM1();</span><br><span class="line">	&#125;</span><br><span class="line">	interface SubInterface extends MyInterface&#123;</span><br><span class="line">			public void absM2();</span><br><span class="line">	&#125;</span><br><span class="line">	public class SubAdapter implements SubInterface&#123;</span><br><span class="line">			public void absM1()&#123;System.out.println(“absM1”);&#125;</span><br><span class="line">			public void absM2()&#123;System.out.println(“absM2”);&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>实现类SubAdapter必须给出接口SubInterface以及父接口MyInterface中所有方法的实现。</p>
<h2 id="7-7-4-接口小结"><a href="#7-7-4-接口小结" class="headerlink" title="7.7.4 接口小结"></a>7.7.4 接口小结</h2><p>接口的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">①用interface来定义。</span><br><span class="line">②接口中的所有成员变量都默认是由public static final修饰的。</span><br><span class="line">③接口中的所有方法都默认是由public abstract修饰的。</span><br><span class="line">④接口没有构造器。</span><br><span class="line">⑤接口采用多继承机制。</span><br><span class="line">⑥接口定义举例</span><br><span class="line">    public interface Runner &#123;</span><br><span class="line">			int ID = 1;</span><br><span class="line">			void start();</span><br><span class="line">			public void run();</span><br><span class="line">			void stop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-7-5-接口和抽象类的关系"><a href="#7-7-5-接口和抽象类的关系" class="headerlink" title="7.7.5 接口和抽象类的关系"></a>7.7.5 接口和抽象类的关系</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103339.png" alt></p>
<h2 id="7-7-6-接口在java8中的变化"><a href="#7-7-6-接口在java8中的变化" class="headerlink" title="7.7.6 接口在java8中的变化"></a>7.7.6 接口在java8中的变化</h2><p>Java 8中，你可以为接口添加默认方法和静态方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p>
<ul>
<li>默认方法：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。<br>比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</li>
<li>静态方法：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface AA &#123;</span><br><span class="line"></span><br><span class="line">    double PI = 3.14;</span><br><span class="line"></span><br><span class="line">	public default void method() &#123;</span><br><span class="line">		System.out.println(&quot;北京&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	default String method1() &#123;</span><br><span class="line">		return &quot;上海&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void method2() &#123;</span><br><span class="line">		System.out.println(“hello lambda!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时<br>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。  </p>
<p>②接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103531.png" alt></p>
<h1 id="7-8-内部类"><a href="#7-8-内部类" class="headerlink" title="7.8 内部类"></a>7.8 内部类</h1><h2 id="7-8-1-什么是内部类"><a href="#7-8-1-什么是内部类" class="headerlink" title="7.8.1 什么是内部类"></a>7.8.1 什么是内部类</h2><ol>
<li>概念</li>
</ol>
<ul>
<li>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</li>
<li>Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</li>
<li>Inner class的名字不能与包含它的类名相同；</li>
<li>Inner class可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要:内部类.成员或者内部类对象.成员。<br>分类：成员内部类（static成员内部类嵌套类和成员内部类）<pre><code>局部内部类（不谈修饰符）、匿名内部类
</code></pre></li>
</ul>
<h2 id="7-8-2-成员内部类"><a href="#7-8-2-成员内部类" class="headerlink" title="7.8.2 成员内部类"></a>7.8.2 成员内部类</h2><h3 id="1-普通内部类"><a href="#1-普通内部类" class="headerlink" title="1. 普通内部类"></a>1. 普通内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">	private int s;</span><br><span class="line"></span><br><span class="line">	public class B &#123;</span><br><span class="line"></span><br><span class="line">		public void mb() &#123;</span><br><span class="line">			s = 100; // 在普通内部类的方法中, 可以直接外部类的私有成员.</span><br><span class="line">			System.out.println(&quot;在内部类B中s=&quot; + s);</span><br><span class="line">		&#125;  </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void ma() &#123;</span><br><span class="line">		B i = new B();</span><br><span class="line">		i.mb();</span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;	</span><br><span class="line"></span><br><span class="line">	public static void main(String args[])&#123;</span><br><span class="line">		A o = new A();</span><br><span class="line">		o.ma(); // 调用外部类的方法, 间接创建了内部类对象并调用了内部类对象的方法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    </span><br><span class="line">	private int s = 111;</span><br><span class="line">        </span><br><span class="line">	public class B &#123;</span><br><span class="line">	</span><br><span class="line">		private int s = 222;</span><br><span class="line">		</span><br><span class="line">		public void mb(int s) &#123;</span><br><span class="line">	        System.out.println(s);        // 访问最近的形参值:333</span><br><span class="line">	        System.out.println(this.s);     // 访问本类当前对象的属性:222</span><br><span class="line">	        System.out.println(A.this.s);   // 访问外部类的当前对象的属性:111</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;    </span><br><span class="line">	</span><br><span class="line">	public static void main(String args[])&#123;</span><br><span class="line">		A a = new A();</span><br><span class="line">		A.B b = a.new B(); // 在测试类中创建普通内部类的对象需要使用外部类对象</span><br><span class="line">		b.mb(333); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-嵌套类"><a href="#2-嵌套类" class="headerlink" title="2. 嵌套类"></a>2. 嵌套类</h3><p>被static修饰的成员内部类就称为嵌套类.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">	private int s;</span><br><span class="line"></span><br><span class="line">	public static class B &#123;</span><br><span class="line"></span><br><span class="line">		public void mb() &#123;</span><br><span class="line">			//s = 100; // 在嵌套类的方法中, 不可以直接外部类的非静态成员.</span><br><span class="line">			//System.out.println(&quot;在内部类B中s=&quot; + s);</span><br><span class="line">		&#125;  </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void ma() &#123;</span><br><span class="line">		B i = new B();</span><br><span class="line">		i.mb();</span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;	</span><br><span class="line"></span><br><span class="line">	public static void main(String args[])&#123;</span><br><span class="line">		A.B b = new A.B(); // 创建嵌套类对象, 不需要外部类的对象</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-8-3-局部内部类"><a href="#7-8-3-局部内部类" class="headerlink" title="7.8.3 局部内部类"></a>7.8.3 局部内部类</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>在方法体中声明的内部类就是局部内部类, 局部内部类的范围和局部变量类似.</p>
<h3 id="2-普通局部内部类"><a href="#2-普通局部内部类" class="headerlink" title="2. 普通局部内部类"></a>2. 普通局部内部类</h3><p>在方法中声明的内部类, 有类名, 使用和普通类类似.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;    </span><br><span class="line">	</span><br><span class="line">	public static void main(String args[])&#123;</span><br><span class="line">		class A &#123;</span><br><span class="line">			public void test();</span><br><span class="line">		&#125;; </span><br><span class="line">		A a = new A();</span><br><span class="line">		a.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3. 匿名内部类"></a>3. 匿名内部类</h3><p>在方法中声明的内部类,   但是没有class关键字和具体类名, 称为匿名内部类, 因为没有类名, 所以必须在声明内部类的同时创建对象, 否则无法创建对象了.<br>所以匿名内部类的语法是 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 引用 = new 父类(实参列表) &#123;类体&#125;;</span><br></pre></td></tr></table></figure>
<p>匿名内部类最常用用法是new 后面的类名是已经存在的类, 或抽象类, 或接口. 如果是抽象类或接口, 则匿名内部类类体中必须实现全部的抽象方法, 由此可见, 匿名内部类只能作为new后面的类或抽象或接口的子类存在, 但是没有类名, 所以通常在声明的时候就创建对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    public void a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;    </span><br><span class="line">	</span><br><span class="line">	public static void main(String args[])&#123;</span><br><span class="line">		new A() &#123;</span><br><span class="line">            @Override</span><br><span class="line">			public void a() &#123;</span><br><span class="line">                System.out.println(“匿名内部类实现接口方法”);</span><br><span class="line">&#125;</span><br><span class="line">		&#125;.a(); // 打印输出内容…</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpeg" alt>
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpeg" alt>
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2016/10/15/6. JavaSE-面向对象基本特征/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2016/11/12/8. JavaSE-枚举与注解/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment"></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "b8cfVAxSX9whYsIOMmxwCicp-gzGzoHsz",
            appKey: "klYDKAeEh6GPa0wnf22lQd96",
            avatar:'identicon',
            placeholder: "ヾﾉ≧∀≦)o 来呀！快活呀！~",
            guest_info:guest_info,
            pageSize:'20'
        });
    </script>
  
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>

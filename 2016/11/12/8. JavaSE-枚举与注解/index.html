<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>8. JavaSE-枚举与注解 | SomnambulistOfChina</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java SE,">
  

  <meta name="description" content="8.1 枚举8.1.1 什么是枚举类的对象只有有限个的、确定的例如：12345678星期：Monday(星期一)......Sunday(星期天)性别：Man(男)、Woman(女)月份：January(1月)......December(12月)季节：Spring(春节)......Winter(冬天)七彩标准色：Red(红)......Purple(紫)支付方式：Cash（现金）、WeChat">
<meta name="keywords" content="Java SE">
<meta property="og:type" content="article">
<meta property="og:title" content="8. JavaSE-枚举与注解">
<meta property="og:url" content="http://yoursite.com/2016/11/12/8. JavaSE-枚举与注解/index.html">
<meta property="og:site_name" content="SomnambulistOfChina">
<meta property="og:description" content="8.1 枚举8.1.1 什么是枚举类的对象只有有限个的、确定的例如：12345678星期：Monday(星期一)......Sunday(星期天)性别：Man(男)、Woman(女)月份：January(1月)......December(12月)季节：Spring(春节)......Winter(冬天)七彩标准色：Red(红)......Purple(紫)支付方式：Cash（现金）、WeChat">
<meta property="og:locale" content="Java EE">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530132629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530133407.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134033.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134149.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000638.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000832.png">
<meta property="og:updated_time" content="2019-06-04T01:25:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="8. JavaSE-枚举与注解">
<meta name="twitter:description" content="8.1 枚举8.1.1 什么是枚举类的对象只有有限个的、确定的例如：12345678星期：Monday(星期一)......Sunday(星期天)性别：Man(男)、Woman(女)月份：January(1月)......December(12月)季节：Spring(春节)......Winter(冬天)七彩标准色：Red(红)......Purple(紫)支付方式：Cash（现金）、WeChat">
<meta name="twitter:image" content="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530132629.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
  <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/e070d647.js","daovoice")</script>
</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">更多</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">更多</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#8-1-枚举"><span class="toc-text">8.1 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-1-什么是枚举"><span class="toc-text">8.1.1 什么是枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-2-如何定义枚举类型"><span class="toc-text">8.1.2 如何定义枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-3-java-lang-Enum类的方法"><span class="toc-text">8.1.3 java.lang.Enum类的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-4-枚举的特别说明"><span class="toc-text">8.1.4 枚举的特别说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、枚举中定义属性"><span class="toc-text">1、枚举中定义属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、枚举类可以自定义方法"><span class="toc-text">2、枚举类可以自定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、枚举类可以实现一个或者多个接口（了解）"><span class="toc-text">3、枚举类可以实现一个或者多个接口（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、枚举类可以自己定义抽象方法（了解）"><span class="toc-text">4、枚举类可以自己定义抽象方法（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-5-关于枚举的拓展"><span class="toc-text">8.1.5 关于枚举的拓展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-2-注解Annotation"><span class="toc-text">8.2 注解Annotation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-1-注解的概述"><span class="toc-text">8.2.1 注解的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Annotation的作用"><span class="toc-text">1、Annotation的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、Annotation的格式"><span class="toc-text">2、Annotation的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、Annotation在哪里使用"><span class="toc-text">3、Annotation在哪里使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-2-常见的注解示例"><span class="toc-text">8.2.2 常见的注解示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、生成文档"><span class="toc-text">1、生成文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、在编译时进行格式检查"><span class="toc-text">2、在编译时进行格式检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、跟踪代码依赖性，实现替代配置文件功能"><span class="toc-text">3、跟踪代码依赖性，实现替代配置文件功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、JUnit框架中的注解"><span class="toc-text">4、JUnit框架中的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-如何使用JUnit"><span class="toc-text">1 如何使用JUnit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JUnit的常用注解"><span class="toc-text">2 JUnit的常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-如何运行Junit测试方法"><span class="toc-text">3 如何运行Junit测试方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-3-自定义注解与反射读取注解"><span class="toc-text">8.2.3 自定义注解与反射读取注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-4-元注解"><span class="toc-text">8.2.4 元注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-5-JDK1-8注解的新特性"><span class="toc-text">8.2.5 JDK1.8注解的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、可重复注解"><span class="toc-text">1、可重复注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、类型注解"><span class="toc-text">2、类型注解</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-8. JavaSE-枚举与注解" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">8. JavaSE-枚举与注解</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.11.12</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>SomnambulistOfChina</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaSE基础笔记/">JavaSE基础笔记</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="8-1-枚举"><a href="#8-1-枚举" class="headerlink" title="8.1 枚举"></a>8.1 枚举</h1><h2 id="8-1-1-什么是枚举"><a href="#8-1-1-什么是枚举" class="headerlink" title="8.1.1 什么是枚举"></a>8.1.1 什么是枚举</h2><p>类的对象只有有限个的、确定的<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">星期：Monday(星期一)......Sunday(星期天)</span><br><span class="line">性别：Man(男)、Woman(女)</span><br><span class="line">月份：January(1月)......December(12月)</span><br><span class="line">季节：Spring(春节)......Winter(冬天)</span><br><span class="line">七彩标准色：Red(红)......Purple(紫)</span><br><span class="line">支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</span><br><span class="line">就职状态：Busy、Free、Vocation、Dimission</span><br><span class="line">订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</span><br></pre></td></tr></table></figure></p>
<h2 id="8-1-2-如何定义枚举类型"><a href="#8-1-2-如何定义枚举类型" class="headerlink" title="8.1.2 如何定义枚举类型"></a>8.1.2 如何定义枚举类型</h2><p>要点：</p>
<ul>
<li>私有化类的构造器，保证不能在类的外部创建其对象 </li>
<li>在类的内部创建枚举类的实例。声明为：public static final </li>
</ul>
<p>JDK1.5之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TestEnumType &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Season s = Season.SPRING;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Season&#123;</span><br><span class="line">	public static final Season SPRING = new Season();</span><br><span class="line">	public static final Season SUMMER = new Season();</span><br><span class="line">	public static final Season AUTUMN = new Season();</span><br><span class="line">	public static final Season WINTER = new Season();</span><br><span class="line">	</span><br><span class="line">	private Season()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		if(this == SPRING)&#123;</span><br><span class="line">			return &quot;SPRING&quot;;</span><br><span class="line">		&#125;else if(this == SUMMER)&#123;</span><br><span class="line">			return &quot;SUMMER&quot;;</span><br><span class="line">		&#125;else if(this == AUTUMN)&#123;</span><br><span class="line">			return &quot;AUTUMN&quot;;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return &quot;WINTER&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.5之后：</p>
<ul>
<li>使用 enum 定义的枚举类默认继承了 java.lang.Enum类。因此不能再继承其他类。</li>
<li>枚举类的所有构造器只能使用 private 访问控制符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(, 分隔    ; 结尾)，必须在枚举类的第一行声明枚举类对象。列出的实例系统会自动添加 public static final 修饰</li>
<li>JDK 1.5 之后可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.enumtype.after15;</span><br><span class="line"></span><br><span class="line">public class TestEnumType &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Season s = Season.SPRING;</span><br><span class="line">		switch(s)&#123;</span><br><span class="line">		case SPRING:</span><br><span class="line">			System.out.println(&quot;春暖花开&quot;);break;</span><br><span class="line">		case SUMMER:</span><br><span class="line">			System.out.println(&quot;夏日炎炎&quot;);break;</span><br><span class="line">		case AUTUMN:</span><br><span class="line">			System.out.println(&quot;秋高气爽&quot;);break;</span><br><span class="line">		case WINTER:</span><br><span class="line">			System.out.println(&quot;白雪皑皑&quot;);break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">enum Season&#123;</span><br><span class="line">	SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-1-3-java-lang-Enum类的方法"><a href="#8-1-3-java-lang-Enum类的方法" class="headerlink" title="8.1.3 java.lang.Enum类的方法"></a>8.1.3 java.lang.Enum类的方法</h2><p>除了toString方法，都是final修饰的方法，因此都不能重写</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530132629.png" alt></p>
<p>还有两个API文档中没有，但枚举类类拥有并且常用的方法</p>
<ul>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常。</li>
</ul>
<h2 id="8-1-4-枚举的特别说明"><a href="#8-1-4-枚举的特别说明" class="headerlink" title="8.1.4 枚举的特别说明"></a>8.1.4 枚举的特别说明</h2><h3 id="1、枚举中定义属性"><a href="#1、枚举中定义属性" class="headerlink" title="1、枚举中定义属性"></a>1、枚举中定义属性</h3><ul>
<li>枚举类对象的属性不应允许被改动, 所以应该使用 private final修饰。不是语法要求，而是语义要求。</li>
<li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值。</li>
<li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.enumtype.before15;</span><br><span class="line"></span><br><span class="line">public class TestWeekField &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Week w = Week.MONDAY;</span><br><span class="line">		System.out.println(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">enum Week&#123;</span><br><span class="line">	MONDAY(&quot;星期一&quot;),</span><br><span class="line">	TUESDAY(&quot;星期二&quot;),</span><br><span class="line">	WEDNESDAY(&quot;星期三&quot;),</span><br><span class="line">	THURSDAY(&quot;星期四&quot;),</span><br><span class="line">	FRIDAY(&quot;星期五&quot;),</span><br><span class="line">	SATURDAY(&quot;星期六&quot;),</span><br><span class="line">	SUNDAY(&quot;星期日&quot;);</span><br><span class="line">	private final String DESCRPTION;</span><br><span class="line"></span><br><span class="line">	private Week(String dESCRPTION) &#123;</span><br><span class="line">		DESCRPTION = dESCRPTION;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return DESCRPTION;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、枚举类可以自定义方法"><a href="#2、枚举类可以自定义方法" class="headerlink" title="2、枚举类可以自定义方法"></a>2、枚举类可以自定义方法</h3><p>静态和非静态</p>
<h3 id="3、枚举类可以实现一个或者多个接口（了解）"><a href="#3、枚举类可以实现一个或者多个接口（了解）" class="headerlink" title="3、枚举类可以实现一个或者多个接口（了解）"></a>3、枚举类可以实现一个或者多个接口（了解）</h3><ul>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Change&#123;</span><br><span class="line">	void degenerate();</span><br><span class="line">&#125;</span><br><span class="line">interface Checkable&#123;</span><br><span class="line">	void check();</span><br><span class="line">&#125;</span><br><span class="line">enum Gender implements Change,Checkable&#123;</span><br><span class="line">	MAN&#123;</span><br><span class="line">		public void degenerate()&#123;</span><br><span class="line">			System.out.println(&quot;咔嚓一刀&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,WOMAN&#123;</span><br><span class="line">		public void degenerate()&#123;</span><br><span class="line">			System.out.println(&quot;比较复杂&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	public void check()&#123;</span><br><span class="line">		System.out.println(&quot;脱光&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、枚举类可以自己定义抽象方法（了解）"><a href="#4、枚举类可以自己定义抽象方法（了解）" class="headerlink" title="4、枚举类可以自己定义抽象方法（了解）"></a>4、枚举类可以自己定义抽象方法（了解）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">enum Payment&#123;</span><br><span class="line">	CASH&#123;</span><br><span class="line">		public void pay()&#123;</span><br><span class="line">			System.out.println(&quot;现金支付&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	WECHAT&#123;</span><br><span class="line">		public void pay()&#123;</span><br><span class="line">			System.out.println(&quot;微信支付&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	ALIPAY&#123;</span><br><span class="line">		public void pay()&#123;</span><br><span class="line">			System.out.println(&quot;支付鸨支付&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	CARD&#123;</span><br><span class="line">		public void pay()&#123;</span><br><span class="line">			System.out.println(&quot;银行卡支付&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	CREDIT&#123;</span><br><span class="line">		public void pay()&#123;</span><br><span class="line">			System.out.println(&quot;信用卡支付&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	public abstract void pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-1-5-关于枚举的拓展"><a href="#8-1-5-关于枚举的拓展" class="headerlink" title="8.1.5 关于枚举的拓展"></a>8.1.5 关于枚举的拓展</h2><p>java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的key是enum类型，而value则可以是任意类型。关于这个两个集合的使用就不在这里赘述，可以参考JDK文档。</p>
<h1 id="8-2-注解Annotation"><a href="#8-2-注解Annotation" class="headerlink" title="8.2 注解Annotation"></a>8.2 注解Annotation</h1><p>注解Annotation是从JDK5.0开始引入的新特性。</p>
<h2 id="8-2-1-注解的概述"><a href="#8-2-1-注解的概述" class="headerlink" title="8.2.1 注解的概述"></a>8.2.1 注解的概述</h2><h3 id="1、Annotation的作用"><a href="#1、Annotation的作用" class="headerlink" title="1、Annotation的作用"></a>1、Annotation的作用</h3><ul>
<li>注解不是程序本身，可以对程序作出解释。（这一点，跟注释没什么区别）</li>
<li>可以被其他程序（比如：编译器，Checker Framework等）读取。（注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义）<h3 id="2、Annotation的格式"><a href="#2、Annotation的格式" class="headerlink" title="2、Annotation的格式"></a>2、Annotation的格式</h3>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(value=”unchecked”)</span><br></pre></td></tr></table></figure>
<h3 id="3、Annotation在哪里使用"><a href="#3、Annotation在哪里使用" class="headerlink" title="3、Annotation在哪里使用"></a>3、Annotation在哪里使用</h3><p>Annotation 可以像修饰符一样被使用, 可用于修饰包，类, 构造器, 方法, 成员变量, 参数, 局部变量。相当于给它们添加了额外的辅助信息，而且有些注解我们可以通过反射机制编程实现对这些元数据的访问。</p>
<h2 id="8-2-2-常见的注解示例"><a href="#8-2-2-常见的注解示例" class="headerlink" title="8.2.2 常见的注解示例"></a>8.2.2 常见的注解示例</h2><h3 id="1、生成文档"><a href="#1、生成文档" class="headerlink" title="1、生成文档"></a>1、生成文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@author 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line">@version 标明该类模块的版本</span><br><span class="line">@see 参考转向，也就是相关主题</span><br><span class="line">@since 从哪个版本开始增加的</span><br><span class="line">@param 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line">@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</span><br><span class="line">@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</span><br><span class="line">其中 @param  @return 和 @exception 这三个标记都是只用于方法的。</span><br><span class="line">@param的格式要求：@param 形参名 形参类型  形参说明</span><br><span class="line">@return 的格式要求：@return 返回值类型 返回值说明</span><br><span class="line">@exception的格式要求：@exception 异常类型 异常说明</span><br><span class="line">@param和@exception可以并列多个</span><br><span class="line">javadoc.exe就是这些注解的信息处理流程</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.javadoc;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @author Irene</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @see Math.java</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestJavadoc &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 程序的主方法，程序的入口</span><br><span class="line">	 * @param args String[] 命令行参数</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 求圆面积的方法</span><br><span class="line">	 * @param radius double 半径值</span><br><span class="line">	 * @return double 圆的面积</span><br><span class="line">	 */</span><br><span class="line">	public static double getArea(double radius)&#123;</span><br><span class="line">		return Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530133407.png" alt></p>
<h3 id="2、在编译时进行格式检查"><a href="#2、在编译时进行格式检查" class="headerlink" title="2、在编译时进行格式检查"></a>2、在编译时进行格式检查</h3><p> JDK中系统内置了常用的三个注解：<br> （1）@Override：按照重写的要求检查方法的格式<br> （2）@Deprecated：过时，表示不鼓励程序员使用这样的元素，因为存在危险或有更好的实现<br> （3）@SuppressWarnings：抑制警告 </p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000425.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.javadoc;</span><br><span class="line"></span><br><span class="line">public class TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">		int a = 10;</span><br><span class="line">	&#125;</span><br><span class="line">	@Deprecated</span><br><span class="line">	public void print()&#123;</span><br><span class="line">		System.out.println(&quot;过时的方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;重写的toString方法()&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、跟踪代码依赖性，实现替代配置文件功能"><a href="#3、跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="3、跟踪代码依赖性，实现替代配置文件功能"></a>3、跟踪代码依赖性，实现替代配置文件功能</h3><p>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.servlet;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/login&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>spring框架中关于“事务”的管理<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation=Propagation.REQUIRES_NEW,</span><br><span class="line">				isolation=Isolation.READ_COMMITTED,</span><br><span class="line">				readOnly=false,</span><br><span class="line">                timeout=3)</span><br><span class="line">	public void buyBook(String username, String isbn) &#123;</span><br><span class="line">		//1.查询书的单价</span><br><span class="line">		int price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">		//2. 更新库存</span><br><span class="line">		bookShopDao.updateBookStock(isbn);	</span><br><span class="line">		//3. 更新用户的余额</span><br><span class="line">		bookShopDao.updateUserAccount(username, price);</span><br><span class="line">	&#125;</span><br><span class="line">     &lt;!-- 配置事务属性 --&gt;</span><br><span class="line">	 &lt;tx:advice transaction-manager=&quot;dataSourceTransactionManager&quot; id=&quot;txAdvice&quot;&gt;</span><br><span class="line">	 	 &lt;tx:attributes&gt;</span><br><span class="line">	 	 		&lt;!-- 配置每个方法使用的事务属性 --&gt;</span><br><span class="line">	 	 		&lt;tx:method name=&quot;buyBook&quot; propagation=&quot;REQUIRES_NEW&quot; </span><br><span class="line">	 	 				   isolation=&quot;READ_COMMITTED&quot;  read-only=&quot;false&quot; </span><br><span class="line">	 	 				   timeout=&quot;3&quot; /&gt;</span><br><span class="line">	 	 &lt;/tx:attributes&gt;</span><br><span class="line">	 &lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、JUnit框架中的注解"><a href="#4、JUnit框架中的注解" class="headerlink" title="4、JUnit框架中的注解"></a>4、JUnit框架中的注解</h3><ul>
<li>JUnit是由 Erich Gamma 和 Kent Beck 编写的一个回归测试框架（regression testing framework）,供Java开发人员编写单元测试之用。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。</li>
<li>Junit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。<h4 id="1-如何使用JUnit"><a href="#1-如何使用JUnit" class="headerlink" title="1 如何使用JUnit"></a>1 如何使用JUnit</h4>要使用JUnit，必须在项目的编译路径中必须引入JUnit的库，即相关的.class文件组成的jar包。<br>如何把JUnit的jar添加到编译路径如图所示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134033.png" alt></p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134123.png" alt></p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134149.png" alt></p>
<h4 id="2-JUnit的常用注解"><a href="#2-JUnit的常用注解" class="headerlink" title="2 JUnit的常用注解"></a>2 JUnit的常用注解</h4><ul>
<li>使用JUnit测试的类必须是public的。</li>
<li>JUnit4常见的注解和要求：这些方法都必须是public，无参，无返回值。</li>
<li>@Test：标记在非静态的测试方法上。只有标记@Test的方法才能被作为一个测试方法单独测试。一个类中可以有多个@Test标记的方法。运行时如果只想运行其中一个@Test标记的方法，那么选择这个方法名，然后单独运行，否则整个类的所有标记了@Test的方法都会被执行。-</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test(timeout=1000)：设置超时时间，如果测试时间超过了你定义的timeout，测试失败</span><br><span class="line">@Test(expected)： 申明出会发生的异常，比如 @Test（expected = Exception.class）</span><br><span class="line">了解：</span><br><span class="line">@BeforeClass：标记在静态方法上。因为这个方法只执行一次。在类初始化时执行。</span><br><span class="line">@AfterClass：标记在静态方法上。因为这个方法只执行一次。在所有方法完成后执行。</span><br><span class="line">@Before：标记在非静态方法上。在@Test方法前面执行，而且是在每一个@Test方法前面都执行</span><br><span class="line">@After：标记在非静态方法上。在@Test方法后面执行，而且是在每一个@Test方法后面都执行</span><br><span class="line">@Ignore：标记在本次不参与测试的方法上。这个注解的含义就是“某些方法尚未完成，暂不参与此次测试”。</span><br><span class="line">@BeforeClass、@AfterClass、@Before、@After、@Ignore都是配合@Test它使用的，单独使用没有意义。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.AfterClass;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.BeforeClass;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestJUnit2 &#123;</span><br><span class="line">	private static Object[] array;</span><br><span class="line">	private static int total;</span><br><span class="line">	</span><br><span class="line">	@BeforeClass</span><br><span class="line">	public static void init()&#123;</span><br><span class="line">		System.out.println(&quot;初始化数组&quot;);</span><br><span class="line">		array = new Object[5];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Before</span><br><span class="line">	public void before()&#123;</span><br><span class="line">		System.out.println(&quot;调用之前total=&quot; + total);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void add()&#123;</span><br><span class="line">		//往数组中存储一个元素</span><br><span class="line">		System.out.println(&quot;add&quot;);</span><br><span class="line">		array[total++] = &quot;hello&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@After</span><br><span class="line">	public void after()&#123;</span><br><span class="line">		System.out.println(&quot;调用之前total=&quot; + total);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@AfterClass</span><br><span class="line">	public static void destroy()&#123;</span><br><span class="line">		array = null;</span><br><span class="line">		System.out.println(&quot;销毁数组&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-如何运行Junit测试方法"><a href="#3-如何运行Junit测试方法" class="headerlink" title="3 如何运行Junit测试方法"></a>3 如何运行Junit测试方法</h4><p>一个类中可以有多个@Test标记的方法，运行时如果只想运行其中一个@Test标记的方法，那么选择这个方法名，然后单独运行，否则整个类的所有标记了@Test的方法都会被执行。</p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134423.png" alt></p>
<h2 id="8-2-3-自定义注解与反射读取注解"><a href="#8-2-3-自定义注解与反射读取注解" class="headerlink" title="8.2.3 自定义注解与反射读取注解"></a>8.2.3 自定义注解与反射读取注解</h2><ul>
<li>定义新的 Annotation 类型使用 @interface 关键字</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明. 其方法名和返回值定义了该成员的名字和类型. 我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</li>
<li>如果只有一个参数成员，建议使用参数名为value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”</li>
<li>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation</li>
<li>注意：自定义注解必须配上注解的信息处理流程才有意义。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.javadoc;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@MyAnnotation(value=&quot;尚硅谷&quot;)</span><br><span class="line">public class TestMyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Class clazz = TestMyAnnotation.class;</span><br><span class="line">		Annotation a = clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">		MyAnnotation m = (MyAnnotation) a;</span><br><span class="line">		String info = m.value();</span><br><span class="line">		System.out.println(info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">	String value() default &quot;auguigu&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-4-元注解"><a href="#8-2-4-元注解" class="headerlink" title="8.2.4 元注解"></a>8.2.4 元注解</h2><blockquote>
<p>Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）@Target</span><br><span class="line">（2）@Retention</span><br><span class="line">（3）@Documented</span><br><span class="line">（4）@Inherited</span><br></pre></td></tr></table></figure>
<p>在java.lang.annotation包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、@Target</span><br><span class="line">作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134908.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2、@Retention</span><br><span class="line">@Retention定义了该Annotation被保留的时间长短</span><br><span class="line">作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</span><br><span class="line">@Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:</span><br><span class="line">取值（RetentionPoicy）有：</span><br><span class="line">SOURCE:在源文件中有效（即源文件保留）</span><br><span class="line">CLASS:在class文件中有效（即class保留） 这是默认值</span><br><span class="line">RUNTIME:在运行时有效（即运行时保留）当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000638.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3、@Documented</span><br><span class="line">Documented 注解表明这个注解应该被 javadoc工具记录。默认情况下,javadoc是不包括注解的，但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理。</span><br><span class="line">4、@Inherited</span><br><span class="line">允许子类继承父类中的注解</span><br></pre></td></tr></table></figure></p>
<h2 id="8-2-5-JDK1-8注解的新特性"><a href="#8-2-5-JDK1-8注解的新特性" class="headerlink" title="8.2.5 JDK1.8注解的新特性"></a>8.2.5 JDK1.8注解的新特性</h2><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。  </p>
<h3 id="1、可重复注解"><a href="#1、可重复注解" class="headerlink" title="1、可重复注解"></a>1、可重复注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestOldAnnotation &#123;</span><br><span class="line"></span><br><span class="line">	@RoleAnnotations(&#123;@RoleAnnotation(role=&quot;admin&quot;),@RoleAnnotation(role=&quot;manager&quot;),@RoleAnnotation(role=&quot;saler&quot;)&#125;)</span><br><span class="line">	public void add()&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@interface RoleAnnotation&#123;</span><br><span class="line">	String role() default &quot;admin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//表示target是所有</span><br><span class="line">@interface RoleAnnotations&#123;</span><br><span class="line">	RoleAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8之后，可读性更好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Repeatable;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">public class TestNewAnnotation &#123;</span><br><span class="line">	</span><br><span class="line">	@LimitAnnotation(role=&quot;admin&quot;)</span><br><span class="line">	@LimitAnnotation(role=&quot;manager&quot;)</span><br><span class="line">	@LimitAnnotation(role=&quot;saler&quot;)</span><br><span class="line">	public void test()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)      此处的target必须与LimitAnnotation一致</span><br><span class="line">@interface LimitAnnotations&#123;</span><br><span class="line">	LimitAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(LimitAnnotations.class)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@interface LimitAnnotation&#123;</span><br><span class="line">	String role() default &quot;admin&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、类型注解"><a href="#2、类型注解" class="headerlink" title="2、类型注解"></a>2、类型注解</h3><p>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    /** Class, interface (including annotation type), or enum declaration */</span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    /** Field declaration (includes enum constants) */</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    /** Method declaration */</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    /** Formal parameter declaration */</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    /** Constructor declaration */</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    /** Local variable declaration */</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    /** Annotation type declaration */</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    /** Package declaration */</span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在java 8之前，注解只能是在声明的地方所使用，java8开始，注解可以应用在任何地方。</li>
<li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（eg：泛型声明）。</li>
<li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package.com.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">public class TestTypeDefine&lt;@TypeDefine() U&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	private U u;</span><br><span class="line">	</span><br><span class="line">	public &lt;@TypeDefine() T&gt; void test(T t)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@interface TypeDefine&#123;</span><br><span class="line">&#125;</span><br><span class="line">package com.atguigu.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@MyAnnotation</span><br><span class="line">public class TestAnnotation&lt;U&gt;&#123;</span><br><span class="line">	@MyAnnotation</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TestAnnotation &lt;@MyAnnotation String&gt; t = null;</span><br><span class="line">		int a = (@MyAnnotation int)2L;</span><br><span class="line">		@MyAnnotation int b = 10;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static &lt;@MyAnnotation T&gt; void method(T t)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void test(@MyAnnotation String arg)throws @MyAnnotation Exception&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE_USE)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型注解被用来支持在Java的程序中做强类型检查。配合第三方插件工具Checker Framework（使用Checker Framework可以找到类型注解出现的地方并检查），可以在编译的时候检测出<code>runtime error（eg：UnsupportedOperationException； NumberFormatException；NullPointerException异常等都是runtime error）</code>，以提高代码质量。这就是类型注解的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package checker;</span><br><span class="line"></span><br><span class="line">import org.checkerframework.checker.nullness.qual.NonNull;</span><br><span class="line"></span><br><span class="line">public class TestChecker &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Object obj = null;</span><br><span class="line">		printNonNullToString(obj);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void printNonNullToString(@NonNull Object object) &#123;</span><br><span class="line">		System.out.println(object.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000751.png" alt></p>
<p>进入源代码目录   通过javac编译  -processor 后面接注释处理流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac  -processor org.checkerframework.checker.nullness.NullnessChecker TestChecker.java</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000832.png" alt></p>
<p>警告处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -Xbootclasspath/p:D:\software\eclipse\checker-framework-2.1.13\checker\dist\jdk8.jar -processor org.checkerframework.checker.nullness.NullnessChecker TestChecker.java</span><br></pre></td></tr></table></figure>
<p>要配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath=.;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar;D:\software\eclipse\checker-framework-2.1.13\checker\dist\checker.jar;D:\software\eclipse\checker-framework-2.1.13\checker\dist\checker-qual.jar;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>java 5,6,7版本是不支持注解@NonNull，但checker framework 有个向下兼容的解决方案，就是将类型注解@NonNull 用/**/注释起来。 </li>
</ul>
<p>这样javac编译器就会忽略掉注释块，但用checker framework里面的javac编译器同样能够检测出@NonNull错误。</p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpeg" alt>
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpeg" alt>
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2016/10/28/7. JavaSE-面向对象高级特性/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2016/12/24/9. JavaSE-Java异常处理/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment"></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "b8cfVAxSX9whYsIOMmxwCicp-gzGzoHsz",
            appKey: "klYDKAeEh6GPa0wnf22lQd96",
            avatar:'identicon',
            placeholder: "ヾﾉ≧∀≦)o 来呀！快活呀！~",
            guest_info:guest_info,
            pageSize:'10'
        });
    </script>
  
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>

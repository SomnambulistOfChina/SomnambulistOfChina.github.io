<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SomnambulistOfChina</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-06T09:47:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SomnambulistOfChina</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3. SQL-JDBC</title>
    <link href="http://yoursite.com/2017/09/25/19.%20SQL-JDBC/"/>
    <id>http://yoursite.com/2017/09/25/19. SQL-JDBC/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2019-06-06T09:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li>JDBC直接访问数据库</li><li>JDO技术（Java Data Object）</li><li>第三方O/R工具，如Hibernate, Mybatis 等</li></ul><p>JDBC是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p><h2 id="1、什么是JDBC"><a href="#1、什么是JDBC" class="headerlink" title="1、什么是JDBC"></a>1、什么是JDBC</h2><ul><li>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</li><li>JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115232.png" alt></p><p>现在：</p><p><img src="http://note.youdao.com/yws/res/8061/23E2E85D304744C494F1D83F1FE4483B" alt="image"></p><p>结论：  </p><ul><li>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。</li><li>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</li></ul><h2 id="2、JDBC-API"><a href="#2、JDBC-API" class="headerlink" title="2、JDBC API"></a>2、JDBC API</h2><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115353.png" alt></p><h2 id="3、JDBC程序编写步骤"><a href="#3、JDBC程序编写步骤" class="headerlink" title="3、JDBC程序编写步骤"></a>3、JDBC程序编写步骤</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115428.png" alt></p><h1 id="二、获取数据库连接"><a href="#二、获取数据库连接" class="headerlink" title="二、获取数据库连接"></a>二、获取数据库连接</h1><h3 id="（一）引入JDBC驱动程序"><a href="#（一）引入JDBC驱动程序" class="headerlink" title="（一）引入JDBC驱动程序"></a>（一）引入JDBC驱动程序</h3><p>驱动程序由数据库提供商提供下载。 MySQL的驱动下载地址：<a href="http://dev.mysql.com/downloads/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/</a><br>如何在Java Project项目应用中添加数据库驱动jar：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115616.png" alt></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115718.png" alt></p><h2 id="（二）加载并注册驱动"><a href="#（二）加载并注册驱动" class="headerlink" title="（二）加载并注册驱动"></a>（二）加载并注册驱动</h2><p>加载并注册驱动：</p><ul><li>加载驱动，把驱动类加载到内存</li><li>注册驱动，把驱动类的对象交给DriverManager管理，用于后面创建连接等使用。</li></ul><h3 id="1、Class-forName"><a href="#1、Class-forName" class="headerlink" title="1、Class.forName()"></a>1、Class.forName()</h3><p>因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例，所以可以换一种方式来加载驱动。（即只要想办法让驱动类的这段静态代码块执行即可注册驱动类，而要让这段静态代码块执行，只要让该类被类加载器加载即可）</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115834.png" alt></p><p>调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过反射，加载与注册驱动类，解耦合（不直接依赖）</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><h3 id="2、服务提供者框架"><a href="#2、服务提供者框架" class="headerlink" title="2、服务提供者框架"></a>2、服务提供者框架</h3><p>（例如：JDBC的驱动程序）自动注册（有版本要求）<br>符合JDBC 4.0规范的驱动程序包含了一个文件META-INF/services/java.sql.Driver，在这个文件中提供了JDBC驱动实现的类名。例如：mysql-connector-java-5.1.40-bin.jar文件中就可以找到java.sql.Driver文件，用文本编辑器打开文件就可以看到：com.mysql.jdbc.Driver类。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115935.png" alt></p><p>JVM的服务提供者框架在启动应用时就会注册服务，例如：MySQL的JDBC驱动就会被注册，而原代码中的Class.forName(“com.mysql.jdbc.Driver”)仍然可以存在，但是不会起作用。<br>但是注意mysql-connector-java-5.0.8-bin.jar版本的jar中没有，如下</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605120032.png" alt></p><h2 id="（三）获取数据库链接"><a href="#（三）获取数据库链接" class="headerlink" title="（三）获取数据库链接"></a>（三）获取数据库链接</h2><p>可以通过 DriverManager 类建立到数据库的连接Connection：<br>DriverManager 试图从已注册的 JDBC 驱动程序集中选择一个适当的驱动程序。</p><ul><li>public static Connection getConnection(String url) </li><li>public static Connection getConnection(String url,String user, String password)</li><li>public static Connection getConnection(String url,Properties info)其中Properties info通常至少应该包括 “user” 和 “password” 属性</li></ul><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由三部分组成，各部分间用冒号分隔。<br>jdbc:&lt;子协议&gt;:&lt;子名称&gt;  </p><ul><li>协议：JDBC URL中的协议总是jdbc </li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息   </li></ul><p>例如：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605120219.png" alt></p><ul><li>MySQL的连接URL编写方式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</span><br><span class="line">jdbc:mysql://localhost:3306/testdb</span><br><span class="line">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</span><br><span class="line"></span><br><span class="line">jdbc:mysql://localhost:3306/testdb?user=root&amp;password=123456</span><br></pre></td></tr></table></figure><ul><li>Oracle9i:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</span><br><span class="line">jdbc:oracle:thin:@localhost:1521:testdb</span><br><span class="line">SQLServer</span><br><span class="line">jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</span><br><span class="line">jdbc:sqlserver://localhost:1433:DatabaseName=testdb</span><br><span class="line">//1、加载与注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">//2、获取数据库连接</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure><h2 id="（四）操作或访问数据库"><a href="#（四）操作或访问数据库" class="headerlink" title="（四）操作或访问数据库"></a>（四）操作或访问数据库</h2><ul><li>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。</li><li>其实一个数据库连接就是一个Socket连接。</li><li>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </span><br><span class="line">    PrepatedStatement：SQL 语句被预编译并存储在此对象中，</span><br><span class="line">                                 然后可以使用此对象多次高效地执行该语句。</span><br><span class="line">        CallableStatement：用于执行 SQL 存储过程</span><br></pre></td></tr></table></figure><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>通过调用 Connection 对象的 createStatement() 方法创建该对象<br>该对象用于执行静态的 SQL 语句，并且返回执行结果<br>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE</span><br><span class="line">ResultSet excuteQuery(String sql)：执行查询操作SELECT</span><br></pre></td></tr></table></figure><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul><li>通过调用 Statement 对象的 excuteQuery() 方法创建该对象</li><li>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现</li><li>ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行</li><li>ResultSet 接口的常用方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean next()</span><br><span class="line">getXxx(String columnLabel)：columnLabel使用 SQL AS 子句指定的列标签。</span><br><span class="line">                            如果未指定 SQL AS 子句，则标签是列名称</span><br><span class="line">getXxx(int index) :索引从1开始</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605141430.png" alt></p><h2 id="（五）释放资源"><a href="#（五）释放资源" class="headerlink" title="（五）释放资源"></a>（五）释放资源</h2><p>Connection、Statement、ResultSet都是应用程序和数据库服务器的连接资源，使用后一定要关闭，可以在finally中关闭<br>演示未关闭后果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.conn;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line">public class TestConnectionClose &#123;</span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">//1、加载与注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">//2、获取数据库连接</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line"></span><br><span class="line">//my.ini中max_connections=10</span><br><span class="line">for (int i = 0; i &lt; 15; i++) &#123;</span><br><span class="line">Connection conn = DriverManager.getConnection(url,&quot;root&quot;, &quot;123456&quot;);</span><br><span class="line">System.out.println(conn);</span><br><span class="line">//没有关闭，资源一直没有释放</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（六）增、删、改、查示例代码"><a href="#（六）增、删、改、查示例代码" class="headerlink" title="（六）增、删、改、查示例代码"></a>（六）增、删、改、查示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">package com.statement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 网络编程：tcp</span><br><span class="line"> * </span><br><span class="line"> * 服务器端：</span><br><span class="line"> * 1、ServerSocket server = new ServerSocket(3306);</span><br><span class="line"> * 2、Socket socket = server.accept();</span><br><span class="line"> * 3、InputStream input = socket.getInputStream();//接收sql，客户端传过来的</span><br><span class="line"> * 4、在服务器执行sql</span><br><span class="line"> * 5、把结果给客户端</span><br><span class="line"> * </span><br><span class="line"> * 客户端：</span><br><span class="line"> * 1、Socket socket = new Socket(服务器的IP地址，3306);</span><br><span class="line"> * 2、传sql</span><br><span class="line"> * 3、OutputStream out = socket.getOutputStream();</span><br><span class="line"> * 4、out.write(sql);</span><br><span class="line"> * 5、接收结果</span><br><span class="line"> * 6、断开连接  out.close();socket.close();</span><br><span class="line"> */</span><br><span class="line">public class TestStatement &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testAdd()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">             String sql = &quot;INSERT INTO t_department(dname,description) VALUES(&apos;财务部&apos;,&apos;负责发钱工作&apos;)&quot;;</span><br><span class="line">int len = st.executeUpdate(sql);//把insert,update,delete都用这个方法</span><br><span class="line"></span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;添加成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;添加失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testUpdate()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        String sql = &quot;UPDATE t_department SET description = &apos;负责发工资、社保、公积金工作&apos; WHERE dname =&apos;财务部&apos;&quot;;</span><br><span class="line">int len = st.executeUpdate(sql);//把insert,update,delete都用这个方法</span><br><span class="line"></span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;修改成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;修改失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testDelete()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">String sql = &quot;DELETE FROM t_department WHERE did =6&quot;;</span><br><span class="line">int len = st.executeUpdate(sql);//把insert,update,delete都用这个方法</span><br><span class="line"></span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;删除成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;删除失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testSelect()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        String sql = &quot;SELECT * FROM t_department&quot;;</span><br><span class="line">ResultSet rs = st.executeQuery(sql);//select语句用query方法</span><br><span class="line">while(rs.next())&#123;//是否有下一行</span><br><span class="line">//取这一行的单元格</span><br><span class="line">int id = rs.getInt(1);</span><br><span class="line">String name = rs.getString(2);</span><br><span class="line">String desc = rs.getString(3);</span><br><span class="line"></span><br><span class="line">System.out.println(id+&quot;\t&quot; + name + &quot;\t&quot; + desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testSelect2()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">String sql = &quot;SELECT did,dname FROM t_department&quot;;</span><br><span class="line">ResultSet rs = st.executeQuery(sql);//select语句用query方法</span><br><span class="line">while(rs.next())&#123;//是否有下一行</span><br><span class="line">//取这一行的单元格</span><br><span class="line">int id = rs.getInt(&quot;did&quot;);</span><br><span class="line">String name = rs.getString(&quot;dname&quot;);</span><br><span class="line">System.out.println(id+&quot;\t&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、PreparedStatement"><a href="#四、PreparedStatement" class="headerlink" title="四、PreparedStatement"></a>四、PreparedStatement</h1><h2 id="1、Statement的不足"><a href="#1、Statement的不足" class="headerlink" title="1、Statement的不足"></a>1、Statement的不足</h2><h3 id="（1）SQL拼接"><a href="#（1）SQL拼接" class="headerlink" title="（1）SQL拼接"></a>（1）SQL拼接</h3><h3 id="（2）SQL注入"><a href="#（2）SQL注入" class="headerlink" title="（2）SQL注入"></a>（2）SQL注入</h3><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement 取代 Statement 就可以了。</p><h3 id="（3）处理Blob类型的数据"><a href="#（3）处理Blob类型的数据" class="headerlink" title="（3）处理Blob类型的数据"></a>（3）处理Blob类型的数据</h3><ul><li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li><li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605141849.png" alt></p><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。<br>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,</span><br><span class="line">  `head_picture` mediumblob,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package com.statement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Statement：</span><br><span class="line"> * 1、SQL拼接</span><br><span class="line"> * 2、SQL注入</span><br><span class="line"> * 3、处理不了Blob类型的数据</span><br><span class="line"> */</span><br><span class="line">public class TestStatementProblem &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void add() throws Exception&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入领导编号：&quot;);</span><br><span class="line">int mid = input.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入部门编号：&quot;);</span><br><span class="line">int did = input.nextInt();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/1221db&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、创建Statement对象</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">//3、编写sql</span><br><span class="line">String sql = &quot;INSERT INTO emp (ename,`mid`,did) VALUES(&apos;&quot; + name+&quot;&apos;,&quot; + mid + &quot;,&quot; + did + &quot;)&quot;;</span><br><span class="line"></span><br><span class="line">//4、执行sql</span><br><span class="line">int update = st.executeUpdate(sql);</span><br><span class="line">System.out.println(update&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">//5、释放资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void select()throws Exception&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/1221db&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、写sql</span><br><span class="line">//孙红雷  &apos; or &apos;1&apos; = &apos;1</span><br><span class="line">String sql = &quot;SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = &apos;&quot; + name + &quot;&apos;&quot;;</span><br><span class="line">System.out.println(sql);</span><br><span class="line">//SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = &apos;孙红雷  &apos; or &apos;1&apos; = &apos;1&apos;</span><br><span class="line"></span><br><span class="line">//3、用Statement执行</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">//4、执行查询sql</span><br><span class="line">ResultSet rs = st.executeQuery(sql);</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">int id = rs.getInt(1);</span><br><span class="line">String ename = rs.getString(2);</span><br><span class="line">String tel = rs.getString(3);</span><br><span class="line">String gender =rs.getString(4);</span><br><span class="line">double salary = rs.getDouble(5);</span><br><span class="line"></span><br><span class="line">System.out.println(id+&quot;\t&quot; + ename + &quot;\t&quot; + tel + &quot;\t&quot; + gender + &quot;\t&quot; +salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5、释放资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">public void testAddBlob()&#123;</span><br><span class="line">String sql = &quot;INSERT INTO `user` (username,`password`,photo)VALUES(&apos;chai&apos;,&apos;123&apos;,没法在String中处理Blob类型的数据);&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、PreparedStatement概述"><a href="#2、PreparedStatement概述" class="headerlink" title="2、PreparedStatement概述"></a>2、PreparedStatement概述</h2><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象<br>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</p><ul><li>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</li><li>ResultSet executeQuery()执行查询，并返回该查询生成的 ResultSet 对象。</li><li>int executeUpdate()：执行更新，包括增、删、该 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">package com.preparedstatement;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * PreparedStatement：是Statement子接口</span><br><span class="line"> * 1、SQL不需要拼接</span><br><span class="line"> * 2、SQL不会出现注入</span><br><span class="line"> * 3、可以处理Blob类型的数据</span><br><span class="line"> * tinyblob：255字节以内</span><br><span class="line"> * blob：65K以内</span><br><span class="line"> * mediumblob:16M以内</span><br><span class="line"> * longblob：4G以内</span><br><span class="line"> * </span><br><span class="line"> * 如果还是报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：</span><br><span class="line"> * max_allowed_packet=16M</span><br><span class="line"> * 注意：修改了my.ini文件，一定要重新启动服务</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class TestPreparedStatement &#123;</span><br><span class="line">@Test</span><br><span class="line">public void add() throws Exception &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入手机号码：&quot;);</span><br><span class="line">String tel = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入性别：&quot;);</span><br><span class="line">String gender = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入薪资：&quot;);</span><br><span class="line">double salary = input.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入部门编号：&quot;);</span><br><span class="line">int did = input.nextInt();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、编写带？的SQL</span><br><span class="line">String sql = &quot;INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">// 3、准备一个PreparedStatement：预编译sql</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);// 对带？的sql进行预编译</span><br><span class="line"></span><br><span class="line">// 4、把?用具体的值进行代替</span><br><span class="line">pst.setString(1, name);</span><br><span class="line">pst.setString(2, tel);</span><br><span class="line">pst.setString(3, gender);</span><br><span class="line">pst.setDouble(4, salary);</span><br><span class="line">pst.setInt(5, did);</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void select() throws Exception &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、编写带?的sql</span><br><span class="line">//孙红雷  &apos; or &apos;1&apos; = &apos;1</span><br><span class="line">String sql = &quot;SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = ?&quot;;</span><br><span class="line"></span><br><span class="line">// 3、把带？的sql语句进行预编译</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">// 4、把？用具体的变量的赋值</span><br><span class="line">pst.setString(1, name);</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">int id = rs.getInt(&quot;eid&quot;);</span><br><span class="line">String ename = rs.getString(&quot;ename&quot;);</span><br><span class="line">String tel = rs.getString(&quot;tel&quot;);</span><br><span class="line">String gender = rs.getString(&quot;gender&quot;);</span><br><span class="line">double salary = rs.getDouble(&quot;salary&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(id + &quot;\t&quot; + ename + &quot;\t&quot; + tel + &quot;\t&quot; + gender + &quot;\t&quot; + salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">rs.close();</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void addBlob() throws Exception &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入用户名：&quot;);</span><br><span class="line">String username = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入密码：&quot;);</span><br><span class="line">String pwd = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请指定照片的路径：&quot;);</span><br><span class="line">String photoPath = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、 INSERT INTO `user` VALUES(NULL,用户名,密码,照片)</span><br><span class="line">String sql = &quot;INSERT INTO `user` (username,`password`,head_picture)VALUES(?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">// 3、准备一个PreparedStatement：预编译sql</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);// 对带？的sql进行预编译</span><br><span class="line"></span><br><span class="line">// 4、对？进行设置</span><br><span class="line">pst.setString(1, username);</span><br><span class="line">pst.setString(2, pwd);</span><br><span class="line">pst.setBlob(3, new FileInputStream(photoPath));</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len &gt; 0 ? &quot;添加成功&quot; : &quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、PreparedStatement-vs-Statement"><a href="#3、PreparedStatement-vs-Statement" class="headerlink" title="3、PreparedStatement vs Statement"></a>3、PreparedStatement vs Statement</h2><ul><li>代码的可读性和可维护性. Statement的sql拼接是个难题。</li><li>PreparedStatement 可以防止 SQL 注入 </li><li>PreparedStatement 可以处理Blob类型的数据</li><li>PreparedStatement 能最大可能提高性能：（Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高）<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li></ul></li></ul><h2 id="4、JDBC-取得数据库自动生成的主键"><a href="#4、JDBC-取得数据库自动生成的主键" class="headerlink" title="4、JDBC 取得数据库自动生成的主键"></a>4、JDBC 取得数据库自动生成的主键</h2><h3 id="获取自增长的键值："><a href="#获取自增长的键值：" class="headerlink" title="获取自增长的键值："></a>获取自增长的键值：</h3><h4 id="（1）在创建PreparedStatement对象时"><a href="#（1）在创建PreparedStatement对象时" class="headerlink" title="（1）在创建PreparedStatement对象时"></a>（1）在创建PreparedStatement对象时</h4><p>原来：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pst = conn.preparedStatement(sql);</span><br></pre></td></tr></table></figure><p>现在：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pst = conn.prepareStatement(orderInsert,Statement.RETURN_GENERATED_KEYS);</span><br></pre></td></tr></table></figure><h4 id="（2）原来执行更新"><a href="#（2）原来执行更新" class="headerlink" title="（2）原来执行更新"></a>（2）原来执行更新</h4><p>原来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int len = pst.executeUpdate();</span><br></pre></td></tr></table></figure><p> 现在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int len = pst.executeUpdate();</span><br><span class="line">ResultSet rs = pst.getGeneratedKeys();</span><br><span class="line">if(rs.next())&#123;</span><br><span class="line"> Object key = rs.getObject(第几列);//获取自增长的键值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.preparedstatement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class TestGenerateKey &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入手机号码：&quot;);</span><br><span class="line">String tel = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入性别：&quot;);</span><br><span class="line">String gender = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入薪资：&quot;);</span><br><span class="line">double salary = input.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入部门编号：&quot;);</span><br><span class="line">int did = input.nextInt();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、编写带？的SQL</span><br><span class="line">String sql = &quot;INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">// 3、准备一个PreparedStatement：预编译sql</span><br><span class="line">//执行添加语句，如果需要获取自增长的键值，那么在此处要告知mysql服务器，在创建PreparedStatement对象时，增加一个参数</span><br><span class="line">//autoGeneratedKeys - 指示是否应该返回自动生成的键的标志，它是 Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS 之一</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"></span><br><span class="line">// 4、把?用具体的值进行代替</span><br><span class="line">pst.setString(1, name);</span><br><span class="line">pst.setString(2, tel);</span><br><span class="line">pst.setString(3, gender);</span><br><span class="line">pst.setDouble(4, salary);</span><br><span class="line">pst.setInt(5, did);</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">ResultSet rs = pst.getGeneratedKeys();</span><br><span class="line">if(rs.next())&#123;</span><br><span class="line">System.out.println(&quot;新员工编号是：&quot; + rs.getObject(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、批处理"><a href="#5、批处理" class="headerlink" title="5、批处理"></a>5、批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。<br>JDBC的批量处理语句包括下面两个方法：</p><ul><li>addBatch()：添加需要批量处理的SQL语句或参数</li><li>executeBatch()：执行批量处理语句；</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><p>注意：<br><strong>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements=true<br>PreparedStatement作批处理插入时使用values（使用value没有效果）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.preparedstatement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestBatch &#123;</span><br><span class="line">@Test</span><br><span class="line">public void noBatch()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql = &quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;;</span><br><span class="line">        PreparedStatement st = conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;1000; i++)&#123;</span><br><span class="line">        st.setString(1, &quot;测试部门&quot; + i);</span><br><span class="line">        st.setString(2, &quot;测试部门描述&quot;  + i);</span><br><span class="line">        </span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void useBatch()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql = &quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;;</span><br><span class="line">        PreparedStatement st = conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;1000; i++)&#123;</span><br><span class="line">        st.setString(1, &quot;测试部门&quot; + i);</span><br><span class="line">        st.setString(2, &quot;测试部门描述&quot;  + i);</span><br><span class="line">        </span><br><span class="line">        st.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st.executeBatch();</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、事务"><a href="#6、事务" class="headerlink" title="6、事务"></a>6、事务</h2><p>JDBC程序中当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。<br>JDBC程序中为了让多个 SQL 语句作为一个事务执行：（重点）  </p><ul><li>调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</li><li>在其中某个操作失败或出现异常时，调用 rollback(); 方法回滚事务</li><li>若此时 Connection 没有被关闭, 则需要恢复其自动提交状态 setAutoCommit(true);</li></ul><p>注意：<br><strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.transaction;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class TestTransaction &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">//设置手动提交</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">String sql1 = &quot;update t_department set description = ? where did = ?&quot;;</span><br><span class="line">PreparedStatement pst1 = conn.prepareStatement(sql1);</span><br><span class="line">pst1.setObject(1, &quot;挣大钱的&quot;);</span><br><span class="line">pst1.setObject(2, 4);</span><br><span class="line">int len1 = pst1.executeUpdate();</span><br><span class="line">System.out.println(len1&gt;0?&quot;更新部门信息成功&quot;:&quot;更新部门信息失败&quot;);</span><br><span class="line">pst1.close();</span><br><span class="line"></span><br><span class="line">String sql2 = &quot;update t_employee set salary = salary + ? where did = ?&quot;;</span><br><span class="line">PreparedStatement pst2 = conn.prepareStatement(sql2);</span><br><span class="line">pst2.setObject(1, 20000);</span><br><span class="line">pst2.setObject(2, 4);</span><br><span class="line">int len2 = pst2.executeUpdate();</span><br><span class="line">System.out.println(len2&gt;0?&quot;更新部门信息成功&quot;:&quot;更新部门信息失败&quot;);</span><br><span class="line">pst2.close();</span><br><span class="line"></span><br><span class="line">conn.commit();</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(conn!=null)&#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(conn!=null)&#123;</span><br><span class="line">//恢复自动提交</span><br><span class="line">conn.setAutoCommit(true);</span><br><span class="line">//释放连接</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、数据库连接池"><a href="#五、数据库连接池" class="headerlink" title="五、数据库连接池"></a>五、数据库连接池</h1><h2 id="1、数据库连接池"><a href="#1、数据库连接池" class="headerlink" title="1、数据库连接池"></a>1、数据库连接池</h2><h3 id="（1）数据库连接池的必要性"><a href="#（1）数据库连接池的必要性" class="headerlink" title="（1）数据库连接池的必要性"></a>（1）数据库连接池的必要性</h3><p>不使用数据库连接池存在的问题:  </p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li>对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。</li><li>这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li></ul><p>为解决传统开发中的数据库连接问题，可以采用<strong>数据库连接池技术（connection pool）</strong>。</p><ul><li>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，<strong>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605142920.png" alt></p><p>数据库连接池技术的优点：  </p><ul><li>资源重用：<ul><li>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li></ul></li></ul><ul><li>更快的系统反应速度<ul><li>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</li></ul></li></ul><ul><li>新的资源分配手段<ul><li>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</li></ul></li></ul><ul><li>统一的连接管理，避免数据库连接泄露<ul><li>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</li></ul></li></ul><h3 id="（2）多种开源的数据库连接池"><a href="#（2）多种开源的数据库连接池" class="headerlink" title="（2）多种开源的数据库连接池"></a>（2）多种开源的数据库连接池</h3><p>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：</p><ul><li>DBCP 是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持</li><li>C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以</li><li>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li>BoneCP 是一个开源组织提供的数据库连接池，速度快</li><li>Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不知道是否有BoneCP快</li></ul><p>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池<br>注意：  </p><ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul><h3 id="（3）Druid（德鲁伊）数据源"><a href="#（3）Druid（德鲁伊）数据源" class="headerlink" title="（3）Druid（德鲁伊）数据源"></a>（3）Druid（德鲁伊）数据源</h3><p> Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605143309.png" alt>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.druid;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line">public class TestDruid &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">initialSize=10</span><br><span class="line">maxActive=20</span><br><span class="line">maxWait=1000</span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605143757.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605143854.png" alt></p><h2 id="2、ThreadLocal"><a href="#2、ThreadLocal" class="headerlink" title="2、ThreadLocal"></a>2、ThreadLocal</h2><ul><li>JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</li><li>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。</span><br><span class="line">2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。</span><br><span class="line">3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。</span><br><span class="line">4、ThreadLocal.initialValue:</span><br><span class="line">ThreadLocal没有被当前线程赋值时或当前线程刚调remove方法后调用get方法，返回此方法值。</span><br></pre></td></tr></table></figure><h2 id="3、封装JDBCTools"><a href="#3、封装JDBCTools" class="headerlink" title="3、封装JDBCTools"></a>3、封装JDBCTools</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.util;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 获取连接或释放连接的工具类</span><br><span class="line"> */</span><br><span class="line">public class JDBCTools &#123;</span><br><span class="line">// 1、数据源,即连接池</span><br><span class="line">private static DataSource dataSource;</span><br><span class="line"></span><br><span class="line">// 2、ThreadLocal对象</span><br><span class="line">private static ThreadLocal&lt;Connection&gt; threadLocal;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//1、读取druip.properties文件</span><br><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(JDBCTools.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line"></span><br><span class="line">//2、连接连接池</span><br><span class="line">dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">//3、创建线程池</span><br><span class="line">threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取连接的方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> * @throws SQLException</span><br><span class="line"> */</span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">// 从当前线程中获取连接</span><br><span class="line">Connection connection = threadLocal.get();</span><br><span class="line">if (connection == null) &#123;</span><br><span class="line">// 从连接池中获取一个连接</span><br><span class="line">try &#123;</span><br><span class="line">connection = dataSource.getConnection();</span><br><span class="line">// 将连接与当前线程绑定</span><br><span class="line">threadLocal.set(connection);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 释放连接的方法</span><br><span class="line"> * </span><br><span class="line"> * @param connection</span><br><span class="line"> */</span><br><span class="line">public static void releaseConnection() &#123;</span><br><span class="line">// 获取当前线程中的连接</span><br><span class="line">Connection connection = threadLocal.get();</span><br><span class="line">if (connection != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">connection.close();</span><br><span class="line">// 将已经关闭的连接从当前线程中移除</span><br><span class="line">threadLocal.remove();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、Apache—DBUtils简介"><a href="#六、Apache—DBUtils简介" class="headerlink" title="六、Apache—DBUtils简介"></a>六、Apache—DBUtils简介</h1><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605144149.png" alt></p><h2 id="1、DbUtils类"><a href="#1、DbUtils类" class="headerlink" title="1、DbUtils类"></a>1、DbUtils类</h2><p>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：</p><ul><li>public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接的事务，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li><li>public static void rollback(Connection conn)throws SQLException允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul><h2 id="2、QueryRunner类"><a href="#2、QueryRunner类" class="headerlink" title="2、QueryRunner类"></a>2、QueryRunner类</h2><p>该类封装了SQL的执行，是线程安全的。</p><ul><li>可以实现增、删、改、查、批处理、</li><li>考虑了事务处理需要共用Connection。</li><li>该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</li></ul><p>QueryRunner类提供了两个构造方法：  </p><ul><li>QueryRunner()：默认的构造方法</li><li>QueryRunner(DataSource ds)：需要一个 javax.sql.DataSource 来作参数的构造方法。</li></ul><h3 id="（1）更新"><a href="#（1）更新" class="headerlink" title="（1）更新"></a>（1）更新</h3><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul><h3 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a>（2）插入</h3><ul><li>public <t> T insert(Connection conn,String sql,ResultSetHandler<t> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</t></t></li><li>….</li></ul><h3 id="（3）批处理"><a href="#（3）批处理" class="headerlink" title="（3）批处理"></a>（3）批处理</h3><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <t> T insertBatch(Connection conn,String sql,ResultSetHandler<t> rsh,Object[][] params)throws SQLException：只支持INSERT语句</t></t></li><li>…..</li></ul><h3 id="（4）使用QueryRunner类实现查询"><a href="#（4）使用QueryRunner类实现查询" class="headerlink" title="（4）使用QueryRunner类实现查询"></a>（4）使用QueryRunner类实现查询</h3><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>……    </li></ul><h2 id="3、ResultSetHandler接口"><a href="#3、ResultSetHandler接口" class="headerlink" title="3、ResultSetHandler接口"></a>3、ResultSetHandler接口</h2><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet  rs)该方法的返回值将作为QueryRunner类的query()方法的返回值。<br>该接口有如下实现类可以使用：  </p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li><li>BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li>BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li><li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li><li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li></ul><h2 id="4、表与JavaBean"><a href="#4、表与JavaBean" class="headerlink" title="4、表与JavaBean"></a>4、表与JavaBean</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605144702.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605144730.png" alt></p><h2 id="5、示例代码"><a href="#5、示例代码" class="headerlink" title="5、示例代码"></a>5、示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.apache.dbutils;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.MapListHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.Book;</span><br><span class="line">import com.atguigu.util.JDBCTools;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">QueryRunner qr = new QueryRunner();</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testUpdate() throws Exception &#123;</span><br><span class="line">Book book = new Book(0, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, 88.8, 0, 200, null);</span><br><span class="line">// 写sql语句</span><br><span class="line">String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;</span><br><span class="line">qr.update(JDBCTools.getConnection(), sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(),</span><br><span class="line">book.getStock(), book.getImgPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws Exception &#123;</span><br><span class="line">Book book = new Book(0, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, 88.8, 0, 200, null);</span><br><span class="line">// 写sql语句</span><br><span class="line">String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;</span><br><span class="line">Long id = qr.insert(JDBCTools.getConnection(), sql, new ScalarHandler&lt;Long&gt;(), book.getTitle(),</span><br><span class="line">book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getImgPath());</span><br><span class="line">System.out.println(&quot;新书编号：&quot; + id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testBatch() throws Exception &#123;</span><br><span class="line">Object[][] params = new Object[2][3];</span><br><span class="line">params[0][0] = 1;</span><br><span class="line">params[0][1] = 1;</span><br><span class="line">params[0][2] = 1;</span><br><span class="line"></span><br><span class="line">params[1][0] = 1;</span><br><span class="line">params[1][1] = 1;</span><br><span class="line">params[1][2] = 2;</span><br><span class="line"></span><br><span class="line">String sql = &quot;update books set sales = sales + ? , stock = stock - ? where id = ?&quot;;</span><br><span class="line">qr.batch(JDBCTools.getConnection(), sql, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetBean() throws Exception &#123;</span><br><span class="line">// 写sql语句</span><br><span class="line">// 当JavaBean的属性名与字段名不一致时，可以通过指定别名告知属性名</span><br><span class="line">String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;</span><br><span class="line">Book b = qr.query(JDBCTools.getConnection(), sql, new BeanHandler&lt;Book&gt;(Book.class), 2);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetBeanList() throws Exception &#123;</span><br><span class="line">// 写sql语句</span><br><span class="line">// 当JavaBean的属性名与字段名不一致时，可以通过指定别名告知属性名</span><br><span class="line">String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? &quot;;</span><br><span class="line">List&lt;Book&gt; list = qr.query(JDBCTools.getConnection(), sql, new BeanListHandler&lt;Book&gt;(Book.class), 10, 20);</span><br><span class="line">for (Book b : list) &#123;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetSingleValue() throws Exception &#123;</span><br><span class="line">// 获取数据库中图书的总记录数</span><br><span class="line">String sql = &quot;select count(*) from books&quot;;</span><br><span class="line">Long count = qr.query(JDBCTools.getConnection(), sql,  new ScalarHandler&lt;Long&gt;());</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetMap() throws Exception &#123;</span><br><span class="line">String sql = &quot;SELECT user_id userId,COUNT(*) FROM `orders` GROUP BY user_id&quot;;</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; list = qr.query(JDBCTools.getConnection(), sql, new MapListHandler());</span><br><span class="line">for (Map&lt;String, Object&gt; map : list) &#123;</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.bean;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String title;</span><br><span class="line">private String author;</span><br><span class="line">private Double price;</span><br><span class="line">private Integer sales;</span><br><span class="line">private Integer stock;</span><br><span class="line">private String imgPath =&quot;static/img/default.jpg&quot;;</span><br><span class="line">public Book(Integer id, String title, String author, Double price, Integer sales, Integer stock, String imgPath) &#123;</span><br><span class="line">super();</span><br><span class="line">this.id = id;</span><br><span class="line">this.title = title;</span><br><span class="line">this.author = author;</span><br><span class="line">this.price = price;</span><br><span class="line">this.sales = sales;</span><br><span class="line">this.stock = stock;</span><br><span class="line">if(imgPath != null)&#123;</span><br><span class="line">this.imgPath = imgPath;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Book() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(Integer id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public String getTitle() &#123;</span><br><span class="line">return title;</span><br><span class="line">&#125;</span><br><span class="line">public void setTitle(String title) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">&#125;</span><br><span class="line">public String getAuthor() &#123;</span><br><span class="line">return author;</span><br><span class="line">&#125;</span><br><span class="line">public void setAuthor(String author) &#123;</span><br><span class="line">this.author = author;</span><br><span class="line">&#125;</span><br><span class="line">public Double getPrice() &#123;</span><br><span class="line">return price;</span><br><span class="line">&#125;</span><br><span class="line">public void setPrice(Double price) &#123;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getSales() &#123;</span><br><span class="line">return sales;</span><br><span class="line">&#125;</span><br><span class="line">public void setSales(Integer sales) &#123;</span><br><span class="line">this.sales = sales;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getStock() &#123;</span><br><span class="line">return stock;</span><br><span class="line">&#125;</span><br><span class="line">public void setStock(Integer stock) &#123;</span><br><span class="line">this.stock = stock;</span><br><span class="line">&#125;</span><br><span class="line">public String getImgPath() &#123;</span><br><span class="line">return imgPath;</span><br><span class="line">&#125;</span><br><span class="line">public void setImgPath(String imgPath) &#123;</span><br><span class="line">this.imgPath = imgPath;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Book [id=&quot; + id + &quot;, title=&quot; + title + &quot;, author=&quot; + author + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales</span><br><span class="line">+ &quot;, stock=&quot; + stock + &quot;, imgPath=&quot; + imgPath + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、DAO和增删改查通用方法"><a href="#七、DAO和增删改查通用方法" class="headerlink" title="七、DAO和增删改查通用方法"></a>七、DAO和增删改查通用方法</h1><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息<br>作用：为了实现功能的模块化，更有利于代码的维护和升级。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605150226.png" alt></p><h2 id="1、DAO接口"><a href="#1、DAO接口" class="headerlink" title="1、DAO接口"></a>1、DAO接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.User;</span><br><span class="line"></span><br><span class="line">public interface UserDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 根据用户名和密码获取数据库中的记录</span><br><span class="line"> * </span><br><span class="line"> * @param user</span><br><span class="line"> * @return User：用户名和密码正确 null：用户名或密码不正确</span><br><span class="line"> */</span><br><span class="line">public User getUser(User user);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据用户名获取数据库中的记录</span><br><span class="line"> * </span><br><span class="line"> * @param user</span><br><span class="line"> * @return true：用户名已存在， false：用户名可用</span><br><span class="line"> */</span><br><span class="line">public boolean checkUserName(User user);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将用户保存到数据库</span><br><span class="line"> * </span><br><span class="line"> * @param user</span><br><span class="line"> */</span><br><span class="line">public void saveUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.Book;</span><br><span class="line"></span><br><span class="line">public interface BookDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 获取所有图书的方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Book&gt; getBooks();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加图书的方法</span><br><span class="line"> * </span><br><span class="line"> * @param book</span><br><span class="line"> */</span><br><span class="line">public void addBook(Book book);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据图书的id删除图书的方法</span><br><span class="line"> * </span><br><span class="line"> * @param bookId</span><br><span class="line"> */</span><br><span class="line">public void deleteBookById(String bookId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据图书的id获取图书信息</span><br><span class="line"> * </span><br><span class="line"> * @param bookId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Book getBookById(String bookId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新图书信息的方法</span><br><span class="line"> * </span><br><span class="line"> * @param book</span><br><span class="line"> */</span><br><span class="line">public void updateBook(Book book);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量更新图书的库存和销量</span><br><span class="line"> * </span><br><span class="line"> * @param params</span><br><span class="line"> */</span><br><span class="line">public void batchUpdateSalesAndStock(Object[][] params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.Order;</span><br><span class="line"></span><br><span class="line">public interface OrderDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 保存订单的方法</span><br><span class="line"> * </span><br><span class="line"> * @param order</span><br><span class="line"> */</span><br><span class="line">public void saveOrder(Order order);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取所用订单的方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Order&gt; getOrders();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取我的订单的方法</span><br><span class="line"> * </span><br><span class="line"> * @param userId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Order&gt; getMyOrders(int userId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新订单的状态的方法，例如已发货、确认收货等</span><br><span class="line"> * </span><br><span class="line"> * @param orderId</span><br><span class="line"> * @param state</span><br><span class="line"> */</span><br><span class="line">public void updateOrderState(String orderId, int state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.OrderItem;</span><br><span class="line"></span><br><span class="line">public interface OrderItemDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 根据订单号获取对应的订单项</span><br><span class="line"> * </span><br><span class="line"> * @param orderId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;OrderItem&gt; getOrderItemsByOrderId(String orderId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量插入订单项的方法</span><br><span class="line"> * </span><br><span class="line"> * @param params</span><br><span class="line"> */</span><br><span class="line">public void batchInsertOrderItems(Object[][] params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、BasicDAOImpl"><a href="#2、BasicDAOImpl" class="headerlink" title="2、BasicDAOImpl"></a>2、BasicDAOImpl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.dao.impl;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line">import com.atguigu.util.JDBCTools;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span><br><span class="line"> */</span><br><span class="line">public class BasicDAOImpl &#123;</span><br><span class="line">private QueryRunner queryRunner = new QueryRunner();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通用的增删改操作</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int update(String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">int count = 0;</span><br><span class="line">try &#123;</span><br><span class="line">count = queryRunner.update(connection, sql, params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取一个对象</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T getBean(Class&lt;T&gt; type,String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">T t = null;</span><br><span class="line">try &#123;</span><br><span class="line">t = queryRunner.query(connection, sql, new BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取所有对象</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; List&lt;T&gt; getBeanList(Class&lt;T&gt; type,String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">List&lt;T&gt; list = null;</span><br><span class="line">try &#123;</span><br><span class="line">list = queryRunner.query(connection, sql, new BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取一个单一值的方法，专门用来执行像select count(*)... 这样的sql语句</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object getSingleValue(String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">Object value = null;</span><br><span class="line">try &#123;</span><br><span class="line">value = queryRunner.query(connection, sql, new ScalarHandler(), params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 进行批处理的方法</span><br><span class="line"> * 关于二维数组Object[][] params</span><br><span class="line"> * 二维数组的第一维是sql语句要执行的次数</span><br><span class="line"> * 二维数组的第二维就是每条sql语句中要填充的占位符</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> */</span><br><span class="line">public void batchUpdate(String sql , Object[][] params)&#123;</span><br><span class="line">//获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">try &#123;</span><br><span class="line">queryRunner.batch(connection ,sql, params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、DAO实现类"><a href="#3、DAO实现类" class="headerlink" title="3、DAO实现类"></a>3、DAO实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.dao.impl;</span><br><span class="line"></span><br><span class="line">import com.bean.User;</span><br><span class="line">import com.dao.UserDAO;</span><br><span class="line"></span><br><span class="line">public class UserDAOImpl extends BasicDAOImpl implements UserDAO&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public User getUser(User user) &#123;</span><br><span class="line">// 写查询数据库的sql语句</span><br><span class="line">String sql = &quot;select id , username , password , email from users where username = ? and password = ?&quot;;</span><br><span class="line">// 调用BaseDao中的getBean方法</span><br><span class="line">User bean = getBean(User.class, sql, user.getUsername(), user.getPassword());</span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean checkUserName(User user) &#123;</span><br><span class="line">// 写查询数据库的sql语句</span><br><span class="line">String sql = &quot;select id , username , password , email from users where username = ?&quot;;</span><br><span class="line">// 调用BaseDao中的getBean方法</span><br><span class="line">User bean = getBean(User.class, sql, user.getUsername());</span><br><span class="line">return bean!=null;//不为空，说明已存在，返回true，如果bEan是空的，没找到，bean!=null返回false，说明不存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void saveUser(User user) &#123;</span><br><span class="line">//写添加数据到数据库的sql语句</span><br><span class="line">String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;</span><br><span class="line">//调用BaseDao中通用的增删改的方法</span><br><span class="line">update(sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;在Java中，数据库存取技术可分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDBC直接访问数据库&lt;/li&gt;
&lt;li&gt;JDO技术
      
    
    </summary>
    
      <category term="JavaWeb基础笔记" scheme="http://yoursite.com/categories/JavaWeb%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SQL&amp;JDBC" scheme="http://yoursite.com/tags/Java-SQL-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>2. SQL笔记语法(增删改查)</title>
    <link href="http://yoursite.com/2017/09/19/18.%20SQL%E6%A6%82%E8%BF%B0(%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5)/"/>
    <id>http://yoursite.com/2017/09/19/18. SQL概述(增删改查)/</id>
    <published>2017-09-18T16:00:00.000Z</published>
    <updated>2019-06-06T09:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阶段1：常用指令"><a href="#阶段1：常用指令" class="headerlink" title="阶段1：常用指令"></a>阶段1：常用指令</h1><ul><li><p>sql(structure query language)：结构化查询语言  </p></li><li><p>作用：和关系型数据库(dbms)交互的一种方式  </p></li></ul><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ddl(data definition language)：数据定义语言；操作数据库对象(库、表、列..)</span><br><span class="line"></span><br><span class="line">dml(data manipulation language)：数据操作语言；操作数据表中的内容</span><br><span class="line"> 使用的crud操作</span><br><span class="line"> create：创建</span><br><span class="line"> read：查阅</span><br><span class="line"> update：修改</span><br><span class="line"> delete：删除</span><br><span class="line"></span><br><span class="line">dcl(data control language)：数据控制语言；定义访问权限以及安全级别</span><br><span class="line">    使用其中的两个指令配合事务处理：</span><br><span class="line">commit：提交</span><br><span class="line">rollback：回滚</span><br><span class="line"></span><br><span class="line">dql(data query language)：数据查询语言；使用select操作的一些语句</span><br></pre></td></tr></table></figure><h2 id="sql好处："><a href="#sql好处：" class="headerlink" title="sql好处："></a>sql好处：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.易学，语法简单</span><br><span class="line">2.将类似java实现的一些操作简化</span><br></pre></td></tr></table></figure><p>sql的注释：</p><p>分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">单行注释：</span><br><span class="line"></span><br><span class="line">方式一：-- 注释内容</span><br><span class="line">方式二：#注释内容</span><br><span class="line"></span><br><span class="line">多行注释：/* ... */</span><br><span class="line"></span><br><span class="line">#切换数据库(db)</span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line">#显示当前服务器下所有的数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">#显示当前库下的所有数据表(tables)</span><br><span class="line">SHOW TABLES FROM test;</span><br><span class="line"></span><br><span class="line">#简化写法</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">-- 显示当前服务器的版本信息，用户信息</span><br><span class="line">/*</span><br><span class="line">sql语句中函数的使用：</span><br><span class="line">调用方式：</span><br><span class="line">函数名(参数列表)</span><br><span class="line">注意事项：</span><br><span class="line">sql中的函数一定有返回值，和java有区别的</span><br><span class="line">*/</span><br><span class="line">SELECT VERSION(),USER();</span><br></pre></td></tr></table></figure><p>#进阶1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">基础查询</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">select 查询列表 【from 表名】;</span><br><span class="line"></span><br><span class="line">查询列表涉及的内容如下：</span><br><span class="line">常量、表达式、函数、字段(单个、多个)以及上述的组合形式</span><br><span class="line"></span><br><span class="line">涉及到的函数：</span><br><span class="line">database()、user()、version()、ifnull()、concat()、</span><br><span class="line">*/</span><br><span class="line">#切库 --&gt; myemployees</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">#常量：</span><br><span class="line">SELECT 100;</span><br><span class="line">SELECT &apos;jerry&apos;;</span><br><span class="line"> ，</span><br><span class="line">#表达式：</span><br><span class="line">/*</span><br></pre></td></tr></table></figure><p>sql中的+号运算：只做加法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果+号两遍表达式的数据都为数值型，那么直接做加法运算；  </span><br><span class="line">如果+号两遍表达式的数据存在字符型，先尝试将字符型数据隐式转换为数值型数据，  </span><br><span class="line">如果转换成功，直接加法运算；  </span><br><span class="line">如果转换失败，使用0参与加法运算；</span><br></pre></td></tr></table></figure><p>结论：如果运算过程中有null值参与，结果一定为null                   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">SELECT 500+299;</span><br><span class="line">SELECT &apos;300&apos;+200;</span><br><span class="line">SELECT &apos;abc&apos;+&apos;def&apos;;</span><br><span class="line">SELECT &apos;abc&apos;+10;</span><br><span class="line">SELECT NULL + 100;</span><br><span class="line"></span><br><span class="line">#取余操作的符号和被余数有关</span><br><span class="line">SELECT 10%(-3);</span><br><span class="line"></span><br><span class="line">#需求：查询员工的年薪</span><br><span class="line">SELECT salary*12 FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#单个字段</span><br><span class="line">SELECT last_name FROM employees;</span><br><span class="line"></span><br><span class="line">#多个字段</span><br><span class="line">-- 部分字段</span><br><span class="line">-- 需求：查询员工的编号、名字、薪资和部门编号</span><br><span class="line">SELECT employee_id,last_name,salary,department_id</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 全部字段</span><br><span class="line">-- 需求：查询员工信息</span><br><span class="line">-- 方式一：</span><br><span class="line">-- 着重号</span><br><span class="line">SELECT </span><br><span class="line">  `employee_id`,</span><br><span class="line">  `first_name`,</span><br><span class="line">  `last_name`,</span><br><span class="line">  `email`,</span><br><span class="line">  `phone_number`,</span><br><span class="line">  `job_id`,</span><br><span class="line">  `salary`,</span><br><span class="line">  `commission_pct`,</span><br><span class="line">  `manager_id`,</span><br><span class="line">  `department_id`,</span><br><span class="line">  `hiredate` </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">-- 方式二：*</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">#函数</span><br><span class="line">SELECT USER(),VERSION(),DATABASE();</span><br><span class="line"></span><br><span class="line">#【综合案例】：涉及存在函数、单个字段、表达式...</span><br><span class="line">SELECT USER(),last_name,12*salary</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">别名：起一个新的名字</span><br><span class="line">位置：列、表</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">1、AS 别名</span><br><span class="line">2、&apos;&apos;或者&quot;&quot;如果存在特殊符号需要使用引号</span><br><span class="line">*/</span><br><span class="line">#【优化综合案例】：使用别名</span><br><span class="line">SELECT USER(),last_name,12*salary AS year_sal</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT USER(),last_name,12*salary &quot;Year_Sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT USER(),last_name,12*salary 年薪</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT USER(),last_name,12*salary &quot;Year Sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">模拟场景：</span><br><span class="line">错误现象：如何解决？</span><br><span class="line"></span><br><span class="line">ifnull(expr1,expr2)：</span><br><span class="line">如果expr1不为null，就拿其本身参与运算</span><br><span class="line">如果expr1为null，就使用expr2参与运算</span><br><span class="line">*/</span><br><span class="line">SELECT USER(),last_name,commission_pct,12*salary*(1+IFNULL(commission_pct,0)) &quot;Year Sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">模拟场景：</span><br><span class="line">XXX的年薪是XXX</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">concat(...)：拼接类似于java中的+号</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT CONCAT(last_name,&apos;的年薪是&apos;,12*salary*(1+IFNULL(commission_pct,0))) details</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><h1 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">select 查询列表</span><br><span class="line">from 表名</span><br><span class="line">where 条件</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line"></span><br><span class="line">关系表达式：</span><br><span class="line">运算符：&gt; &gt;= &lt; &lt;= = != &lt;&gt;</span><br><span class="line"></span><br><span class="line">逻辑表达式：</span><br><span class="line">运算符：and(与，并且) or(或，或者) not(非，取反)</span><br><span class="line"></span><br><span class="line">其它运算符：</span><br><span class="line">1、模糊查询：like</span><br><span class="line">2、between A and B：在[A,B]之间</span><br><span class="line">3、in(...)：只要满足条件都返回</span><br><span class="line">4、is null：</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">where紧随from</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#演示关系运算符的使用</span><br><span class="line">-- 案例1：查询工资&gt;10000的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE salary &gt; 10000;</span><br><span class="line"></span><br><span class="line">-- 案例2：查询 job_id不是&apos;IT_PROG&apos;的员工姓名、job_id、salary </span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &lt;&gt; &apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id != &apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE NOT(job_id = &apos;IT_PROG&apos;);</span><br><span class="line"></span><br><span class="line">#演示逻辑运算符的使用</span><br><span class="line">-- 案例3：查询工资&gt;10000并且小于20000的员工姓名、工资、年薪</span><br><span class="line">SELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; 10000 AND salary &lt; 20000;</span><br><span class="line">-- 案例4：查询部门编号不在90到120之间的并且 工资&gt;11000的员工信息</span><br><span class="line">SELECT last_name,department_id,salary FROM employees</span><br><span class="line">WHERE NOT(department_id &gt;= 90 AND department_id &lt;= 120) AND salary &gt; 11000;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">模糊查询的使用：</span><br><span class="line">配合通配符使用：</span><br><span class="line">_：匹配任意单个字符</span><br><span class="line">%：匹配0或者任意多个字符</span><br><span class="line">*/</span><br><span class="line">#案例1：查询员工信息表中姓名第一个字符为e的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;e%&apos;;</span><br><span class="line"></span><br><span class="line">#案例2：查询员工信息表中姓名第二个字符为e，第五个字符为a的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;_e__a%&apos;;</span><br><span class="line">#案例3：查询姓名中最后第二个字符为s的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%s_&apos;;</span><br><span class="line">#案例4：查询姓名中第二个字符为_的员工信息</span><br><span class="line">#方式一：使用\实现转义</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;_\_%&apos;;</span><br><span class="line">#方式二：使用escape关键字实现</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;_#_%&apos; ESCAPE &apos;#&apos;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">between...and...的使用：</span><br><span class="line">作用：判断是否在某一个区间范围内(含头含尾闭区间)返回布尔值</span><br><span class="line">将 and操作简化</span><br><span class="line">*/</span><br><span class="line">#查询年薪在100000到200000的员工年薪和姓名</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary*12*(1+IFNULL(commission_pct,0)) BETWEEN 100000 AND 200000;</span><br><span class="line">#案例2：查询年薪在100740到187200的员工年薪和姓名</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary*12*(1+IFNULL(commission_pct,0)) BETWEEN 100740 AND 187200;</span><br><span class="line"></span><br><span class="line">SELECT salary FROM employees</span><br><span class="line">WHERE salary &gt;= 8000 AND salary &lt;= 14000;</span><br><span class="line"></span><br><span class="line">SELECT salary FROM employees</span><br><span class="line">WHERE salary BETWEEN 8000 AND 14000;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">in(...)的使用：</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">可以简化or的使用，</span><br><span class="line">记住：</span><br><span class="line">1、如果内容不匹配页不会报错，只是不返回任何内容</span><br><span class="line">2、会自动将字符类型转换为数值型(如果需要)</span><br><span class="line">*/</span><br><span class="line">-- 案例1：查询在80、90、100号部门工作的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department_id = 80 OR department_id = 90 OR department_id = 100;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department_id IN(80,90,100);</span><br><span class="line">-- where department_id in(80,90,&apos;100&apos;,null);</span><br><span class="line"></span><br><span class="line">SELECT * FROM departments;</span><br><span class="line"></span><br><span class="line">-- 案例2：查询工种编号是IT_PROG或是ST_CLERK或是AD_VP的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE job_id IN(&apos;IT_PROG&apos;,&apos;ST_CLERK&apos;,&apos;AD_VP&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">not的使用：</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">#案例1：查询哪些员工没有奖金</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line">#案例2：查询哪些员工有奖金</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE NOT commission_pct IS NULL;</span><br></pre></td></tr></table></figure><h1 id="进阶3："><a href="#进阶3：" class="headerlink" title="进阶3："></a>进阶3：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">排序查询：</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">select 查询列表 --②</span><br><span class="line">from 表名--①</span><br><span class="line">where 条件--③</span><br><span class="line">order by 排序列表 asc|desc --④</span><br><span class="line"></span><br><span class="line">排序列表：</span><br><span class="line">单个字段、多个字段、函数、别名、表达式</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1、asc可以省略，默认升序排列</span><br><span class="line">`666`</span><br><span class="line">总结：</span><br><span class="line">order by子句出现在最后位置，除了limit...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">#单个字段：</span><br><span class="line">-- 案例1：按工资从低到高排序</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary ASC;</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary;</span><br><span class="line">-- 案例2：按工资从高到低排序</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC;</span><br><span class="line"></span><br><span class="line">#多个字段：</span><br><span class="line">-- 案例：部门编号&gt;50的按工资从高到低排序，如果一样，再按frist_name升序</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department_id &gt; 50</span><br><span class="line">ORDER BY salary DESC,first_name ASC;</span><br><span class="line"></span><br><span class="line">#按表达式排序</span><br><span class="line">-- 案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%e%&apos;</span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;</span><br><span class="line"></span><br><span class="line">#按别名排序</span><br><span class="line">-- 案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%e%&apos;</span><br><span class="line">ORDER BY 年薪 DESC;</span><br><span class="line"></span><br><span class="line">#按函数排序</span><br><span class="line">-- 案例：显示所有有奖金的员工姓名、奖金、姓名的长度，按姓名的长度从低到高排序</span><br><span class="line">-- length()函数的使用</span><br><span class="line">SELECT last_Name,commission_pct,LENGTH(last_name) 长度</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">ORDER BY LENGTH(last_name);</span><br><span class="line"></span><br><span class="line">SELECT last_Name,commission_pct,LENGTH(last_name) 长度</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">ORDER BY 长度;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阶段1：常用指令&quot;&gt;&lt;a href=&quot;#阶段1：常用指令&quot; class=&quot;headerlink&quot; title=&quot;阶段1：常用指令&quot;&gt;&lt;/a&gt;阶段1：常用指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sql(structure query language)：结构化查询语言
      
    
    </summary>
    
      <category term="JavaWeb基础笔记" scheme="http://yoursite.com/categories/JavaWeb%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SQL&amp;JDBC" scheme="http://yoursite.com/tags/Java-SQL-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>1. MYSQL数据库5.5安装(win7)及使用</title>
    <link href="http://yoursite.com/2017/09/14/17.%20MYSQL%E6%95%B0%E6%8D%AE%E5%BA%935.5%E5%AE%89%E8%A3%85(win7)%E5%8F%8A%E4%BD%BF%E7%94%A817.9.4/"/>
    <id>http://yoursite.com/2017/09/14/17. MYSQL数据库5.5安装(win7)及使用17.9.4/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2019-06-06T13:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySql数据库</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随便打开一个Web网站，比如淘宝：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604232623.png" alt></p><p>为什么学习MySQL数据库？</p><p> <img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604232703.png" alt></p><ul><li><p>MySQL广占IT市场，比如淘宝、网易、百度、新浪、facebook等大部分互联网公司，都在使用mysql软件，而且在网络游戏领域，大部分的后台数据库都在使用mysql，如劲舞团、魔兽世界，还有更厉害的，中国电网、中国移动中很多项目也在使用我们的mysql。</p></li><li><p>如果我们把mysql学好学精了，还愁没工作吗？我们甚至可以去任何IT行业公司，这不像小众 的产品，你哪怕学透了，也不一定有多少人要你。</p></li></ul><h1 id="第1章-数据库概述"><a href="#第1章-数据库概述" class="headerlink" title="第1章 数据库概述"></a>第1章 数据库概述</h1><h2 id="1-1-什么是数据库"><a href="#1-1-什么是数据库" class="headerlink" title="1.1 什么是数据库"></a>1.1 什么是数据库</h2><ul><li>数据库是持久化数据的一种介质，可以理解成用来存储和管理数据的仓库！</li><li>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。持久化的大多数时候是将内存中的数据存储在数据库中，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><h2 id="1-2为什么要用数据库"><a href="#1-2为什么要用数据库" class="headerlink" title="1.2为什么要用数据库"></a>1.2为什么要用数据库</h2><ul><li>保存数据 的容器：数组、集合、文件  </li><li>保存到文件：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604232913.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605093234.png" alt></p><ul><li>可将数据持久化到硬盘</li><li>可存储大量数据</li><li>方便检索</li><li>保证数据的一致性、完整性</li><li>安全，可共享</li><li>通过组合分析，可以产生新数据</li></ul><h2 id="1-3常见数据库产品"><a href="#1-3常见数据库产品" class="headerlink" title="1.3常见数据库产品"></a>1.3常见数据库产品</h2><ul><li>Oracle：甲骨文</li><li>DB2：IBM；</li><li>SQL Server：微软；</li><li>MySQL：甲骨文；</li></ul><h2 id="1-4数据库相关概念"><a href="#1-4数据库相关概念" class="headerlink" title="1.4数据库相关概念"></a>1.4数据库相关概念</h2><ul><li><p>DB<br>数据库（ database ）：存储数据的“仓库”。它保存了一系列有组织的数据。</p></li><li><p>DBMS<br>数据库管理系统（ Database Management System ）。数据库是通过 DBMS 创<br>建和操作的容器</p></li><li><p>SQL<br>结构化查询语言（ Structure Query Language ）：专门用来与数据库通信的语<br>言。  </p></li></ul><p>三者的关系：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605093502.png" alt></p><h2 id="1-5数据库存储数据的特点"><a href="#1-5数据库存储数据的特点" class="headerlink" title="1.5数据库存储数据的特点"></a>1.5数据库存储数据的特点</h2><p>1、将数据放到表中，表再放到库中<br>2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。<br>表名具有唯一性。<br>3、表具有一些特性，这些特性定义了数据在表中如何存储，<br>类似java中 “类”的设计。<br>4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，<br>每一列类似java 中的”属性”<br>5、表中的数据是按行存储的，每一行类似于java中的“对象”。  </p><h1 id="第2章-MySQL数据库的介绍"><a href="#第2章-MySQL数据库的介绍" class="headerlink" title="第2章 MySQL数据库的介绍"></a>第2章 MySQL数据库的介绍</h1><h2 id="2-1-MySQL产品的介绍"><a href="#2-1-MySQL产品的介绍" class="headerlink" title="2.1 MySQL产品的介绍"></a>2.1 MySQL产品的介绍</h2><blockquote><p>MySQL是一种开放源代码的关系型数据库管理系统，开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购。而2009年,SUN又被Oracle收购.目前 MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库（Facebook, Twitter, YouTube）。</p></blockquote><h2 id="2-2-MySQL产品的优点"><a href="#2-2-MySQL产品的优点" class="headerlink" title="2.2 MySQL产品的优点"></a>2.2 MySQL产品的优点</h2><ul><li>成本低：开放源代码，一般可以免费试用 </li><li>性能高：执行很快 </li><li>简单：很容易安装和使用 </li></ul><h2 id="2-2-MySQL服务端的安装和卸载"><a href="#2-2-MySQL服务端的安装和卸载" class="headerlink" title="2.2 MySQL服务端的安装和卸载"></a>2.2 MySQL服务端的安装和卸载</h2><p>DBMS分为两类： </p><ul><li>基于共享文件系统的DBMS （Access ） </li><li>基于客户机——服务器的DBMS<br>（MySQL、Oracle、SqlServer） </li></ul><p>注：查看数据库的安装和卸载文档</p><h3 id="1、win7MYSQL卸载"><a href="#1、win7MYSQL卸载" class="headerlink" title="1、win7MYSQL卸载"></a>1、win7MYSQL卸载</h3><h4 id="1）软件的卸载"><a href="#1）软件的卸载" class="headerlink" title="1）软件的卸载"></a>1）软件的卸载</h4><p>方式一：通过控制面板  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605093953.png" alt></p><p>方式二：通过电脑管家等软件卸载  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094036.png" alt></p><p>方式三：通过安装包中提供的卸载功能卸载  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094122.png" alt></p><h4 id="2）清理残余文件"><a href="#2）清理残余文件" class="headerlink" title="2）清理残余文件"></a>2）清理残余文件</h4><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装<br>a）清除安装残余文件  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094245.png" alt></p><p>b）清除数据残余文件<br>请在卸载前做好数据备份  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094317.png" alt></p><p>c）清理注册表</p><p>如果前两步做了，再次安装还是失败，那么可以清理注册表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line">2：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除</span><br><span class="line">3：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line">4：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除</span><br><span class="line">5：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务目录删除</span><br><span class="line">6：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除</span><br></pre></td></tr></table></figure></p><p>注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类</p><h3 id="2、win7-MYSQL5-5-安装"><a href="#2、win7-MYSQL5-5-安装" class="headerlink" title="2、win7 MYSQL5.5 安装"></a>2、win7 MYSQL5.5 安装</h3><h4 id="（1）准备安装"><a href="#（1）准备安装" class="headerlink" title="（1）准备安装"></a>（1）准备安装</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094526.png" alt></p><h4 id="（2）欢迎安装"><a href="#（2）欢迎安装" class="headerlink" title="（2）欢迎安装"></a>（2）欢迎安装</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094623.png" alt></p><h4 id="（3）准许协议"><a href="#（3）准许协议" class="headerlink" title="（3）准许协议"></a>（3）准许协议</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094646.png" alt></p><h4 id="（4）选择安装模式"><a href="#（4）选择安装模式" class="headerlink" title="（4）选择安装模式"></a>（4）选择安装模式</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094719.png" alt></p><ul><li>Typical：表示一般常用的组件都会被安装，默认情况下安装到”C:\Program Files\MySQL\MySQL Server 5.5\”下。</li><li>Complete：表示会安装所有的组件。此套件会占用比较大的磁盘空间。</li><li>Custom：表示用户可以选择要安装的组件，可以更改默认按照的路径。这种按照类型最灵活，适用于高级用户。</li></ul><h4 id="（5）选择安装组件及安装路径"><a href="#（5）选择安装组件及安装路径" class="headerlink" title="（5）选择安装组件及安装路径"></a>（5）选择安装组件及安装路径</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094830.png" alt></p><p>这里可以选择安装哪些部分，主要是这里可以设置两个路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL Server的应用软件的安装路径，默认在</span><br><span class="line">    “C:\Program Files\MySQL\MySQL Server 5.5\”</span><br><span class="line">Server data files的数据存储的目录路径，默认在</span><br><span class="line">    “C:\ProgramData\MySQL\MySQL Server 5.5\”</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095026.png" alt></p><h4 id="（6）开始安装"><a href="#（6）开始安装" class="headerlink" title="（6）开始安装"></a>（6）开始安装</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095109.png" alt></p><p>安装进度</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095142.png" alt></p><p>系统会显示MySQL Enterprise版（企业版）的一些功能介绍界面，可以单击“Next”继续。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095217.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095310.png" alt></p><h4 id="（7）安装完成"><a href="#（7）安装完成" class="headerlink" title="（7）安装完成"></a>（7）安装完成</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095331.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单击“Finish”按钮完成安装过程。</span><br><span class="line">如果想马上配置数据库连接，</span><br><span class="line">选择“Launch the MySQL Instance Configuration Wizard”复选框。</span><br><span class="line">如果现在没有配置，以后想要配置或重新配置都可以在“MySQL Server”的安装目录的bin目录下</span><br><span class="line">（例如：D:\ProgramFiles\MySQL5.5\MySQL Server</span><br><span class="line"> 5.5\bin）找到“MySQLInstanceConfig.exe”打开“MySQL Instance Configuration Wizard”向导。</span><br></pre></td></tr></table></figure><h3 id="3、MySQL的配置"><a href="#3、MySQL的配置" class="headerlink" title="3、MySQL的配置"></a>3、MySQL的配置</h3><h4 id="（1）准备开始"><a href="#（1）准备开始" class="headerlink" title="（1）准备开始"></a>（1）准备开始</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095522.png" alt></p><h4 id="（2）选择配置类型"><a href="#（2）选择配置类型" class="headerlink" title="（2）选择配置类型"></a>（2）选择配置类型</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095606.png" alt></p><p>选择配置方式，“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，我们选择“Detailed Configuration”，方便熟悉配置过程。  </p><h4 id="（3）选择MySQL的应用模式"><a href="#（3）选择MySQL的应用模式" class="headerlink" title="（3）选择MySQL的应用模式"></a>（3）选择MySQL的应用模式</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095652.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Develop Machine（开发机），使用最小数量的内存</span><br><span class="line">Server Machine（服务器），使用中等大小的内存</span><br><span class="line">Dedicated MySQL Server Machine（专用服务器），使用当前可用的最大内存。</span><br></pre></td></tr></table></figure><h4 id="（4）选择数据库用途选择界面"><a href="#（4）选择数据库用途选择界面" class="headerlink" title="（4）选择数据库用途选择界面"></a>（4）选择数据库用途选择界面</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095746.png" alt></p><p>选择mysql数据库的大致用途：</p><ul><li>“Multifunctional Database（通用多功能型，好）”：此选项对事务性存储引擎（InnoDB）和非事务性（MyISAM）存储引擎的存取速度都很快。</li><li>“Transactional Database Only（服务器类型，专注于事务处理，一般）”：此选项主要优化了事务性存储引擎（InnoDB），但是非事务性（MyISAM）存储引擎也能用。</li><li>“Non-Transactional Database Only（非事务处理型，较简单）主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional，注意事务性存储引擎（InnoDB）不能用。</li></ul><h4 id="（5）配置InnoDB数据文件目录"><a href="#（5）配置InnoDB数据文件目录" class="headerlink" title="（5）配置InnoDB数据文件目录"></a>（5）配置InnoDB数据文件目录</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095842.png" alt></p><p>InnoDB的数据文件会在数据库第一次启动的时候创建，默认会创建在MySQL的安装目录下。用户可以根据实际的空间状况进行路径的选择。  </p><h4 id="（6）并发连接设置"><a href="#（6）并发连接设置" class="headerlink" title="（6）并发连接设置"></a>（6）并发连接设置</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095951.png" alt></p><p>选择您的网站的一般mysql 访问量，同时连接的数目，“Decision Support(DSS)/OLAP（决策支持系统，20个左右）”、“Online Transaction Processing(OLTP)（在线事务系统，500个左右）”、“Manual Setting（手动设置，自己输一个数）”  </p><h4 id="（7）网络选项设置"><a href="#（7）网络选项设置" class="headerlink" title="（7）网络选项设置"></a>（7）网络选项设置</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100049.png" alt></p><ul><li>是否启用TCP/IP连接，设定端口，如果不启用，就只能在自己的机器上访问mysql 数据库了，我这里启用，把前面的勾打上，Port Number：3306，还有一个关于防火墙的设置“Add firewall exception ……”需要选中，将MYSQL服务的监听端口加为windows防火墙例外，避免防火墙阻断。</li><li>在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性。  </li></ul><h4 id="（8）选择字符集"><a href="#（8）选择字符集" class="headerlink" title="（8）选择字符集"></a>（8）选择字符集</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100129.png" alt></p><ul><li>注意：<ul><li>如果要用原来数据库的数据，最好能确定原来数据库用的是什么编码，如果这里设置的编码和原来数据库数据的编码不一致，在使用的时候可能会出现乱码。</li><li>这个比较重要，就是对mysql默认数据库语言编码进行设置，第一个是西文编码，第二个是多字节的通用utf8编码，第三个，手工选择字符集。</li></ul></li><li>提示：<ul><li>如果安装时选择了字符集和“utf8”，通过命令行客户端来操作数据库时，有时候会出现乱码，</li><li>这是因为“命令行客户端”默认是GBK字符集，因此客户端与服务器端就出现了不一致的情况，会出现乱码。</li><li>可以在客户端执行：<br><code>mysql&gt; set names gbk;</code>  </li><li>可以通过以下命令查看：<br><code>mysql&gt; show variables like &#39;character_set_%&#39;;</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100326.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100345.png" alt></p><p>对于客户端和服务器的交互操作，MySQL提供了3个不同的参数：<br>character_set_client、character_set_connection、character_set_results，<br>分别代表客户端、连接和返回结果的字符集。<br>通常情况下，这3个字符集应该是相同的，才能确保用户写入的数据可以正确的读出和写入。<br>“set names xxx;”命令可以同时修改这3个参数的值，但是需要每次连接都重新设置。  </p><h4 id="（9）安全选择"><a href="#（9）安全选择" class="headerlink" title="（9）安全选择"></a>（9）安全选择</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100519.png" alt></p><p>选择是否将mysql 安装为windows服务，还可以指定Service Name（服务标识名称，例如我这里取名为“MySQL5.5”），是否将mysql的bin目录加入到Windows PATH环境变量中（加入后，就可以直接使用bin下的命令）”，我这里全部打上了勾。</p><h4 id="（10）设置密码"><a href="#（10）设置密码" class="headerlink" title="（10）设置密码"></a>（10）设置密码</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101625.png" alt></p><ul><li><p>这一步询问是否要修改默认root 用户（超级管理）的密码（默认为空），“New root password”如果要修改，就在此填入新密码，“Confirm（再输一遍）”内再填一次，防止输错。（如果是重装，并且之前已经设置了密码，在这里更改密码可能会出错，请留空，并将“Modify Security Settings”前面的勾去掉，安装配置完成后另行修改密码）</p></li><li><p>“Enable root access from remotemachines（是否允许root 用户在其它的机器或使用IP地址登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。如果没有勾选，默认只支持localhost和127.0.0.1连接。</p></li><li><p>最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询，如果要有操作数据的权限需要单独分配）”，一般就不用勾了</p><h4 id="（11）准备执行界面"><a href="#（11）准备执行界面" class="headerlink" title="（11）准备执行界面"></a>（11）准备执行界面</h4></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101704.png" alt></p><h4 id="（12）完成"><a href="#（12）完成" class="headerlink" title="（12）完成"></a>（12）完成</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101733.png" alt></p><h2 id="2-3-MySQL的安装目录"><a href="#2-3-MySQL的安装目录" class="headerlink" title="2.3 MySQL的安装目录"></a>2.3 MySQL的安装目录</h2><ul><li>bin目录中都是可执行文件；</li><li>my.ini文件是MySQL的配置文件；</li><li>MySQL的数据存储目录为data</li><li>data目录通常在C:\Documents and Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data位置。</li><li>在data下的每个目录都代表一个数据库。</li></ul><h2 id="2-4-MySQL环境变量的配置"><a href="#2-4-MySQL环境变量的配置" class="headerlink" title="2.4 MySQL环境变量的配置"></a>2.4 MySQL环境变量的配置</h2><p>将C:\Program Files (x86)\MySQL\MySQL Server 5.5\bin;添加到path中</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101847.png" alt></p><h1 id="第3章-MySQL的使用"><a href="#第3章-MySQL的使用" class="headerlink" title="第3章 MySQL的使用"></a>第3章 MySQL的使用</h1><h2 id="1、启动和停止服务"><a href="#1、启动和停止服务" class="headerlink" title="1、启动和停止服务"></a>1、启动和停止服务</h2><p>MySQL软件的服务器端必须先启动，客户端才可以连接和使用使用数据库。</p><h3 id="启动服务的方式："><a href="#启动服务的方式：" class="headerlink" title="启动服务的方式："></a>启动服务的方式：</h3><ul><li>方式一：图形化方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“我的电脑/计算机”--&gt;右键--&gt;“管理”--&gt;“服务”--&gt;启动和关闭MySQL</span><br><span class="line">“开始菜单”--&gt;“控制面板”--&gt;“管理工具”--&gt;“服务”--&gt;启动和关闭MySQL</span><br><span class="line">“任务管理器”--&gt;“服务”--&gt;启动和关闭MySQL</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605102748.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605102802.png" alt></p><ul><li>方式二：命令行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net  start  MySQL服务名</span><br><span class="line">net  stop  MySQL服务名</span><br></pre></td></tr></table></figure><h2 id="2、客户端登录"><a href="#2、客户端登录" class="headerlink" title="2、客户端登录"></a>2、客户端登录</h2><h3 id="方式一：MySQL自带客户端"><a href="#方式一：MySQL自带客户端" class="headerlink" title="方式一：MySQL自带客户端"></a>方式一：MySQL自带客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“开始菜单”--&gt;MySQL--&gt;MySQL Server 5.5 --&gt; MySQL 5.5 Command Line Client</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605102904.png" alt></p><p>仅限于root用户</p><h3 id="方式二：命令行"><a href="#方式二：命令行" class="headerlink" title="方式二：命令行"></a>方式二：命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 主机名 -P 端口号 -u 用户名 -p密码</span><br><span class="line">例如：mysql -h localhost -P 3306 -u root -proot</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格</span><br><span class="line">mysql -hlocalhost -P3306 -uroot -proot</span><br><span class="line">（2）密码建议在一行输入</span><br><span class="line">mysql -h localhost -P 3306 -u root -p</span><br><span class="line">Enter password:****</span><br><span class="line">（3）如果是连本机：-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略</span><br><span class="line">简写成：mysql -u root -p</span><br><span class="line">    Enter password:****</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103022.png" alt></p><p>连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。<br>也可以在命令行通过以下方式获取MySQL Server服务版本的信息</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103054.png" alt></p><p>或登录后，通过以下方式查看当前版本信息：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103116.png" alt></p><h3 id="方式三：可视化工具"><a href="#方式三：可视化工具" class="headerlink" title="方式三：可视化工具"></a>方式三：可视化工具</h3><p>例如：Navicat Preminum，SQLyogEnt等工具<br>还有其他工具：mysqlfront,phpMyAdmin</p><h4 id="（1）Navicat-Preminum"><a href="#（1）Navicat-Preminum" class="headerlink" title="（1）Navicat Preminum"></a>（1）Navicat Preminum</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103151.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103232.png" alt></p><h4 id="（2）SQLyog-江湖人称小海豚"><a href="#（2）SQLyog-江湖人称小海豚" class="headerlink" title="（2）SQLyog(江湖人称小海豚)"></a>（2）SQLyog(江湖人称小海豚)</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103343.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103416.png" alt></p><h2 id="3、MySQL的基本命令"><a href="#3、MySQL的基本命令" class="headerlink" title="3、MySQL的基本命令"></a>3、MySQL的基本命令</h2><h3 id="启动和关闭mysql服务"><a href="#启动和关闭mysql服务" class="headerlink" title="启动和关闭mysql服务"></a>启动和关闭mysql服务</h3><p>方式一：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动：net start mysql；  </span><br><span class="line">关闭：net stop mysql；</span><br></pre></td></tr></table></figure><p>方式二：<br><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103526.png" alt></p><p>在启动mysql服务后，打开windows任务管理器，会有一个名为mysqld.exe的进程运行，所以mysqld.exe才是MySQL服务器程序。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103603.png" alt></p><p>客户端登录退出mysql<br>在启动MySQL服务器后，我们需要使用管理员用户登录MySQL服务器，然后来对服务器进行操作。登录MySQL需要使用MySQL的客户端程序：mysql.exe  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">登录：mysql -u root -p root -h localhost；</span><br><span class="line">-u：后面的root是用户名，这里使用的是超级管理员root；</span><br><span class="line">-p：后面的root是密码，这是在安装MySQL时就已经指定的密码；</span><br><span class="line">-h：后面给出的localhost是服务器主机名，它是可以省略的，例如：mysql -u root -p root；</span><br><span class="line">退出：quit或exit；</span><br></pre></td></tr></table></figure><p>在登录成功后，打开windows任务管理器，会有一个名为mysql.exe的进程运行，所以mysql.exe是客户端程序。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103707.png" alt></p><h1 id="第4章-SQL语句"><a href="#第4章-SQL语句" class="headerlink" title="第4章 SQL语句"></a>第4章 SQL语句</h1><h2 id="4-1-SQL概述"><a href="#4-1-SQL概述" class="headerlink" title="4.1 SQL概述"></a>4.1 SQL概述</h2><h3 id="1-什么是SQL"><a href="#1-什么是SQL" class="headerlink" title="1. 什么是SQL"></a>1. 什么是SQL</h3><p>SQL（Structured Query Language）是“结构化查询语言”，它是对关系型数据库的操作语言。它可以应用到所有关系型数据库中，例如：MySQL、Oracle、SQL Server等。SQL标准有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1986年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86</span><br><span class="line">1989年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89</span><br><span class="line">1992年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2）</span><br><span class="line">1999年，ISO/IEC 9075:1999，SQL:1999（SQL3）</span><br><span class="line">2003年，ISO/IEC 9075:2003，SQL:2003</span><br><span class="line">2008年，ISO/IEC 9075:2008，SQL:2008</span><br><span class="line">2011年，ISO/IEC 9075:2011，SQL:2011</span><br><span class="line">2016年，ISO/IEC 9075:2016，SQL:2016</span><br></pre></td></tr></table></figure><ul><li>这些标准就与JDK的版本一样，在新的版本中总要有一些语法的变化。不同时期的数据库对不同标准做了实现。</li><li>虽然SQL可以用在所有关系型数据库中，但很多数据库还都有标准之后的一些语法，我们可以称之为“方言”。例如MySQL中的LIMIT语句就是MySQL独有的方言，其它数据库都不支持！当然，Oracle或SQL Server都有自己的方言。</li></ul><h3 id="2-SQL语法要求"><a href="#2-SQL语法要求" class="headerlink" title="2. SQL语法要求"></a>2. SQL语法要求</h3><ul><li>不区分大小写，建议关键字大写，表名和列名小写</li><li>每句命令的结尾使用分号</li><li>每句命令，根据需要可以换行，但关键字或表名、列名不可以拆开</li><li>可以用空格和缩进来来增强语句的可读性；</li></ul><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：-- 注释文字</span><br><span class="line">单行注释：#注释文字</span><br><span class="line">多行注释：/*注释文字*/</span><br></pre></td></tr></table></figure><h2 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDL（Data Definition Language）：</span><br><span class="line">    数据定义语言，用来定义数据库对象：库、表、列等；</span><br><span class="line">DML（Data Manipulation Language）：</span><br><span class="line">    数据操作语言，用来定义数据库记录（数据）；</span><br><span class="line">DCL（Data Control Language）：</span><br><span class="line">    数据控制语言，用来定义访问权限和安全级别；</span><br><span class="line">DQL（Data Query Language）：</span><br><span class="line">    数据查询语言，用来查询记录（数据）。</span><br></pre></td></tr></table></figure><h2 id="4-3-DDL"><a href="#4-3-DDL" class="headerlink" title="4.3 DDL"></a>4.3 DDL</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看所有数据库名称：SHOW DATABASES；　</span><br><span class="line">切换数据库：USE mydb1，切换到mydb1数据库；</span><br></pre></td></tr></table></figure><h3 id="2-操作数据库"><a href="#2-操作数据库" class="headerlink" title="2.操作数据库"></a>2.操作数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建数据库：CREATE DATABASE [IF NOT EXISTS] mydb1；</span><br></pre></td></tr></table></figure><p>创建数据库，例如：CREATE DATABASE mydb1，创建一个名为mydb1的数据库。如果这个数据已经存在，那么会报错。例如CREATE DATABASE IF NOT EXISTS mydb1，在名为mydb1的数据库不存在时创建该库，这样可以避免报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除数据库：DROP DATABASE [IF EXISTS] mydb1；</span><br></pre></td></tr></table></figure><p>删除数据库，例如：DROP DATABASE mydb1，删除名为mydb1的数据库。如果这个数据库不存在，那么会报错。DROP DATABASE IF EXISTS mydb1，就算mydb1不存在，也不会的报错。</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>MySQL与Java一样，也有数据类型。MySQL中数据类型主要应用在列上。</p><p>常用类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int：整型</span><br><span class="line">double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</span><br><span class="line">decimal：浮点型，在表示钱方面使用该类型，因为不会出现精度缺失问题；</span><br><span class="line">char：固定长度字符串类型；char(4) 范围是0-255</span><br><span class="line">varchar：可变长度字符串类型；</span><br><span class="line">text：字符串类型；</span><br><span class="line">blob：字节类型；//jpg mp3 avi</span><br><span class="line">date：日期类型，格式为：yyyy-MM-dd；</span><br><span class="line">time：时间类型，格式为：hh:mm:ss</span><br><span class="line">timestamp：时间戳类型；日期+时间 yyyyMMdd hhmmss</span><br></pre></td></tr></table></figure><h3 id="4-操作表"><a href="#4-操作表" class="headerlink" title="4.操作表"></a>4.操作表</h3><ul><li>创建表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">  字段名 字段类型 【字段约束】,</span><br><span class="line">  字段名 字段类型 【字段约束】,</span><br><span class="line">  ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stus(</span><br><span class="line">sid    CHAR(6),</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emps(</span><br><span class="line">eidCHAR(6),</span><br><span class="line">enameVARCHAR(50),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(6),</span><br><span class="line">birthdayDATE,</span><br><span class="line">hiredateDATE,</span><br><span class="line">salaryDECIMAL(7,2),</span><br><span class="line">resumeVARCHAR(1000)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>MYSQL基础语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">查看当前数据库中所有表名称：SHOW TABLES；　</span><br><span class="line">查看指定表的创建语句：SHOW CREATE TABLE  emps;</span><br><span class="line">查看表结构：DESC emps;</span><br><span class="line">删除表：DROP TABLE emps</span><br><span class="line">修改表结构:</span><br><span class="line">a)修改之添加列：给stus表添加classname列：</span><br><span class="line">ALTER TABLE stu ADD (classname varchar(100));</span><br><span class="line">b)修改之修改列类型：修改stu表的gender列类型为CHAR(2)：</span><br><span class="line">ALTER TABLE stus MODIFY gender CHAR(2);</span><br><span class="line">c)修改之修改列名：修改stu表的gender列名为sex：</span><br><span class="line">ALTER TABLE stus change gender sex CHAR(2);</span><br><span class="line">d)修改之删除列：删除stsu表的classname列：</span><br><span class="line">ALTER TABLE stus DROP classname;</span><br><span class="line">e)修改之修改表名称：修改stu表名称为student：</span><br><span class="line">ALTER TABLE stus RENAME TO student;</span><br></pre></td></tr></table></figure><h2 id="4-4-DML"><a href="#4-4-DML" class="headerlink" title="4.4 DML"></a>4.4 DML</h2><h3 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1.插入数据"></a>1.插入数据</h3><ul><li>语法1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2, …) VALUES(值1, 值2)</span><br></pre></td></tr></table></figure><p>例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stus(sid, sname,age,gender) VALUES(&apos;s_1001&apos;, &apos;zhangSan&apos;, 23, &apos;male&apos;);</span><br><span class="line">INSERT INTO stus(sid, sname) VALUES(&apos;s_1001&apos;, &apos;zhangSan&apos;);</span><br></pre></td></tr></table></figure></p><ul><li>语法2：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES(值1,值2,…)</span><br></pre></td></tr></table></figure><p>因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stus VALUES(&apos;s_1002&apos;, &apos;liSi&apos;, 32, &apos;female&apos;);</span><br></pre></td></tr></table></figure><p>注意：所有字符串数据必须使用单引号</p><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2.修改数据"></a>2.修改数据</h3><h4 id="单表修改语法："><a href="#单表修改语法：" class="headerlink" title="单表修改语法："></a>单表修改语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1=值1, … 列名n=值n [WHERE 条件]</span><br><span class="line">UPDATE stus SET sname=’zhangSanSan’, age=’32’, gender=’female’ WHERE sid=’s_1001’;</span><br><span class="line">UPDATE stus SET sname=’liSi’, age=’20’ WHERE age&gt;50 AND gender=’male’;</span><br><span class="line">UPDATE stus SET sname=’wangWu’, age=’30’ WHERE age&gt;60 OR gender=’female’;</span><br><span class="line">UPDATE stus SET gender=’female’ WHERE gender IS NULL</span><br><span class="line">UPDATE stus SET age=age+1 WHERE sname=’zhaoLiu’;</span><br></pre></td></tr></table></figure><h4 id="多表修改语法："><a href="#多表修改语法：" class="headerlink" title="多表修改语法："></a>多表修改语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表1 【inner】 john 表2 on 表 SET 列名1= 新值1,列名2 =新值2 【where 筛选条件】</span><br></pre></td></tr></table></figure><h3 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3.删除数据"></a>3.删除数据</h3><h4 id="单表删除语法："><a href="#单表删除语法：" class="headerlink" title="单表删除语法："></a>单表删除语法：</h4><p>①语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件]</span><br><span class="line"></span><br><span class="line">DELETE FROM stus WHERE sid=’s_1001’003B</span><br><span class="line">DELETE FROM stus WHERE sname=’chenQi’ OR age &gt; 30;</span><br><span class="line">DELETE FROM stus;</span><br></pre></td></tr></table></figure><p>②语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE stus;</span><br></pre></td></tr></table></figure><ul><li>虽然TRUNCATE和DELETE都可以删除表的所有记录，但有原理不同。DELETE的效率没有TRUNCATE高！<br>TRUNCATE其实属性DDL语句，因为它是先DROP TABLE，再CREATE TABLE。而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的.</li></ul><h2 id="4-5-DQL"><a href="#4-5-DQL" class="headerlink" title="4.5 DQL"></a>4.5 DQL</h2><p>DQL就是数据查询语言，数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">selection_list /*要查询的列名称*/</span><br><span class="line">FROM </span><br><span class="line">table_list /*要查询的表名称*/</span><br><span class="line">WHERE </span><br><span class="line">condition /*行条件*/</span><br><span class="line">GROUP BY </span><br><span class="line">grouping_columns /*对结果分组*/</span><br><span class="line">HAVING </span><br><span class="line">condition /*分组后的行条件*/</span><br><span class="line">ORDER BY</span><br><span class="line">sorting_columns /*对结果分组*/</span><br><span class="line">LIMIT </span><br><span class="line">offset_start, row_count /*结果限定*/</span><br></pre></td></tr></table></figure><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.1　查询常量</span><br><span class="line">1.2　查询表达式</span><br><span class="line">1.3  查询函数(方法)</span><br><span class="line">1.4  查询单个字段</span><br><span class="line">1.5  查询多个字段</span><br><span class="line">1.6  查询所有字段(两种方式)</span><br></pre></td></tr></table></figure><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><p>介绍<br>条件查询就是在查询时给出WHERE子句，在WHERE子句中可以使用如下运算符及关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</span><br><span class="line">AND、OR、NOT</span><br><span class="line">λBETWEEN…AND、IN(set)、IS NULL</span><br></pre></td></tr></table></figure><h3 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3.模糊查询"></a>3.模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Like</span><br><span class="line">like一般搭配通配符使用。</span><br><span class="line">常见的通配符：</span><br><span class="line">%：任意0个或多个字符</span><br><span class="line">_：任意单个字符</span><br></pre></td></tr></table></figure><p>当想查询姓名中包含a字母的员工时就需要使用模糊查询了。模糊查询需要使用关键字LIKE。  </p><ul><li>方式一：直接通过\进行转义</li><li>方式二：通过escape关键字指定转义字符</li></ul><ul><li>between and  </li></ul><p>特点：<br>①用于筛选某个字段或表达式是否在指定的区间范围<br>②等价于 使用逻辑表达式的效果，只是语法上更加简单<br>③两个区间值不能调换顺序  </p><ul><li>两个区间值包含</li></ul><blockquote><p>=左区间 and &lt;=右区间</p></blockquote><h3 id="4-字段控制查询"><a href="#4-字段控制查询" class="headerlink" title="4.字段控制查询"></a>4.字段控制查询</h3><h4 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h4><p>去除重复记录（两行或两行以上记录中系列的上的数据都相同），例如emp表中sal字段就存在相同的记录。当只查询emp表的sal字段时，那么会出现重复记录，那么想去除重复记录，需要使用DISTINCT：</p><h4 id="查看雇员的月薪与薪资之和-IFNULL函数"><a href="#查看雇员的月薪与薪资之和-IFNULL函数" class="headerlink" title="查看雇员的月薪与薪资之和(IFNULL函数)"></a>查看雇员的月薪与薪资之和(IFNULL函数)</h4><ul><li>因为salary和commission_pct两列的类型都是数值类型，所以可以做加运算。如果salary或commission_pct中有一个字段不是数值类型，那么会出错。</li><li>Commission_pct列有很多记录的值为NULL，因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。下面使用了把NULL转换成数值0的函数IFNULL：</li></ul><h4 id="给列名添加别名"><a href="#给列名添加别名" class="headerlink" title="给列名添加别名"></a>给列名添加别名</h4><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名 as 别名 from 表名;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名 别名  from 表名;</span><br></pre></td></tr></table></figure><h3 id="5-排序-order-by"><a href="#5-排序-order-by" class="headerlink" title="5.排序 order by"></a>5.排序 order by</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）按单个字段进行升序 ★</span><br><span class="line">案例1：按工资从低到高排序</span><br><span class="line">案例2：按工资从低到高排序</span><br><span class="line">2）.按多个字段排序</span><br><span class="line">案例1：部门编号&gt;50的按工资从高到低排序，如果一样，再按frist_name升序</span><br><span class="line">3）.按表达式排序</span><br><span class="line">案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">4）.按别名排序</span><br><span class="line">案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">5）.按函数排序</span><br><span class="line">案例：显示所有有奖金的员工姓名、奖金、姓名的长度，按姓名的长度从低到高排序</span><br></pre></td></tr></table></figure><h3 id="6-常见函数"><a href="#6-常见函数" class="headerlink" title="6.常见函数"></a>6.常见函数</h3><p>MySQL数据库提供了很多函数包括：</p><ul><li>数学函数；</li><li>字符串函数；</li><li>日期和时间函数；</li><li>条件判断函数；流程控制函数；</li><li>系统信息函数；</li><li>加密函数；</li><li>格式化函数；</li></ul><h4 id="1）、数学函数"><a href="#1）、数学函数" class="headerlink" title="1）、数学函数"></a>1）、数学函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ABS（x）        返回x的绝对值   </span><br><span class="line">CEIL（x）       返回大于x的最小整数值  </span><br><span class="line">FLOOR（x）      返回大于x的最大整数值</span><br><span class="line">MOD(x,y)        返回x/y的模</span><br><span class="line">RAND(x)         返回0~1的随机值</span><br><span class="line">ROUND(x,y)      返回参数x的四舍五入的有y位的小数的值</span><br><span class="line">TRUNCATE(x,y)   返回数字x截断为y位小数的结果</span><br><span class="line">SQRT(x)         返回x的平方根</span><br><span class="line">POW(x,y)        返回x的y次方</span><br></pre></td></tr></table></figure><h4 id="2）、字符串函数"><a href="#2）、字符串函数" class="headerlink" title="2）、字符串函数"></a>2）、字符串函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(S1,S2,......,Sn)</span><br><span class="line">    连接S1,S2,......,Sn为一个字符串</span><br><span class="line"></span><br><span class="line">CHAR_LENGTH(s)</span><br><span class="line">    返回字符串s的字符数</span><br><span class="line">    </span><br><span class="line">LENGTH(s)</span><br><span class="line">    返回字符串s的字节数，和字符集有关</span><br><span class="line"></span><br><span class="line">INSERT(str, index , len, instr)</span><br><span class="line">    将字符串str从第index位置开始，len个字符长的子串替换为字符串instr</span><br><span class="line">    </span><br><span class="line">UPPER(s) 或 UCASE(s)</span><br><span class="line">    将字符串s的所有字母转成大写字母</span><br><span class="line">    </span><br><span class="line">LOWER(s)  或LCASE(s)</span><br><span class="line">    将字符串s的所有字母转成小写字母</span><br><span class="line">    </span><br><span class="line">LPAD(str, len, pad)</span><br><span class="line">    用字符串pad对str最左边进行填充，直到str的长度为len个字符</span><br><span class="line">    </span><br><span class="line">RPAD(str ,len, pad)</span><br><span class="line">    用字符串pad对str最右边进行填充，直到str的长度为len个字符</span><br><span class="line">    </span><br><span class="line">TRIM(s)</span><br><span class="line">    去掉字符串s开始与结尾的空格</span><br><span class="line">    </span><br><span class="line">REPLACE（str, a, b）</span><br><span class="line">    用字符串b替换字符串str中所有出现的字符串a</span><br><span class="line">    </span><br><span class="line">SUBSTR(s,index,len)</span><br><span class="line">返回从字符串s的index位置其len个字符</span><br></pre></td></tr></table></figure><h4 id="3）、日期时间函数"><a href="#3）、日期时间函数" class="headerlink" title="3）、日期时间函数"></a>3）、日期时间函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CURDATE() 或 CURRENT_DATE()     返回当前日期</span><br><span class="line">CURTIME() 或 CURRENT_TIME()     返回当前时间</span><br><span class="line">NOW()</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">SYSDATE()               返回当前系统日期时间</span><br><span class="line">CURRENT_TIMESTAMP()</span><br><span class="line">LOCALTIME()</span><br><span class="line">LOCALTIMESTAMP()</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">YEAR(date)              返回具体的时间值</span><br><span class="line">MONTH(date)</span><br><span class="line">DAY(date)</span><br><span class="line">HOUR(time)</span><br><span class="line">MINUTE(time)</span><br><span class="line">SECOND(time)</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">WEEK(date)              返回一年中的第几周</span><br><span class="line">WEEKOFYEAR(date)</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">DAYOFWEEK()</span><br><span class="line">    返回周几，注意：周日是1，周一是2，。。。周六是7</span><br><span class="line"></span><br><span class="line">WEEKDAY(date)</span><br><span class="line">    返回周几，注意，周1是0，周2是1，。。。周日是6</span><br><span class="line"></span><br><span class="line">DAYNAME(date)</span><br><span class="line">    返回星期：MONDAY,TUESDAY.....SUNDAY</span><br><span class="line"></span><br><span class="line">MONTHNAME(date)</span><br><span class="line">    返回月份：January，。。。。。</span><br><span class="line"></span><br><span class="line">DATEDIFF(date1,date2)</span><br><span class="line">    返回date1 - date2的日期间隔</span><br><span class="line">    </span><br><span class="line">TIMEDIFF(time1, time2)</span><br><span class="line">    返回time1 - time2的时间间隔</span><br><span class="line"></span><br><span class="line">DATE_ADD(datetime, INTERVALE  expr  type)</span><br><span class="line">    返回与给定日期时间相差INTERVAL时间段的日期时间</span><br><span class="line"></span><br><span class="line">DATE_FORMAT(datetime ,fmt)</span><br><span class="line">    按照字符串fmt格式化日期datetime值</span><br><span class="line"></span><br><span class="line">STR_TO_DATE(str, fmt)</span><br><span class="line">    按照字符串fmt对str进行解析，解析为一个日期</span><br></pre></td></tr></table></figure><p>（1）DATE_ADD(datetime,INTERVAL  expr  type)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR);             #可以是负数</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL &apos;1_1&apos; YEAR_MONTH);    #需要单引号</span><br><span class="line">-------------------------------------</span><br><span class="line">表达式类型      YEAR_MONTH</span><br><span class="line">YEAR            DAY_HOUR</span><br><span class="line">MONTH           DAY_MINUTE</span><br><span class="line">DAY             DAY_SECOND</span><br><span class="line">HOUR            HOUR_MINUTE</span><br><span class="line">MINUTE          HOUR_SECOND</span><br><span class="line">SECOND          MINUTE_SECOND</span><br></pre></td></tr></table></figure><p>（2）DATE_FORMAT(datetime ,fmt)和STR_TO_DATE(str, fmt)</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605112616.png" alt></p><h4 id="4）、流程函数"><a href="#4）、流程函数" class="headerlink" title="4）、流程函数"></a>4）、流程函数</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605112741.png" alt></p><h3 id="7-聚合函数"><a href="#7-聚合函数" class="headerlink" title="7.聚合函数"></a>7.聚合函数</h3><h4 id="聚合函数是用来做纵向运算的函数："><a href="#聚合函数是用来做纵向运算的函数：" class="headerlink" title="聚合函数是用来做纵向运算的函数："></a>聚合函数是用来做纵向运算的函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COUNT()：统计指定列不为NULL的记录行数；</span><br><span class="line">MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</span><br><span class="line">MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</span><br><span class="line">SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</span><br><span class="line">AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</span><br></pre></td></tr></table></figure><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h4><ul><li>当需要纵向统计时可以使用COUNT()。<ul><li>查询employees表中记录数：</li><li>查询employees表中有奖金的人数：</li></ul></li></ul><p>注意，因为count()函数中给出的是commission_pct列，那么只统计comm列非NULL的行数。</p><p>当需要纵向求和时使用sum()函数。</p><h4 id="MAX和MIN"><a href="#MAX和MIN" class="headerlink" title="MAX和MIN"></a>MAX和MIN</h4><pre><code>- 查询最高工资和最低工资：</code></pre><h3 id="8-分组查询"><a href="#8-分组查询" class="headerlink" title="8.分组查询"></a>8.分组查询</h3><h4 id="8-1-group-by"><a href="#8-1-group-by" class="headerlink" title="8.1 group by"></a>8.1 group by</h4><p>当需要分组查询时需要使用GROUP BY子句，例如查询每个部门的平均工资，这说明要使用部分来分组。</p><h4 id="8-2-having"><a href="#8-2-having" class="headerlink" title="8.2 having"></a>8.2 having</h4><h3 id="9-连接查询"><a href="#9-连接查询" class="headerlink" title="9.连接查询"></a>9.连接查询</h3><p>概念：  </p><ul><li>连接查询就是求出多个表的乘积，例如t1连接t2，那么查询出的结果就是t1*t2。</li><li>连接查询会产生笛卡尔积，假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。可以扩展到多个集合的情况。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113223.png" alt></p><ul><li>那么多表查询产生这样的结果并不是我们想要的，那么怎么去除重复的，不想要的记录呢，当然是通过条件过滤。通常要查询的多个表之间都存在关联关系，那么就通过关联关系去除笛卡尔积。</li><li>你能想像到emp和dept表连接查询的结果么？employees一共107行记录，departments表一共27行记录，那么连接后查询出的结果是2889行记录。</li><li>Sql语句：SELECT * FROM employees,departments;</li><li>查询结果：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113341.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113358.png" alt></p><p>也就你只是想在查询employees表的同时，把每个员工的所在部门信息显示出来，那么就需要使用主外键来去除无用信息了。<br>Sql语句：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e,deptartments d WHERE e.department_id=d.deptartment_id ;</span><br></pre></td></tr></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113619.png" alt></p><p>上面查询结果会把两张表的所有列都查询出来，也许你不需要那么多列，这时就可以指定要查询的列了。<br>Sql语句：<br>SELECT employee_id,last_name,salary,commission_pct,department_name<br>FROM employees,deptartments<br>WHERE employees.department_id = departments.department_id;<br>查询结果：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113439.png" alt></p><p>给表指定别名的写法：<br>SELECT employee_id,last_name,salary,commission_pct,department_name<br>FROM employees e,deptartments d<br>WHERE e.department_id = d.department_id;</p><h4 id="9-1-内连接"><a href="#9-1-内连接" class="headerlink" title="9.1　内连接"></a>9.1　内连接</h4><p>上面的连接语句就是内连接，但它不是SQL标准中的查询方式，可以理解为方言！SQL标准的内连接为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e INNER JOIN departments d </span><br><span class="line">ON e.department_id=d.department_id;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>inner可以省略、on是连接条件</li><li>内连接的特点：查询结果必须满足条件。</li></ul><h4 id="9-2-外连接（左连接、右连接）"><a href="#9-2-外连接（左连接、右连接）" class="headerlink" title="9.2　外连接（左连接、右连接）"></a>9.2　外连接（左连接、右连接）</h4><p>外连接的特点：查询出的结果存在不满足条件的可能。</p><ul><li>左连接：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e LEFT OUTER JOIN departments d </span><br><span class="line">ON e.department_id=d.department_id;</span><br></pre></td></tr></table></figure><p>注意：OUTER可以省略<br>左连接是先查询出左表（即以左表为主），然后查询右表，右表中满足条件的显示出来，不满足条件的显示NULL。</p><ul><li>右连接<br>右连接就是先把右表中所有记录都查询出来，然后左表满足条件的显示，不满足显示NULL。例如在departments表中的120~270部门并不存在员工，但在右连接中，如果departments表为右表，那么还是会查出120~270部门的信息，但相应的员工信息为NULL。<br>代码如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e </span><br><span class="line">RIGHT OUTER JOIN departments d </span><br><span class="line">ON e.department_id=d.department_id;</span><br></pre></td></tr></table></figure><p>9.3　自连接（不太常用）</p><p>#案例：查询员工的姓名和工资以及领导姓名和工资</p><p>SELECT e.last_name,e.salary,m.last_name,m.salary<br>FROM employees e<br>JOIN employees m<br>ON e.<code>manager_id</code> = m.<code>employee_id</code>; </p><h3 id="10-子查询"><a href="#10-子查询" class="headerlink" title="10.子查询"></a>10.子查询</h3><p>概念：</p><ul><li>出现在其他语句的内部的select语句，称为子查询或内查询</li><li>里面嵌套其他select语句的查询语句，称为主查询或外查询</li></ul><p>分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行子查询</span><br><span class="line">特点：子查询的结果集只有一行一列</span><br><span class="line">多行子查询</span><br><span class="line">特点：子查询的结果集有多行一列</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、子查询语句需要放在小括号内，提高代码的阅读性  </span><br><span class="line">2、子查询先于主查询执行，一般来讲，主查询会用到子查询的结果  </span><br><span class="line">3、如果子查询放在条件中，一般来讲，子查询需要放在条件的右侧  </span><br><span class="line">示例：where job_id&gt;(子查询)  </span><br><span class="line">不能写成：where (子查询)&lt;job_id  </span><br><span class="line">4、 单行子查询对应的使用单行操作符：&gt; &lt; &gt;= &lt;= = &lt;&gt;    </span><br><span class="line">    多行子查询对应的使用多行操作符:in 、any 、all 、not in</span><br><span class="line">    </span><br><span class="line">LIMIT用来限定查询结果的起始行，以及总行数。</span><br></pre></td></tr></table></figure><h3 id="11-分页查询"><a href="#11-分页查询" class="headerlink" title="11.分页查询"></a>11.分页查询</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">limit 【起始条目索引,】查询的条目数;</span><br></pre></td></tr></table></figure><h1 id="第5章完整性约束"><a href="#第5章完整性约束" class="headerlink" title="第5章完整性约束"></a>第5章完整性约束</h1><p>　　完整性约束是为了表的数据的正确性！如果数据不正确，那么一开始就不能添加到表中。</p><h2 id="5-1主键"><a href="#5-1主键" class="headerlink" title="5.1主键"></a>5.1主键</h2><p>当某一列添加了主键约束后，那么这一列的数据就不能重复出现。这样每行记录中其主键列的值就是这一行的唯一标识。例如学生的学号可以用来做唯一标识，而学生的姓名是不能做唯一标识的，因为学习有可能同名。<br>主键列的值不能为NULL，也不能重复！<br>　指定主键约束使用PRIMARY KEY关键字</p><ul><li>创建表：定义列时指定主键：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">sid    CHAR(6) PRIMARY KEY,</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建表：定义列之后独立指定主键：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">sid    CHAR(6),</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10),</span><br><span class="line">PRIMARY KEY(sid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>修改表时指定主键：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD PRIMARY KEY(sid);</span><br></pre></td></tr></table></figure><ul><li>删除主键（只是删除主键约束，而不会删除主键列）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><h2 id="5-2主键自增长"><a href="#5-2主键自增长" class="headerlink" title="5.2主键自增长"></a>5.2主键自增长</h2><p>MySQL提供了主键自动增长的功能！这样用户就不用再为是否有主键是否重复而烦恼了。当主键设置为自动增长后，在没有给出主键值时，主键的值会自动生成，而且是最大主键值+1，也就不会出现重复主键的可能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 创建表时设置主键自增长（主键必须是整型才可以自增长）：</span><br><span class="line">CREATE TABLE stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">- 修改表时设置主键自增长：</span><br><span class="line">ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line">- 修改表时删除主键自增长：</span><br><span class="line">ALTER TABLE stu CHANGE sid sid INT;</span><br></pre></td></tr></table></figure><h2 id="5-3非空"><a href="#5-3非空" class="headerlink" title="5.3非空"></a>5.3非空</h2><p>指定非空约束的列不能没有值，也就是说在插入记录时，对添加了非空约束的列一定要给值；在修改记录时，不能把非空列的值设置为NULL。</p><ul><li>指定非空约束：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(10) NOT NULL,</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当为sname字段指定为非空后，在向stu表中插入记录时，必须给sname字段指定值，否则会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu(sid) VALUES(1);</span><br></pre></td></tr></table></figure><p>插入的记录中sname没有指定值，所以会报错！</p><h2 id="5-4唯一"><a href="#5-4唯一" class="headerlink" title="5.4唯一"></a>5.4唯一</h2><p>还可以为字段指定唯一约束！当为字段指定唯一约束后，那么字段的值必须是唯一的。这一点与主键相似！例如给stu表的sname字段指定唯一约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tab_ab(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(10) UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">　　INSERT INTO sname(sid, sname) VALUES(1001, &apos;zs&apos;);</span><br><span class="line">INSERT INTO sname(sid, sname) VALUES(1002, &apos;zs&apos;);</span><br></pre></td></tr></table></figure><p>　　当两次插入相同的名字时，MySQL会报错！</p><h2 id="5-5外键"><a href="#5-5外键" class="headerlink" title="5.5外键"></a>5.5外键</h2><p>主外键是构成表与表关联的唯一途径！<br>外键是另一张表的主键！例如员工表与部门表之间就存在关联关系，其中员工表中的部门编号字段就是外键，是相对部门表的外键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- 创建dept表，指定deptno为主键列：</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">deptnoINT PRIMARY KEY,</span><br><span class="line">dnamevarchar(14),</span><br><span class="line">locvarchar(13)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">- 创建t_section表，指定sid为主键列，</span><br><span class="line">    u_id为相对t_user表的uid列的外键：</span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">empnoINT,</span><br><span class="line">enameVARCHAR(50),</span><br><span class="line">jobVARCHAR(50),</span><br><span class="line">mgrINT,</span><br><span class="line">hiredateDATE,</span><br><span class="line">salDECIMAL(7,2),</span><br><span class="line">commdecimal(7,2),</span><br><span class="line">deptnoINT,</span><br><span class="line">CONSTRAINT fk_e_d FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="第6章-事务"><a href="#第6章-事务" class="headerlink" title="第6章 事务"></a>第6章 事务</h1><pre><code>事务属于TCL控制语言（Transaction Control Language ）。</code></pre><h2 id="6-1事务概述"><a href="#6-1事务概述" class="headerlink" title="6.1事务概述"></a>6.1事务概述</h2><ul><li>什么是事务？为什么要用事务？<ul><li>一个事务是由一条或者多条sql语句构成，这一条或者多条sql语句要么全部执行成功，要么全部执行失败！</li><li>默认情况下，每条单独的sql语句就是一个单独的事务！</li></ul></li></ul><p>举例：<br>银行转账！张三转10000块到李四的账户，这其实需要两条SQL语句：</p><ul><li>给张三的账户减去10000元；</li><li>给李四的账户加上10000元。</li></ul><blockquote><ul><li>如果在第一条SQL语句执行成功后，在执行第二条SQL语句之前，程序被中断了（可能是抛出了某个异常，也可能是其他什么原因），那么李四的账户没有加上10000元，而张三却减去了10000元。这肯定是不行的！</li><li>你现在可能已经知道什么是事务了吧！事务中的多个操作，要么完全成功，要么完全失败！不可能存在成功一半的情况！也就是说给张三的账户减去10000元如果成功了，那么给李四的账户加上10000元的操作也必须是成功的；否则给张三减去10000元，以及给李四加上10000元都是失败的！</li></ul></blockquote><h2 id="6-2事务的四大特性（ACID）"><a href="#6-2事务的四大特性（ACID）" class="headerlink" title="6.2事务的四大特性（ACID）"></a>6.2事务的四大特性（ACID）</h2><ul><li>原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。</li><li>一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。</li><li>隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。</li><li>持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。</li></ul><h2 id="6-3-MySql中的事务"><a href="#6-3-MySql中的事务" class="headerlink" title="6.3 MySql中的事务"></a>6.3 MySql中的事务</h2><p>在默认情况下，MySQL每执行一条SQL语句，都是一个单独的事务。如果需要在一个事务中包含多条SQL语句，那么需要开启事务和结束事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启事务：start transaction；</span><br><span class="line">结束事务：commit或rollback。</span><br></pre></td></tr></table></figure><p>在执行SQL语句之前，先执行strat transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所做出的影响会持久化到数据库中。或者rollback，表示回滚，即回滚到事务的起点，之前做的所有操作都被撤消了！<br>演示事务  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建事务要用到的表</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(30),</span><br><span class="line">balance NUMERIC(10.2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO account(NAME,balance) VALUES(&apos;fanbingbing&apos;, 100000);</span><br><span class="line">INSERT INTO account(NAME,balance) VALUES(&apos;lichen&apos;, 100000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure><p>演示事务执行失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">案例一：回滚 事务执行失败！</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance=balance-10000 WHERE id=1;</span><br><span class="line">UPDATE account SET balance=balance+10000 WHERE id=2;</span><br><span class="line">ROLLBACK;</span><br><span class="line">案例二：退出mysql客户端 事务执行失败！</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance=balance-10000 WHERE id=1;</span><br><span class="line">UPDATE account SET balance=balance+10000 WHERE id=2;</span><br></pre></td></tr></table></figure></p><p>演示事务执行成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance=balance-10000 WHERE id=1;</span><br><span class="line">UPDATE account SET balance=balance+10000 WHERE id=2;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySql数据库&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随便打开一个Web网站，比如淘宝：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubu
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java SQL&amp;JDBC" scheme="http://yoursite.com/tags/Java-SQL-JDBC/"/>
    
      <category term="开发环境配置" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>16. JavaSE-网络编程</title>
    <link href="http://yoursite.com/2017/02/26/16.%20JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/26/16. JavaSE-网络编程/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2019-06-04T03:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="16-1-网络编程概述"><a href="#16-1-网络编程概述" class="headerlink" title="16.1 网络编程概述"></a>16.1 网络编程概述</h1><h2 id="16-1-1-网络编程概述"><a href="#16-1-1-网络编程概述" class="headerlink" title="16.1.1 网络编程概述"></a>16.1.1 网络编程概述</h2><p>•    Java是 Internet   上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。<br>•    Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java   实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。  </p><h2 id="16-1-2-网络基础"><a href="#16-1-2-网络基础" class="headerlink" title="16.1.2 网络基础"></a>16.1.2 网络基础</h2><ul><li>计算机网络：  <ul><li>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</li></ul></li></ul><ul><li>网络编程的目的：  <ul><li>直接或间接地通过网络协议与其它计算机进行通讯。</li></ul></li></ul><ul><li>网络编程中有两个主要的问题：<ul><li>如何准确地定位网络上一台或多台主机</li><li>找到主机后如何可靠高效地进行数据传输</li></ul></li></ul><p>地球村</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162248.png" alt></p><h1 id="16-2-网络通信要素"><a href="#16-2-网络通信要素" class="headerlink" title="16.2 网络通信要素"></a>16.2 网络通信要素</h1><p>如何实现网络中的主机互相通信：</p><ul><li>通信双方地址 </li><li>一定的规则（有两套参考模型）<ul><li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li><li>TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162351.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162435.png" alt></p><h1 id="16-3-InetAddress类"><a href="#16-3-InetAddress类" class="headerlink" title="16.3 InetAddress类"></a>16.3 InetAddress类</h1><h2 id="16-3-1通讯要素1：IP-和-端口号"><a href="#16-3-1通讯要素1：IP-和-端口号" class="headerlink" title="16.3.1通讯要素1：IP 和 端口号"></a>16.3.1通讯要素1：IP 和 端口号</h2><p>IP 地址：InetAddress</p><ul><li>唯一的标识 Internet 上的计算机</li><li>本地回环地址(hostAddress)：127.0.0.1      主机名(hostName)：localhost</li><li>不易记忆</li><li>端口号标识正在计算机上运行的进程（程序）<ul><li>不同的进程有不同的端口号</li><li>被规定为一个 16 位的整数 0~65535。其中，0~1023被预先定义的服务通信占用（如http占用端口80，Tomcat占用端口8080，MySql占用端口3306,Oracle占用端口1521等）。除非我们需要访问这些特定服务，否则，就应该使用 1024~65535 这些端口中的某一个进行通信，以免发生端口冲突。 </li></ul></li></ul><ul><li>端口号与IP地址的组合得出一个网络套接字：Socket。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162542.png" alt></p><h2 id="16-3-2-InetAddress类"><a href="#16-3-2-InetAddress类" class="headerlink" title="16.3.2 InetAddress类"></a>16.3.2 InetAddress类</h2><ul><li>Internet上的主机有两种方式表示地址：<ul><li>域名(hostName)：<a href="http://www.soc.pub" target="_blank" rel="noopener">www.soc.pub</a></li><li>IP 地址(hostAddress)：202.108.35.210</li></ul></li></ul><ul><li><p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。</p></li><li><p>InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址：<a href="http://www.atguigu.com" target="_blank" rel="noopener">www.atguigu.com</a> 和 202.108.35.210。</p></li><li><p>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地址，这样才能和主机建立连接。 ——-域名解析</p></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162706.png" alt></p><ul><li>InetAddress类没有提供公共的构造器，而是提供了如下两个静态方法来获取InetAddress实例</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162827.png" alt></p><ul><li>InetAddress提供了如下几个常用的方法</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162859.png" alt></p><h2 id="16-3-2-InetAddress类代码实例"><a href="#16-3-2-InetAddress类代码实例" class="headerlink" title="16.3.2 InetAddress类代码实例"></a>16.3.2 InetAddress类代码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(&quot;www.atguigu.com&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(address);</span><br><span class="line">//获取InetAddress 对象所含的域名</span><br><span class="line">System.out.println(address.getHostName());</span><br><span class="line">//获取InetAddress 对象所含的IP地址</span><br><span class="line">System.out.println(address.getHostAddress());</span><br><span class="line"></span><br><span class="line">//获取本机的域名和IP地址</span><br><span class="line">InetAddress address2 = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(address2);</span><br></pre></td></tr></table></figure><h1 id="16-4-TCP网络通信"><a href="#16-4-TCP网络通信" class="headerlink" title="16.4 TCP网络通信"></a>16.4 TCP网络通信</h1><h2 id="16-4-1-通讯要素2：网络通信协议"><a href="#16-4-1-通讯要素2：网络通信协议" class="headerlink" title="16.4.1 通讯要素2：网络通信协议"></a>16.4.1 通讯要素2：网络通信协议</h2><p>网络通信协议  </p><ul><li>计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。</li></ul><p>通信协议分层的思想</p><ul><li>由于结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</li></ul><h2 id="16-4-2-TCP-IP协议簇"><a href="#16-4-2-TCP-IP协议簇" class="headerlink" title="16.4.2 TCP/IP协议簇"></a>16.4.2 TCP/IP协议簇</h2><ul><li>传输层协议中有两个非常重要的协议：<ul><li>传输控制协议TCP(Transmission Control Protocol)</li><li>用户数据报协议UDP(User Datagram Protocol)。</li></ul></li></ul><ul><li>TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。</li><li>IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。</li><li>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层。</li></ul><h2 id="16-4-3-TCP-和-UDP"><a href="#16-4-3-TCP-和-UDP" class="headerlink" title="16.4.3 TCP 和 UDP"></a>16.4.3 TCP 和 UDP</h2><p>TCP协议：</p><ul><li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li><li>传输前，采用“三次握手”方式，是可靠的</li><li>TCP协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输</li><li>传输完毕，需释放已建立的连接，效率低</li></ul><p>UDP协议：</p><ul><li>将数据、源、目的封装成数据包，不需要建立连接</li><li>每个数据报的大小限制在64K内</li><li>因无需连接，故是不可靠的</li><li>发送数据结束时无需释放资源，速度快</li></ul><h2 id="16-4-4-Socket"><a href="#16-4-4-Socket" class="headerlink" title="16.4.4 Socket"></a>16.4.4 Socket</h2><ul><li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。</li><li>通信的两端都要有Socket，是两台机器间通信的端点</li><li>网络通信其实就是Socket间的通信。</li><li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li></ul><h2 id="16-4-5-基于Socket的TCP编程"><a href="#16-4-5-基于Socket的TCP编程" class="headerlink" title="16.4.5 基于Socket的TCP编程"></a>16.4.5 基于Socket的TCP编程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603163320.png" alt></p><h2 id="16-4-6-Socket类的常用方法"><a href="#16-4-6-Socket类的常用方法" class="headerlink" title="16.4.6 Socket类的常用方法"></a>16.4.6 Socket类的常用方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603163339.png" alt></p><h2 id="16-4-7-ServerSocket类的常用方法"><a href="#16-4-7-ServerSocket类的常用方法" class="headerlink" title="16.4.7 ServerSocket类的常用方法"></a>16.4.7 ServerSocket类的常用方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603163401.png" alt></p><h2 id="16-4-8-基于Socket的TCP编程"><a href="#16-4-8-基于Socket的TCP编程" class="headerlink" title="16.4.8 基于Socket的TCP编程"></a>16.4.8 基于Socket的TCP编程</h2><p>客户端Socket的工作过程包含以下四个基本的步骤：</p><ul><li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket 的输入/出流： 使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输</li><li>按照一定的协议对 Socket  进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。</li><li>关闭 Socket：断开客户端到服务器的连接，释放线路 </li></ul><h2 id="4-8-1-客户端创建Socket对象"><a href="#4-8-1-客户端创建Socket对象" class="headerlink" title="4.8.1 客户端创建Socket对象"></a>4.8.1 客户端创建Socket对象</h2><p>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造方法是：</p><ul><li>Socket(String host,int port)throws UnknownHostException,IOException：向服务器(域名是host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li><li>Socket(InetAddress address,int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接。</li></ul><p>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Socket s = new Socket(“192.168.40.165”,9999);</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line">out.write(“hello”.getBytes());</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure><h2 id="4-8-2服务器程序的工作过程包含以下四个基本的步骤："><a href="#4-8-2服务器程序的工作过程包含以下四个基本的步骤：" class="headerlink" title="4.8.2服务器程序的工作过程包含以下四个基本的步骤："></a>4.8.2服务器程序的工作过程包含以下四个基本的步骤：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">调用 ServerSocket(int port) ：</span><br><span class="line">    创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</span><br><span class="line"></span><br><span class="line">调用 accept()：</span><br><span class="line">    监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</span><br><span class="line"></span><br><span class="line">调用 该Socket类对象的 getOutputStream() 和 getInputStream ()：</span><br><span class="line">    获取输出流和输入流，开始网络数据的发送和接收。</span><br><span class="line"></span><br><span class="line">关闭ServerSocket和Socket对象：</span><br><span class="line">    客户端访问结束，关闭通信套接字。</span><br></pre></td></tr></table></figure><h2 id="4-8-3服务器建立-ServerSocket-对象"><a href="#4-8-3服务器建立-ServerSocket-对象" class="headerlink" title="4.8.3服务器建立 ServerSocket 对象"></a>4.8.3服务器建立 ServerSocket 对象</h2><ul><li>ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的ServerSocket对象。</li><li>所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = new ServerSocket(9999);</span><br><span class="line">Socket s = ss.accept ();</span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line">byte[] buf = new byte[1024];</span><br><span class="line">int num = in.read(buf);</span><br><span class="line">String str = new String(buf,0,num);</span><br><span class="line">System.out.println(s.getInetAddress().toString()+”:”+str);</span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure><h1 id="16-5-UDP网络通信"><a href="#16-5-UDP网络通信" class="headerlink" title="16.5 UDP网络通信"></a>16.5 UDP网络通信</h1><h2 id="16-5-1-UDP网络通信"><a href="#16-5-1-UDP网络通信" class="headerlink" title="16.5.1 UDP网络通信"></a>16.5.1 UDP网络通信</h2><ul><li>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</li><li>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li><li>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li><li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li></ul><h2 id="16-5-2-流程"><a href="#16-5-2-流程" class="headerlink" title="16.5.2 流程"></a>16.5.2 流程</h2><p>流  程：</p><ol><li>DatagramSocket与DatagramPacket  </li><li>建立发送端，接收端  </li><li>建立数据包  </li><li>调用Socket的发送、接收方法  </li><li>关闭Socket  </li></ol><ul><li>发送端与接收端是两个独立的运行程序</li></ul><h2 id="16-5-3-发送端"><a href="#16-5-3-发送端" class="headerlink" title="16.5.3 发送端"></a>16.5.3 发送端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket();</span><br><span class="line">byte[] by = “hello,atguigu.com”.getBytes();</span><br><span class="line">DatagramPacket dp = new DatagramPacket(by,0,by.length,</span><br><span class="line">InetAddress.getByName(“127.0.0.1”),10000);</span><br><span class="line">ds.send(dp);</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><h2 id="16-5-4-接收端"><a href="#16-5-4-接收端" class="headerlink" title="16.5.4 接收端"></a>16.5.4 接收端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在接收端，要指定监听的端口。</span><br><span class="line">DatagramSocket ds = new DatagramSocket(10000);</span><br><span class="line">byte[] by = new byte[1024];</span><br><span class="line">DatagramPacket dp = new DatagramPacket(by,by.length);</span><br><span class="line">ds.receive(dp);</span><br><span class="line">String str = new String(dp.getData(),0,dp.getLength());</span><br><span class="line">System.out.println(str+&quot;--&quot;+dp.getAddress());</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><h1 id="16-6-URL编程"><a href="#16-6-URL编程" class="headerlink" title="16.6 URL编程"></a>16.6 URL编程</h1><h2 id="16-6-1-简介"><a href="#16-6-1-简介" class="headerlink" title="16.6.1 简介"></a>16.6.1 简介</h2><ul><li>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 </li><li>URL的基本结构由5部分组成：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;</span><br><span class="line">例如: http://192.168.1.100:8080/helloworld/index.jsp</span><br></pre></td></tr></table></figure><ul><li>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public URL (String spec)：</span><br><span class="line">通过一个表示URL地址的字符串可以构造一个URL对象。</span><br><span class="line">例如：URL url = new URL (&quot;http://www. atguigu.com/&quot;); </span><br><span class="line"></span><br><span class="line">public URL(URL context, String spec)：</span><br><span class="line">通过基 URL 和相对 URL 构造一个 URL 对象。</span><br><span class="line">例如：URL downloadUrl = new URL(url, “download.html&quot;)</span><br><span class="line"></span><br><span class="line">public URL(String protocol, String host, String file); </span><br><span class="line">例如：new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, “download. html&quot;);</span><br><span class="line"></span><br><span class="line">public URL(String protocol, String host, int port, String file); </span><br><span class="line">例如: URL gamelan = new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, 80, “download.html&quot;);</span><br></pre></td></tr></table></figure><ul><li>类URL的构造方法都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。</li><li>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getProtocol(  )        获取该URL的协议名</span><br><span class="line">public String getHost(  )            获取该URL的主机名</span><br><span class="line">public String getPort(  )            获取该URL的端口号</span><br><span class="line">public String getPath(  )            获取该URL的文件路径</span><br><span class="line">public String getFile(  )             获取该URL的文件名</span><br><span class="line">public String getQuery(   )          获取该URL的查询名</span><br></pre></td></tr></table></figure><h2 id="16-6-2-代码"><a href="#16-6-2-代码" class="headerlink" title="16.6.2 代码"></a>16.6.2 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://localhost:8080/examples/myTest.txt&quot;);</span><br><span class="line">System.out.println(&quot;getProtocol() :&quot;+url.getProtocol());</span><br><span class="line">System.out.println(&quot;getHost() :&quot;+url.getHost());</span><br><span class="line">System.out.println(&quot;getPort() :&quot;+url.getPort());</span><br><span class="line">System.out.println(&quot;getPath() :&quot;+url.getPath());</span><br><span class="line">System.out.println(&quot;getFile() :&quot;+url.getFile());</span><br><span class="line">System.out.println(&quot;getQuery() :&quot;+url.getQuery());</span><br></pre></td></tr></table></figure><h2 id="16-6-3-针对HTTP协议的URLConnection类"><a href="#16-6-3-针对HTTP协议的URLConnection类" class="headerlink" title="16.6.3 针对HTTP协议的URLConnection类"></a>16.6.3 针对HTTP协议的URLConnection类</h2><ul><li>URL的方法 openStream()：能从网络上读取数据</li><li>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</li><li>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL netchinaren = new URL (&quot;http://www.atguigu.com/index.shtml&quot;); </span><br><span class="line">URLConnectonn u = netchinaren.openConnection( );</span><br></pre></td></tr></table></figure><ul><li>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object getContent( ) throws IOException</span><br><span class="line">public int getContentLength( )</span><br><span class="line">public String getContentType( )</span><br><span class="line">public long getDate( )</span><br><span class="line">public long getLastModified( )</span><br><span class="line">public InputStream getInputStream( )throws IOException</span><br><span class="line">public OutputSteram getOutputStream( )throws IOException</span><br></pre></td></tr></table></figure><h2 id="16-6-4-小结"><a href="#16-6-4-小结" class="headerlink" title="16.6.4 小结"></a>16.6.4 小结</h2><ul><li>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</li><li>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。</li><li>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</li><li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。</li><li>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * T代表JavaBean类型</span><br><span class="line"> * P代表主键类型</span><br><span class="line"> */</span><br><span class="line">interface DAO&lt;T,P&gt;&#123;</span><br><span class="line">boolean add(T t);</span><br><span class="line">boolean deleteById(P id);</span><br><span class="line">boolean update(T t);</span><br><span class="line">T findById(P id);</span><br><span class="line">List&lt;T&gt; getAll();</span><br><span class="line">int getCount();</span><br><span class="line">&#125;</span><br><span class="line">class UserDAOImpl implements DAO&lt;User,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean add(User t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean deleteById(String id) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean update(User t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public User findById(String id) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;User&gt; getAll() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class GoodsDAOImpl implements DAO&lt;Goods,Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean add(Goods t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean deleteById(Integer id) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean update(Goods t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Goods findById(Integer id) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;Goods&gt; getAll() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class User&#123;</span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line">public String getUsername() &#123;</span><br><span class="line">return username;</span><br><span class="line">&#125;</span><br><span class="line">public void setUsername(String username) &#123;</span><br><span class="line">this.username = username;</span><br><span class="line">&#125;</span><br><span class="line">public String getPassword() &#123;</span><br><span class="line">return password;</span><br><span class="line">&#125;</span><br><span class="line">public void setPassword(String password) &#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Goods&#123;</span><br><span class="line">private int gid;</span><br><span class="line">private String name;</span><br><span class="line">public int getGid() &#123;</span><br><span class="line">return gid;</span><br><span class="line">&#125;</span><br><span class="line">public void setGid(int gid) &#123;</span><br><span class="line">this.gid = gid;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、编写程序，在main方法中接收5个参数整数字符串；  </p><ul><li>创建TreeSet类型的集合（使用泛型），将5个字符串以整数形式添加到集合中；<br>增强型for循环遍历该集合，打印所有元素，并将所有元素之和打印出来。</li></ul><p>6、编写代码，存储丈夫与妻子，Map&lt;丈夫,妻子&gt;，并遍历输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;16-1-网络编程概述&quot;&gt;&lt;a href=&quot;#16-1-网络编程概述&quot; class=&quot;headerlink&quot; title=&quot;16.1 网络编程概述&quot;&gt;&lt;/a&gt;16.1 网络编程概述&lt;/h1&gt;&lt;h2 id=&quot;16-1-1-网络编程概述&quot;&gt;&lt;a href=&quot;#16-1
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>15. JavaSE-多线程</title>
    <link href="http://yoursite.com/2017/02/19/15.%20JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/19/15. JavaSE-多线程/</id>
    <published>2017-02-18T16:00:00.000Z</published>
    <updated>2019-06-04T01:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="15-1-程序、进程、线程的概念"><a href="#15-1-程序、进程、线程的概念" class="headerlink" title="15.1 程序、进程、线程的概念"></a>15.1 程序、进程、线程的概念</h1><ul><li>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</li><li><p>进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。</p><ul><li>如：运行中的QQ，运行中的MP3播放器</li><li>程序是静态的，进程是动态的</li></ul></li><li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p><ul><li>若一个程序可同一时间执行多个线程，就是支持多线程的</li></ul></li></ul><h2 id="15-1-1-进程与多线程"><a href="#15-1-1-进程与多线程" class="headerlink" title="15.1.1 进程与多线程"></a>15.1.1 进程与多线程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154431.png" alt></p><h2 id="15-1-2-何时需要多线程"><a href="#15-1-2-何时需要多线程" class="headerlink" title="15.1.2 何时需要多线程"></a>15.1.2 何时需要多线程</h2><ul><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li><li>需要一些后台运行的程序时。</li></ul><h1 id="15-2-Java中多线程的创建和使用"><a href="#15-2-Java中多线程的创建和使用" class="headerlink" title="15.2 Java中多线程的创建和使用"></a>15.2 Java中多线程的创建和使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">public void method1(String str)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">public void method2(String str)&#123;</span><br><span class="line">method1(str);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Sample  s = new Sample();</span><br><span class="line">s.method2(&quot;hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-2-1-多线程的创建和启动"><a href="#15-2-1-多线程的创建和启动" class="headerlink" title="15.2.1 多线程的创建和启动"></a>15.2.1 多线程的创建和启动</h2><ul><li>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。</li><li>Thread类的特性<ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li><li>通过该Thread对象的start()方法来调用这个线程</li></ul></li></ul><h2 id="15-2-2-子线程的创建和启动过程"><a href="#15-2-2-子线程的创建和启动过程" class="headerlink" title="15.2.2 子线程的创建和启动过程"></a>15.2.2 子线程的创建和启动过程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154639.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154701.png" alt></p><h2 id="15-2-3-Thread类"><a href="#15-2-3-Thread类" class="headerlink" title="15.2.3 Thread类"></a>15.2.3 Thread类</h2><ul><li>构造方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread()：创建新的Thread对象</span><br><span class="line">Thread(String threadname)：创建线程并指定线程实例名</span><br><span class="line">Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法</span><br><span class="line">Thread(Runnable target, String name)：创建新的Thread对象</span><br></pre></td></tr></table></figure><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><h4 id="一-继承Thread类"><a href="#一-继承Thread类" class="headerlink" title="一 继承Thread类"></a>一 继承Thread类</h4><p> 1)  定义子类继承Thread类。<br> 2)  子类中重写Thread类中的run方法。<br> 3)  创建Thread子类对象，即创建了线程对象。<br> 4)  调用线程对象start方法：启动线程，调用run方法  </p><h4 id="二-实现Runnable接口"><a href="#二-实现Runnable接口" class="headerlink" title="二 实现Runnable接口"></a>二 实现Runnable接口</h4><p>1）定义子类，实现Runnable接口。<br>2）子类中重写Runnable接口中的run方法。<br>3）通过Thread类含参构造器创建线程对象。<br>4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。<br>5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。  </p><h2 id="15-2-4-继承方式和实现方式的联系与区别"><a href="#15-2-4-继承方式和实现方式的联系与区别" class="headerlink" title="15.2.4 继承方式和实现方式的联系与区别"></a>15.2.4 继承方式和实现方式的联系与区别</h2><p>【区别】  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）继承Thread:       线程代码存放Thread子类run方法中。</span><br><span class="line">2）实现Runnable：线程代码存在接口的子类的run方法</span><br></pre></td></tr></table></figure><p>。<br>【实现方法的好处】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）避免了单继承的局限性</span><br><span class="line">2）多个线程可以共享同一个接口子类的对象，非常适合多个相同线程来处理同一份资源。</span><br></pre></td></tr></table></figure><h2 id="15-2-6-Thread类的有关方法-1"><a href="#15-2-6-Thread类的有关方法-1" class="headerlink" title="15.2.6 Thread类的有关方法(1)"></a>15.2.6 Thread类的有关方法(1)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   void start():  启动线程，并执行对象的run()方法</span><br><span class="line">run():  线程在被调度时执行的操作</span><br><span class="line">String getName():  返回线程的名称</span><br><span class="line">void setName(String name):设置该线程名称</span><br><span class="line">static currentThread(): 返回当前线程</span><br></pre></td></tr></table></figure><p>线程的调度</p><ul><li>调度策略<br>时间片</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155028.png" alt><br>抢占式：高优先级的线程抢占CPU </p><ul><li>Java的调度方法</li></ul><blockquote><ul><li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li><li>对高优先级，使用优先调度的抢占式策略</li></ul></blockquote><p>线程的优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   MAX_PRIORITY（10）;    </span><br><span class="line">MIN _PRIORITY （1）;  </span><br><span class="line">NORM_PRIORITY （5）;</span><br><span class="line">涉及的方法：</span><br><span class="line">getPriority() ：返回线程优先值 </span><br><span class="line">setPriority(int newPriority) ：改变线程的优先级</span><br><span class="line">线程创建时继承父线程的优先级</span><br></pre></td></tr></table></figure><h2 id="15-2-7-Thread类的有关方法-2"><a href="#15-2-7-Thread类的有关方法-2" class="headerlink" title="15.2.7 Thread类的有关方法(2)"></a>15.2.7 Thread类的有关方法(2)</h2><p>static  void  yield()：线程让步</p><blockquote><ul><li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li><li>若队列中没有同优先级的线程，忽略此方法</li></ul></blockquote><p>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止   </p><blockquote><ul><li>低优先级的线程也可以获得执行 </li></ul></blockquote><p>static  void  sleep(long millis)：(指定时间:毫秒)</p><blockquote><ul><li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</li><li>抛出InterruptedException异常</li></ul></blockquote><p>stop(): 强制线程生命期结束<br>boolean isAlive()：返回boolean，判断线程是否还活着</p><h2 id="15-2-8-使用多线程的优点"><a href="#15-2-8-使用多线程的优点" class="headerlink" title="15.2.8 使用多线程的优点"></a>15.2.8 使用多线程的优点</h2><p>背景：只使用单个线程完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？<br>多线程程序的优点：</p><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。  </li><li>提高计算机系统CPU的利用率  </li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改  </li></ol><h1 id="15-3-线程的生命周期"><a href="#15-3-线程的生命周期" class="headerlink" title="15.3 线程的生命周期"></a>15.3 线程的生命周期</h1><p>JDK中用Thread.State枚举表示了线程的几种状态</p><ul><li>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：<ul><li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件</li><li>运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能</li><li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了它的全部工作或线程被提前强制性地中止   </li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155642.png" alt></p><h1 id="15-4-线程的同步"><a href="#15-4-线程的同步" class="headerlink" title="15.4 线程的同步"></a>15.4 线程的同步</h1><p>问题的提出</p><ul><li>多个线程执行的不确定性引起执行结果的不稳定</li><li>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155722.png" alt></p><h2 id="15-4-1例-题"><a href="#15-4-1例-题" class="headerlink" title="15.4.1例  题"></a>15.4.1例  题</h2><p>模拟火车站售票程序，开启三个窗口售票。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Ticket implements Runnable &#123;</span><br><span class="line">private int tick = 100;</span><br><span class="line"></span><br><span class="line">public void run()&#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (tick &gt; 0) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;售出车票，tick号为：&quot; + tick--);</span><br><span class="line">&#125; else</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Ticket t = new Ticket();</span><br><span class="line"></span><br><span class="line">Thread t1 = new Thread(t);</span><br><span class="line">Thread t2 = new Thread(t);</span><br><span class="line">Thread t3 = new Thread(t);</span><br><span class="line">t1.setName(&quot;t1窗口&quot;);</span><br><span class="line">t2.setName(&quot;t2窗口&quot;);</span><br><span class="line">t3.setName(&quot;t3窗口&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155810.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155831.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private int tick = 100;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (tick &gt; 0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;售出车票，tick号为：&quot; + tick--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）    多线程出现了安全问题<br>2）    问题的原因：<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。<br>3）    解决办法<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p><h2 id="15-4-2-Synchronized的使用方法"><a href="#15-4-2-Synchronized的使用方法" class="headerlink" title="15.4.2 Synchronized的使用方法"></a>15.4.2 Synchronized的使用方法</h2><ul><li>Java对于多线程的安全问题提供了专业的解决方式： 同步代码块</li></ul><p>1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象)&#123;</span><br><span class="line">          // 需要被同步的代码；</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>2）    synchronized还可以放在方法声明中，表示整个方法<br>      为同步方法。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void show (String name)&#123; </span><br><span class="line">            ….</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603160032.png" alt></p><h2 id="15-4-3-同步锁-Lock"><a href="#15-4-3-同步锁-Lock" class="headerlink" title="15.4.3 同步锁(Lock)"></a>15.4.3 同步锁(Lock)</h2><ul><li>从Java 5开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li><li>Lock是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li><li>在实现线程安全的控制中，比较常用的是ReentrantLock(可重入锁)，可以显式加锁、释放锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">private final ReentrantLock lock = new ReenTrantLock();</span><br><span class="line"></span><br><span class="line">public void m() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// 保证线程安全的代码;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-4-互斥锁"><a href="#15-4-4-互斥锁" class="headerlink" title="15.4.4 互斥锁"></a>15.4.4 互斥锁</h2><ul><li>在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。<ul><li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li><li>关键字synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。</li><li>同步的局限性：导致程序的执行效率要降低</li><li>同步方法（非静态的）的锁为this。</li><li>同步方法（静态的）的锁为当前类本身。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">private Singleton() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">synchronized (Singleton.class) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSingleton &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Singleton s1 = Singleton.getInstance();</span><br><span class="line">Singleton s2 = Singleton.getInstance();</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-6-小结：释放锁的操作"><a href="#15-4-6-小结：释放锁的操作" class="headerlink" title="15.4.6 小结：释放锁的操作"></a>15.4.6 小结：释放锁的操作</h2><ul><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li></ul><h2 id="15-4-7-线程的死锁问题"><a href="#15-4-7-线程的死锁问题" class="headerlink" title="15.4.7 线程的死锁问题"></a>15.4.7 线程的死锁问题</h2><ul><li><p>死锁</p><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li></ul></li><li><p>解决方法</p><ul><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestDeadLock &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final StringBuffer s1 = new StringBuffer();</span><br><span class="line">final StringBuffer s2 = new StringBuffer();</span><br><span class="line">new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (s1) &#123;</span><br><span class="line">s2.append(&quot;A&quot;);</span><br><span class="line">synchronized (s2) &#123;</span><br><span class="line">s2.append(&quot;B&quot;);</span><br><span class="line">System.out.print(s1);</span><br><span class="line">System.out.print(s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (s2) &#123;</span><br><span class="line">s2.append(&quot;C&quot;);</span><br><span class="line">synchronized (s1) &#123;</span><br><span class="line">s1.append(&quot;D&quot;);</span><br><span class="line">System.out.print(s2);</span><br><span class="line">System.out.print(s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-5-线程的通信"><a href="#15-5-线程的通信" class="headerlink" title="15.5 线程的通信"></a>15.5 线程的通信</h1><ul><li><p>wait() 与 notify() 和 notifyAll()</p><ul><li>wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问</li><li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li><li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.</li></ul></li><li><p>Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常</p></li></ul><h2 id="15-5-1-wait-方法"><a href="#15-5-1-wait-方法" class="headerlink" title="15.5.1 wait() 方法"></a>15.5.1 wait() 方法</h2><ul><li>在当前线程中调用方法：  对象名.wait()</li><li>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。</li><li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li><li>调用此方法后，当前线程将释放对象监控权  ，然后进入等待</li><li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li></ul><h2 id="15-5-2-notify-notifyAll"><a href="#15-5-2-notify-notifyAll" class="headerlink" title="15.5.2 notify()/notifyAll()"></a>15.5.2 notify()/notifyAll()</h2><ul><li>在当前线程中调用方法：  对象名.notify()</li><li>功能：唤醒等待该对象监控权的一个线程。</li><li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li></ul><h2 id="15-5-3-例-题"><a href="#15-5-3-例-题" class="headerlink" title="15.5.3 例 题"></a>15.5.3 例 题</h2><p>使用两个线程打印 1-100. 线程1, 线程2 交替打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Communication implements Runnable &#123;</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">notify();</span><br><span class="line">if (i &lt;= 100) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);</span><br><span class="line">&#125; else</span><br><span class="line">break;</span><br><span class="line">try &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典例题：生产者/消费者问题</p><ul><li><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p></li><li><p>这里可能出现两个问题：</p><ul><li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li><li>消费者比生产者快时，消费者会取相同的数据。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class TestProduct &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Clerk clerk = new Clerk();</span><br><span class="line">Thread productorThread = new Thread(new Productor(clerk));</span><br><span class="line">Thread consumerThread = new Thread(new Consumer(clerk));</span><br><span class="line">productorThread.start();</span><br><span class="line">consumerThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clerk &#123; // 售货员</span><br><span class="line">private int product = 0;</span><br><span class="line"></span><br><span class="line">public synchronized void addProduct() &#123;</span><br><span class="line">if (product &gt;= 20) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">product++;</span><br><span class="line">System.out.println(&quot;生产者生产了第&quot; + product + &quot;个产品&quot;);</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void getProduct() &#123;</span><br><span class="line">if (this.product &lt;= 0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;消费者取走了第&quot; + product + &quot;个产品&quot;);</span><br><span class="line">product--;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Productor implements Runnable &#123; // 生产者</span><br><span class="line">Clerk clerk;</span><br><span class="line"></span><br><span class="line">public Productor(Clerk clerk) &#123;</span><br><span class="line">this.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;生产者开始生产产品&quot;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep((int) Math.random() * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">clerk.addProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable &#123; // 消费者</span><br><span class="line">Clerk clerk;</span><br><span class="line"></span><br><span class="line">public Consumer(Clerk clerk) &#123;</span><br><span class="line">this.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;消费者开始取走产品&quot;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep((int) Math.random() * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">clerk.getProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>15.5.4 练习1<br>模拟银行取钱的问题<br>1.定义一个Account类<br>1）该Account类封装了账户编号（String）和余额（double）两个属性<br>2）设置相应属性的getter和setter方法<br>3）提供无参和有两个参数的构造器<br>4）系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写<br>2.提供一个取钱的线程类<br>1）提供了Account类的account属性和double类的取款额的属性<br>2）提供带线程名的构造方法<br>3）run()方法中提供取钱的操作<br>3.在主类中创建线程进行测试。考虑线程安全问题。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">private String accountId;</span><br><span class="line">private double balance;</span><br><span class="line"></span><br><span class="line">public Account() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Account(String accountId, double balance) &#123;</span><br><span class="line">this.accountId = accountId;</span><br><span class="line">this.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getAccountId() &#123;</span><br><span class="line">return accountId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAccountId(String accountId) &#123;</span><br><span class="line">this.accountId = accountId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getBalance() &#123;</span><br><span class="line">return balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setBalance(double balance) &#123;</span><br><span class="line">this.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Account [accountId=&quot; + accountId + &quot;, balance=&quot; + balance + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">final int prime = 31;</span><br><span class="line">int result = 1;</span><br><span class="line">result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());</span><br><span class="line">long temp;</span><br><span class="line">temp = Double.doubleToLongBits(balance);</span><br><span class="line">result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">if (this == obj)</span><br><span class="line">return true;</span><br><span class="line">if (obj == null)</span><br><span class="line">return false;</span><br><span class="line">if (getClass() != obj.getClass())</span><br><span class="line">return false;</span><br><span class="line">Account other = (Account) obj;</span><br><span class="line">if (accountId == null) &#123;</span><br><span class="line">if (other.accountId != null)</span><br><span class="line">return false;</span><br><span class="line">&#125; else if (!accountId.equals(other.accountId))</span><br><span class="line">return false;</span><br><span class="line">if (Double.doubleToLongBits(balance) != Double.doubleToLongBits(other.balance))</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WithDrawThread extends Thread &#123;</span><br><span class="line">Account account;</span><br><span class="line">// 要取款的额度</span><br><span class="line">double withDraw;</span><br><span class="line"></span><br><span class="line">public WithDrawThread(String name, Account account, double amt) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.account = account;</span><br><span class="line">this.withDraw = amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (account) &#123;</span><br><span class="line">if (account.getBalance() &gt; withDraw) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:取款成功，取现的金额为：&quot; + withDraw);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(50);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">account.setBalance(account.getBalance() - withDraw);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;取现额度超过账户余额，取款失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;现在账户的余额为：&quot; + account.getBalance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WithDrawThread extends Thread &#123;</span><br><span class="line">Account account;</span><br><span class="line">// 要取款的额度</span><br><span class="line">double withDraw;</span><br><span class="line"></span><br><span class="line">public WithDrawThread(String name, Account account, double amt) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.account = account;</span><br><span class="line">this.withDraw = amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (account) &#123;</span><br><span class="line">if (account.getBalance() &gt; withDraw) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:取款成功，取现的金额为：&quot; + withDraw);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(50);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">account.setBalance(account.getBalance() - withDraw);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;取现额度超过账户余额，取款失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;现在账户的余额为：&quot; + account.getBalance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;public class TestWithDrawThread &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Account account = new Account(&quot;1234567&quot;, 10000);</span><br><span class="line">Thread t1 = new WithDrawThread(&quot;小明&quot;, account, 8000);</span><br><span class="line">Thread t2 = new WithDrawThread(&quot;小明&apos;s wife&quot;, account, 2800);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-6-线程池"><a href="#15-6-线程池" class="headerlink" title="15.6 线程池"></a>15.6 线程池</h1><ul><li>系统启动一个新线程的成本是比较高的，因为它涉及与os交互。这种情况下，系统启动时即创建大量空闲的线程，就可以很好地提高性能，尤其是当程序需要创建大量生存期很短暂的线程时。</li><li>除此之外，使用线程池可以有效地控制系统中并发线程的数量。避免因并发创建的线程过多，导致系统性能下降，JVM崩溃。</li><li>Java 5以前，需要手动创建自己的线程池；Java 5开始，新增了Executors工厂类产生线程池。<br>使用线程池执行线程任务的步骤如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.调用Executors 类的静态方法newFixedThreadPool(int nThreads)，</span><br><span class="line">    创建一个可重用的、具有固定线程数的线程池ExecutorService对象  </span><br><span class="line">2.创建Runnable实例，作为线程执行任务  </span><br><span class="line">3.调用ExecutorService对象的submit()提交Runnable实例  </span><br><span class="line">4.调用ExecutorService对象的shutDown()方法关闭线程池。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;15-1-程序、进程、线程的概念&quot;&gt;&lt;a href=&quot;#15-1-程序、进程、线程的概念&quot; class=&quot;headerlink&quot; title=&quot;15.1 程序、进程、线程的概念&quot;&gt;&lt;/a&gt;15.1 程序、进程、线程的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;程序(progr
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>14. JavaSE-Java反射机制</title>
    <link href="http://yoursite.com/2017/02/16/14.%20JavaSE-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/02/16/14. JavaSE-Java反射机制/</id>
    <published>2017-02-15T16:00:00.000Z</published>
    <updated>2019-06-04T01:26:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14-1-Java反射机制概述"><a href="#14-1-Java反射机制概述" class="headerlink" title="14.1 Java反射机制概述"></a>14.1 Java反射机制概述</h1><ul><li>Java Reflection<br>   Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</li></ul><ul><li><p>Java反射机制提供的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ul></li><li><p>反射相关的主要API：</p><ul><li>java.lang.Class:代表一个类</li><li>java.lang.reflect.Method:代表类的方法</li><li>java.lang.reflect.Field:代表类的成员变量</li><li>java.lang.reflect.Constructor:代表类的构造方法</li><li>。。。</li></ul></li></ul><h1 id="14-2-理解Class类并获取Class的实例"><a href="#14-2-理解Class类并获取Class的实例" class="headerlink" title="14.2 理解Class类并获取Class的实例"></a>14.2 理解Class类并获取Class的实例</h1><h3 id="14-2-1-Class-类"><a href="#14-2-1-Class-类" class="headerlink" title="14.2.1 Class 类"></a>14.2.1 Class 类</h3><p>在Object类中定义了以下的方法，此方法将被所有子类继承：<br>●  public final Class getClass()<br>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604003545.png" alt></p><ul><li>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。</li><li>Class本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个类在 JVM 中只会有一个Class实例 </li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的完整结构 </li></ul><h2 id="14-2-2-Class类的常用方法"><a href="#14-2-2-Class类的常用方法" class="headerlink" title="14.2.2 Class类的常用方法"></a>14.2.2 Class类的常用方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151527.png" alt></p><h2 id="14-2-3"><a href="#14-2-3" class="headerlink" title="14.2.3"></a>14.2.3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">•String str = &quot;test4.Person&quot;;</span><br><span class="line">•Class clazz = Class.forName(str);</span><br><span class="line">•Object obj = clazz.newInstance();</span><br><span class="line">•Field field = clazz.getField(&quot;name&quot;);</span><br><span class="line">•field.set(obj, &quot;Peter&quot;);</span><br><span class="line">•Object obj2 = field.get(obj);</span><br><span class="line">•System.out.println(obj2);</span><br></pre></td></tr></table></figure><h2 id="14-2-4-实例化Class类对象-四种方法"><a href="#14-2-4-实例化Class类对象-四种方法" class="headerlink" title="14.2.4 实例化Class类对象(四种方法)"></a>14.2.4 实例化Class类对象(四种方法)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）前提：若已知具体的类，通过类的class属性获取，该方法 </span><br><span class="line">                    最为安全可靠，程序性能最高</span><br><span class="line">       实例：Class clazz = String.class;</span><br><span class="line">2）前提：已知某个类的实例，调用该实例的getClass()方法获</span><br><span class="line">                    取Class对象</span><br><span class="line">       实例：Class clazz = “www.atguigu.com”.getClass();</span><br><span class="line">3）前提：已知一个类的全类名，且该类在类路径下，可通过</span><br><span class="line">       Class类的静态方法forName()获取，可能抛出ClassNotFoundException</span><br><span class="line">       实例：Class clazz = Class.forName(“java.lang.String”);</span><br><span class="line">4）其他方式(不做要求)</span><br><span class="line">ClassLoader cl = this.getClass().getClassLoader();</span><br><span class="line">Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure><h1 id="14-3-类的加载与ClassLoader的理解"><a href="#14-3-类的加载与ClassLoader的理解" class="headerlink" title="14.3 类的加载与ClassLoader的理解"></a>14.3 类的加载与ClassLoader的理解</h1><h2 id="14-3-1-了解：类的加载过程"><a href="#14-3-1-了解：类的加载过程" class="headerlink" title="14.3.1 了解：类的加载过程"></a>14.3.1 了解：类的加载过程</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151722.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151758.png" alt></p><h2 id="14-3-2-了解：ClassLoader"><a href="#14-3-2-了解：ClassLoader" class="headerlink" title="14.3.2 了解：ClassLoader"></a>14.3.2 了解：ClassLoader</h2><p>类加载器是用来把类(class)装载进内存的。JVM 规范定义了两种类型的类加载器：启动类加载器(bootstrap)和用户自定义加载器(user-defined class loader)。 JVM在运行时会产生3个类加载器组成的初始化加载器层次结构 ，如下图所示：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603151830.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">•//1.获取一个系统类加载器</span><br><span class="line">•ClassLoader classloader = ClassLoader.getSystemClassLoader();</span><br><span class="line">•System.out.println(classloader);</span><br><span class="line">•//2.获取系统类加载器的父类加载器，即扩展类加载器</span><br><span class="line">•classloader = classloader.getParent();</span><br><span class="line">•System.out.println(classloader);</span><br><span class="line">•//3.获取扩展类加载器的父类加载器，即引导类加载器</span><br><span class="line">•classloader = classloader.getParent();</span><br><span class="line">•System.out.println(classloader);</span><br><span class="line">•//4.测试当前类由哪个类加载器进行加载</span><br><span class="line">•classloader = </span><br><span class="line">•Class.forName(&quot;exer2.ClassloaderDemo&quot;).getClassLoader();</span><br><span class="line">•System.out.println(classloader);</span><br><span class="line">•//5.测试JDK提供的Object类由哪个类加载器加载</span><br><span class="line">•classloader = </span><br><span class="line">•Class.forName(&quot;java.lang.Object&quot;).getClassLoader();</span><br><span class="line">•System.out.println(classloader);</span><br><span class="line">•//*6.关于类加载器的一个主要方法：</span><br><span class="line">    getResourceAsStream(String str):获取类路径下的指定文件的输入流</span><br><span class="line">•InputStream in = null;</span><br><span class="line">•in = this.getClass().getClassLoader().getResourceAsStream(&quot;exer2\\test.properties&quot;);</span><br><span class="line">•System.out.println(in);</span><br></pre></td></tr></table></figure><h1 id="14-4-创建运行时类的对象"><a href="#14-4-创建运行时类的对象" class="headerlink" title="14.4 创建运行时类的对象"></a>14.4 创建运行时类的对象</h1><p>[问题] 有了Class对象，能做什么？</p><p>创建类的对象：调用Class对象的newInstance()方法<br>要  求：  </p><p>1）类必须有一个无参数的构造器。<br>2）类的构造器的访问权限需要足够。  </p><p>难道没有无参的构造器就不能创建对象了吗？<br>不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。步骤如下：<br>1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<br>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。<br>3）在Constructor类中存在一个方法:<br>     Public T newInstance(Object … initargs);<br>以上是反射机制用的最多的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.根据全类名获取对应的Class对象</span><br><span class="line">String name = “atguigu.java.Person&quot;;</span><br><span class="line">Class clazz = null;</span><br><span class="line">clazz = Class.forName(name);</span><br><span class="line">//2.调用指定参数结构的构造器，生成Constructor的实例</span><br><span class="line">Constructor con = clazz.getConstructor(String.class,Integer.class);</span><br><span class="line">//3.通过Constructor的实例创建对应类的对象，并初始化类属性</span><br><span class="line">Person p2 = (Person) con.newInstance(&quot;Peter&quot;,20);</span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure><h1 id="14-5-获取运行时类的完整结构"><a href="#14-5-获取运行时类的完整结构" class="headerlink" title="14.5 获取运行时类的完整结构"></a>14.5 获取运行时类的完整结构</h1><h2 id="14-5-1-通过反射获取运行时类的完整结构"><a href="#14-5-1-通过反射获取运行时类的完整结构" class="headerlink" title="14.5.1 通过反射获取运行时类的完整结构"></a>14.5.1 通过反射获取运行时类的完整结构</h2><p>Field、Method、Constructor、Superclass、Interface、Annotation</p><ul><li>实现的全部接口</li><li>所继承的父类</li><li>全部的构造器</li><li>全部的方法</li><li>全部的Field</li></ul><h2 id="14-5-2-通过反射获取运行时类的完整结构"><a href="#14-5-2-通过反射获取运行时类的完整结构" class="headerlink" title="14.5.2 通过反射获取运行时类的完整结构"></a>14.5.2 通过反射获取运行时类的完整结构</h2><p>使用反射可以取得：<br>1 实现的全部接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt;[] getInterfaces()     </span><br><span class="line">确定此对象所表示的类或接口实现的接口。</span><br></pre></td></tr></table></figure><p>2 所继承的父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;? Super T&gt; getSuperclass()</span><br><span class="line">返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</span><br></pre></td></tr></table></figure><p>3 全部的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt;[] getConstructors()</span><br><span class="line">返回此 Class 对象所表示的类的所有public构造方法。</span><br><span class="line">public Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br><span class="line">返回此 Class 对象表示的类声明的所有构造方法。</span><br></pre></td></tr></table></figure><ul><li>Constructor类中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   取得修饰符: public int getModifiers();</span><br><span class="line">取得方法名称: public String getName();</span><br><span class="line">取得参数的类型：public Class&lt;?&gt;[] getParameterTypes();</span><br></pre></td></tr></table></figure><p>4 全部的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public Method[] getDeclaredMethods()</span><br><span class="line">返回此Class对象所表示的类或接口的全部方法</span><br><span class="line">public Method[] getMethods()  </span><br><span class="line">返回此Class对象所表示的类或接口的public的方法</span><br></pre></td></tr></table></figure><p>Method类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   public Class&lt;?&gt; getReturnType()取得全部的返回值</span><br><span class="line">public Class&lt;?&gt;[] getParameterTypes()取得全部的参数</span><br><span class="line">public int getModifiers()取得修饰符</span><br><span class="line">public Class&lt;?&gt;[] getExceptionTypes()取得异常信息</span><br></pre></td></tr></table></figure><p>5.全部的Field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Field[] getFields() </span><br><span class="line">返回此Class对象所表示的类或接口的public的Field。</span><br><span class="line">public Field[] getDeclaredFields() </span><br><span class="line">返回此Class对象所表示的类或接口的全部Field。</span><br></pre></td></tr></table></figure><p>Field方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int getModifiers() </span><br><span class="line">以整数形式返回此Field的修饰符</span><br><span class="line">public Class&lt;?&gt; getType()</span><br><span class="line">    得到Field的属性类型</span><br><span class="line">public String getName() </span><br><span class="line">返回Field的名称。</span><br></pre></td></tr></table></figure></p><ol start="6"><li>Annotation相关</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get Annotation(Class&lt;T&gt; annotationClass) </span><br><span class="line">getDeclaredAnnotations()</span><br></pre></td></tr></table></figure><p>7.泛型相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取父类泛型类型：Type getGenericSuperclass()</span><br><span class="line">泛型类型：ParameterizedType</span><br><span class="line">获取实际的泛型类型参数数组：getActualTypeArguments()</span><br></pre></td></tr></table></figure><p>8.类所在的包    Package getPackage() </p><p>小 结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在实际的操作中，取得类的信息的操作代码，并不会经常开发。</span><br><span class="line">2.一定要熟悉java.lang.reflect包的作用，反射机制。</span><br><span class="line">3.如何取得属性、方法、构造器的名称，修饰符等。</span><br></pre></td></tr></table></figure><h1 id="14-6-调用运行时类的指定属性、指定方法等"><a href="#14-6-调用运行时类的指定属性、指定方法等" class="headerlink" title="14.6 调用运行时类的指定属性、指定方法等"></a>14.6 调用运行时类的指定属性、指定方法等</h1><h2 id="14-6-1-通过反射调用类中的指定方法、指定属性"><a href="#14-6-1-通过反射调用类中的指定方法、指定属性" class="headerlink" title="14.6.1 通过反射调用类中的指定方法、指定属性"></a>14.6.1 通过反射调用类中的指定方法、指定属性</h2><p>1.调用指定方法<br>通过反射，调用类中的方法，通过Method类完成。步骤： </p><ul><li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li><li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153110.png" alt></p><p>2.通过反射调用类中的指定方法、指定属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object obj, Object …  args)</span><br></pre></td></tr></table></figure><p>1）说明：</p><blockquote><p>   1.Object 对应原方法的返回值，若原方法无返回值，此时返回null<br>   2.若原方法若为静态方法，此时形参Object obj可为null<br>   3.若原方法形参列表为空，则Object[] args为null<br>   4.若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</p></blockquote><p>2）调用指定属性  </p><ul><li>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public Field getField(String name)</span><br><span class="line">返回此Class对象表示的类或接口的指定的public的Field。</span><br><span class="line">    public Field getDeclaredField(String name)</span><br><span class="line">返回此Class对象表示的类或接口的指定的Field。</span><br></pre></td></tr></table></figure><ul><li>在Field中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object obj)</span><br><span class="line">    取得指定对象obj上此Field的属性内容</span><br><span class="line">public void set(Object obj,Object value)</span><br><span class="line">设置指定对象obj上此Field的属性内容</span><br></pre></td></tr></table></figure><p>注：在类中属性都设置为private的前提下，在使用set()和get()方法时，首先要使用Field类中的setAccessible(true)方法将需要操作的属性设置为可以被外部访问。</p><ul><li>public void setAccessible(true)访问私有属性时，让这个属性可见。 </li></ul><h1 id="14-7-反射的应用：动态代理"><a href="#14-7-反射的应用：动态代理" class="headerlink" title="14.7 反射的应用：动态代理"></a>14.7 反射的应用：动态代理</h1><h2 id="14-7-1-Java动态代理"><a href="#14-7-1-Java动态代理" class="headerlink" title="14.7.1 Java动态代理"></a>14.7.1 Java动态代理</h2><ul><li>之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</li><li>最好可以通过一个代理类完成全部的代理功能</li><li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</li><li><p>动态代理使用场合:</p><ul><li>调试</li><li>远程方法调用</li></ul></li><li><p>代理设计模式的原理:<br>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上.</p></li><li><p>Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</p></li><li>提供用于创建动态代理类和动态代理对象的静态方法<ul><li>static Class&lt;?&gt;   getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces)  创建一个动态代理类所对应的Class对象</li><li>static Object   newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)  直接创建一个动态代理对象</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader : 类加载器</span><br><span class="line">Class&lt;?&gt;[] : 得到全部的接口</span><br><span class="line">InvocationHandler : 得到InvocationHandler接口的子类实例</span><br></pre></td></tr></table></figure><h2 id="14-7-2-动态代理步骤"><a href="#14-7-2-动态代理步骤" class="headerlink" title="14.7.2 动态代理步骤"></a>14.7.2 动态代理步骤</h2><p>1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object theProxy, Method method, Object[] params) throws Throwable&#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">         Object retval = method.invoke(targetObj, params);</span><br><span class="line">         // Print out the result</span><br><span class="line">           System.out.println(retval);</span><br><span class="line">            return retval;</span><br><span class="line">        &#125;</span><br><span class="line">      catch (Exception exc)&#123;&#125;</span><br><span class="line">Object theProxy : 被代理对象</span><br><span class="line">Method method : 要调用的方法</span><br><span class="line">Object[] params : 方法调用时所需要的参数</span><br></pre></td></tr></table></figure><p>2.创建被代理的类以及接口</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153731.png" alt></p><p>3.通过Proxy的静态方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个Subject接口代理</span><br><span class="line">   RealSubject target = new RealSubject();</span><br><span class="line">// Create a proxy to wrap the original implementation</span><br><span class="line">            DebugProxy proxy = new DebugProxy(target);</span><br><span class="line"> // Get a reference to the proxy through the Subject interface</span><br><span class="line">          Subject sub = (Subject) Proxy.newProxyInstance(</span><br><span class="line">            Subject.class.getClassLoader(),</span><br><span class="line">            new Class[] &#123; Subject.class &#125;, proxy);</span><br></pre></td></tr></table></figure><p>4.通过 Subject代理调用RealSubject实现类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String info = sub.say(“Peter&quot;, 24);</span><br><span class="line"> System.out.println(info);</span><br></pre></td></tr></table></figure><h2 id="14-7-3-动态代理与AOP（Aspect-Orient-Programming"><a href="#14-7-3-动态代理与AOP（Aspect-Orient-Programming" class="headerlink" title="14.7.3 动态代理与AOP（Aspect Orient Programming)"></a>14.7.3 动态代理与AOP（Aspect Orient Programming)</h2><p>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下面介绍一种更实用的动态代理机制</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153928.png" alt></p><p>改进后的说明：代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和一个特定的方法A耦合了！最理想的效果是：代码块1、2、3既可以执行方法A，又无须在程序中以硬编码的方式直接调用深色代码的方法</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603153949.png" alt></p><p>代码演示 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">public interface Dog &#123;</span><br><span class="line">void info();</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HuntingDog implements Dog &#123;</span><br><span class="line">public void info() &#123;</span><br><span class="line">System.out.println(&quot;我是一只猎狗&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;我奔跑迅速&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DogUtil &#123;</span><br><span class="line">public void method1() &#123;</span><br><span class="line">System.out.println(&quot;=====模拟通用方法一=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void method2() &#123;</span><br><span class="line">System.out.println(&quot;=====模拟通用方法二=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DogUtil &#123;</span><br><span class="line">public void method1() &#123;</span><br><span class="line">System.out.println(&quot;=====模拟通用方法一=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void method2() &#123;</span><br><span class="line">System.out.println(&quot;=====模拟通用方法二=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DogUtil &#123;</span><br><span class="line">public void method1() &#123;</span><br><span class="line">System.out.println(&quot;=====模拟通用方法一=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void method2() &#123;</span><br><span class="line">System.out.println(&quot;=====模拟通用方法二=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">// 需要被代理的对象</span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public void setTarget(Object target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行动态代理对象的所有方法时，都会被替换成执行如下的invoke方法</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Exception &#123;</span><br><span class="line">DogUtil du = new DogUtil();</span><br><span class="line">// 执行DogUtil对象中的method1。</span><br><span class="line">du.method1();</span><br><span class="line">// 以target作为主调来执行method方法</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">// 执行DogUtil对象中的method2。</span><br><span class="line">du.method2();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">// 需要被代理的对象</span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public void setTarget(Object target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行动态代理对象的所有方法时，都会被替换成执行如下的invoke方法</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Exception &#123;</span><br><span class="line">DogUtil du = new DogUtil();</span><br><span class="line">// 执行DogUtil对象中的method1。</span><br><span class="line">du.method1();</span><br><span class="line">// 以target作为主调来执行method方法</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">// 执行DogUtil对象中的method2。</span><br><span class="line">du.method2();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyProxyFactory &#123;</span><br><span class="line">// 为指定target生成动态代理对象</span><br><span class="line">public static Object getProxy(Object target) throws Exception &#123;</span><br><span class="line">// 创建一个MyInvokationHandler对象</span><br><span class="line">MyInvokationHandler handler = new MyInvokationHandler();</span><br><span class="line">// 为MyInvokationHandler设置target对象</span><br><span class="line">handler.setTarget(target);</span><br><span class="line">// 创建、并返回一个动态代理对象</span><br><span class="line">return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyProxyFactory &#123;</span><br><span class="line">// 为指定target生成动态代理对象</span><br><span class="line">public static Object getProxy(Object target) throws Exception &#123;</span><br><span class="line">// 创建一个MyInvokationHandler对象</span><br><span class="line">MyInvokationHandler handler = new MyInvokationHandler();</span><br><span class="line">// 为MyInvokationHandler设置target对象</span><br><span class="line">handler.setTarget(target);</span><br><span class="line">// 创建、并返回一个动态代理对象</span><br><span class="line">return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">throws Exception&#123;</span><br><span class="line">// 创建一个原始的HuntingDog对象，作为target</span><br><span class="line">Dog target = new HuntingDog();</span><br><span class="line">// 以指定的target来创建动态代理</span><br><span class="line">Dog dog = (Dog)MyProxyFactory.getProxy(target);</span><br><span class="line">dog.info();</span><br><span class="line">dog.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理</li><li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154040.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;14-1-Java反射机制概述&quot;&gt;&lt;a href=&quot;#14-1-Java反射机制概述&quot; class=&quot;headerlink&quot; title=&quot;14.1 Java反射机制概述&quot;&gt;&lt;/a&gt;14.1 Java反射机制概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java Reflect
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>13. JavaSE-IO流</title>
    <link href="http://yoursite.com/2017/01/29/13.%20JavaSE-IO%E6%B5%81/"/>
    <id>http://yoursite.com/2017/01/29/13. JavaSE-IO流/</id>
    <published>2017-01-28T16:00:00.000Z</published>
    <updated>2019-06-04T01:26:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-1-File类的使用"><a href="#13-1-File类的使用" class="headerlink" title="13.1 File类的使用"></a>13.1 File类的使用</h1><h2 id="13-1-1-File类"><a href="#13-1-1-File类" class="headerlink" title="13.1.1 File类"></a>13.1.1 File类</h2><ul><li>java.io.File类：文件和目录路径名的抽象表示形式，与平台无关</li><li>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。</li><li>File对象可以作为参数传递给流的构造器</li></ul><h2 id="13-1-2-File类的常见构造器"><a href="#13-1-2-File类的常见构造器" class="headerlink" title="13.1.2 File类的常见构造器"></a>13.1.2 File类的常见构造器</h2><ul><li>public File(String pathname)<br>以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</li><li>public File(String parent,String child)<br>以parent为父路径，child为子路径创建File对象。</li><li>File的静态属性String separator存储了当前系统的路径分隔符。</li><li>在UNIX中，此字段为‘/’，在Windows中，为‘\’</li></ul><h2 id="13-1-3-File类常用API"><a href="#13-1-3-File类常用API" class="headerlink" title="13.1.3 File类常用API"></a>13.1.3 File类常用API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">访问文件名：</span><br><span class="line">getName()</span><br><span class="line">getPath()</span><br><span class="line">getAbsoluteFile()</span><br><span class="line">getAbsolutePath()</span><br><span class="line">getParent()</span><br><span class="line">toPath()</span><br><span class="line">renameTo(File newName)</span><br><span class="line"></span><br><span class="line">文件检测</span><br><span class="line">exists()</span><br><span class="line">canWrite()</span><br><span class="line">canRead()</span><br><span class="line">isFile()</span><br><span class="line">isDirectory()</span><br><span class="line"></span><br><span class="line">获取常规文件信息</span><br><span class="line">lastModified()</span><br><span class="line">length()</span><br><span class="line"></span><br><span class="line">文件操作相关</span><br><span class="line">createNewFile()</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">目录操作相关</span><br><span class="line">mkdir()</span><br><span class="line">mkdirs()</span><br><span class="line">delete()</span><br><span class="line">list()</span><br><span class="line">listFiles()</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">File dir1 = new File(&quot;D:/IOTest/dir1&quot;);</span><br><span class="line">if (!dir1.exists()) &#123;     // 如果D:/IOTest/dir1不存在，就创建为目录</span><br><span class="line">dir1.mkdir(); &#125;</span><br><span class="line">// 创建以dir1为父目录,名为&quot;dir2&quot;的File对象</span><br><span class="line">File dir2 = new File(dir1, &quot;dir2&quot;); </span><br><span class="line">if (!dir2.exists()) &#123; // 如果还不存在，就创建为目录</span><br><span class="line">dir2.mkdirs(); &#125;</span><br><span class="line">File dir4 = new File(dir1, &quot;dir3/dir4&quot;);</span><br><span class="line">if (!dir4.exists()) &#123;</span><br><span class="line">dir4.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">// 创建以dir2为父目录,名为&quot;test.txt&quot;的File对象</span><br><span class="line">File file = new File(dir2, &quot;test.txt&quot;); </span><br><span class="line">if (!file.exists()) &#123; // 如果还不存在，就创建为文件</span><br><span class="line">file.createNewFile();&#125;</span><br></pre></td></tr></table></figure><h1 id="13-2-IO流原理及流的分类"><a href="#13-2-IO流原理及流的分类" class="headerlink" title="13.2 IO流原理及流的分类"></a>13.2 IO流原理及流的分类</h1><h2 id="13-2-1-Java-IO流原理"><a href="#13-2-1-Java-IO流原理" class="headerlink" title="13.2.1 Java IO流原理"></a>13.2.1 Java IO流原理</h2><ul><li>I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</li><li>Java程序中，对于数据的输入/输出操作以”流(stream)” 的方式进行。java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603115552.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603115622.png" alt></p><h2 id="13-2-2-流的分类"><a href="#13-2-2-流的分类" class="headerlink" title="13.2.2 流的分类"></a>13.2.2 流的分类</h2><ul><li>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)  </li><li>按数据流的流向不同分为：输入流，输出流</li><li>按流的角色的不同分为：节点流，处理流</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603115659.png" alt></p><ol><li>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。  </li><li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li></ol><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603115728.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603115754.png" alt></p><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><p>1.节点流可以从一个特定的数据源读写数据</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603115830.png" alt></p><ol start="2"><li>处理流是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</li></ol><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603140827.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603141027.png" alt></p><p>InputStream &amp; Reader</p><ul><li>InputStream 和 Reader 是所有输入流的基类。</li><li><p>InputStream（典型实现：FileInputStream）</p><ul><li>int read()</li><li>int read(byte[] b)</li><li>int read(byte[] b, int off, int len)</li></ul></li><li><p>Reader（典型实现：FileReader）</p><ul><li>int read()</li><li>int read(char [] c)</li><li>int read(char [] c, int off, int len)</li></ul></li><li><p>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源。</p></li></ul><h2 id="13-2-3-节点流-文件流"><a href="#13-2-3-节点流-文件流" class="headerlink" title="13.2.3 节点流(文件流)"></a>13.2.3 节点流(文件流)</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>1 建立一个流对象，将已存在的一个文件加载进流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = new FileReader(“Test.txt”);</span><br></pre></td></tr></table></figure><p>2 创建一个临时存放数据的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char[] ch = new char[1024];</span><br></pre></td></tr></table></figure><p>3 调用流对象的读取方法将流中的数据读入到数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fr.read(ch);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = null;</span><br><span class="line">try&#123;</span><br><span class="line">fr = new FileReader(&quot;c:\\test.txt&quot;);</span><br><span class="line">char[] buf = new char[1024];</span><br><span class="line">int len= 0;</span><br><span class="line">while((len=fr.read(buf))!=-1)&#123;</span><br><span class="line">System.out.println(new String(buf ,0,len));&#125;</span><br><span class="line">&#125;catch (IOException e)&#123;</span><br><span class="line">System.out.println(&quot;read-Exception :&quot;+e.toString());&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">if(fr!=null)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">fr.close();</span><br><span class="line">&#125;catch (IOException e)&#123;</span><br><span class="line">System.out.println(&quot;close-Exception :&quot;+e.toString());</span><br><span class="line">&#125; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>1.创建流对象，建立数据存放文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = new FileWriter(“Test.txt”);</span><br></pre></td></tr></table></figure><p>2.调用流对象的写入方法，将数据写入流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fw.write(“text”);</span><br></pre></td></tr></table></figure><p>3.关闭流资源，并将流中的数据清空到文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fw.close();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = null;</span><br><span class="line">try&#123;</span><br><span class="line">fw = new FileWriter(&quot;Test.txt&quot;);</span><br><span class="line">fw.write(&quot;text&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)&#123;</span><br><span class="line">System.out.println(e.toString());</span><br><span class="line">&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">If(fw!=null)</span><br><span class="line">try&#123;</span><br><span class="line"> fw.close();</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)&#123;</span><br><span class="line">System.out.println(e.toString());&#125;&#125;</span><br></pre></td></tr></table></figure><p>注  意</p><ul><li>定义文件路径时，注意：可以用“/”或者“\”。</li><li>在写入一个文件时，如果目录下有同名文件将被覆盖。<br>在读取文件时，必须保证该文件已存在，否则出异常</li></ul><h2 id="13-2-4-缓冲流"><a href="#13-2-4-缓冲流" class="headerlink" title="13.2.4 缓冲流"></a>13.2.4 缓冲流</h2><ul><li>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组</li><li><p>根据数据操作单位可以把缓冲流分为：</p><ul><li>BufferedInputStream 和 BufferedOutputStream</li><li>BufferedReader 和 BufferedWriter</li></ul></li><li><p>缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法</p></li><li>对于输出的缓冲流，写出的数据会先在内存中缓存，使用flush()将会使内存中的数据立刻写出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = null;</span><br><span class="line">BufferedWriter bw = null;</span><br><span class="line">try &#123;</span><br><span class="line">//step1:创建缓冲流对象：它是过滤流，是对节点流的包装</span><br><span class="line">br = new  BufferedReader(new FileReader(&quot;d:\\IOTest\\source.txt&quot;));</span><br><span class="line">bw = new BufferedWriter(new FileWriter(&quot;d:\\IOTest\\destBF.txt&quot;));</span><br><span class="line">String str = null;</span><br><span class="line">while ((str = br.readLine()) != null) &#123; //一次读取字符文本文件的一行字符</span><br><span class="line">bw.write(str); //一次写入一行字符串</span><br><span class="line">bw.newLine();  //写入行分隔符</span><br><span class="line">bw.flush();  //step2:刷新缓冲区</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// step3: 关闭IO流对象</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">if (bw != null) &#123;</span><br><span class="line">bw.close();  //关闭过滤流时,会自动关闭它所包装的底层节点流</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">if (br != null) &#123;</span><br><span class="line">br.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-2-5-转换流"><a href="#13-2-5-转换流" class="headerlink" title="13.2.5 转换流"></a>13.2.5 转换流</h2><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><ul><li>转换流提供了在字节流和字符流之间的转换</li><li>Java API提供了两个转换流：<ul><li><code>InputStreamReader和OutputStreamWriter</code></li></ul></li><li>字节流中的数据都是字符时，转成字符流操作更高效。</li></ul><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader`"></a>InputStreamReader`</h3><ul><li>用于将字节流中读取到的字节按指定字符集解码成字符。需要和InputStream“套接”。</li><li>构造方法<ul><li>public InputStreamReader(InputStream in)</li><li>public InputSreamReader(InputStream in,String charsetName)  </li></ul></li></ul><p>如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isr = new </span><br><span class="line">    InputStreamReader(System.in,”gb2312”);</span><br></pre></td></tr></table></figure><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><ul><li>用于将要写入到字节流中的字符按指定字符集编码成字节。需要和OutputStream“套接”。</li><li>构造方法<ul><li>public OutputStreamWriter(OutputStream out)</li><li>public OutputSreamWriter(OutputStream out,String charsetName)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603142510.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void testMyInput() throws Exception&#123;</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;dbcp.txt&quot;);</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;dbcp5.txt&quot;);</span><br><span class="line">    InputStreamReader isr = new InputStreamReader(fis,&quot;GBK&quot;);</span><br><span class="line">    OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;GBK&quot;);</span><br><span class="line">    BufferedReader br = new BufferedReader(isr);</span><br><span class="line">    BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">    String str = null;</span><br><span class="line">    while((str = br.readLine()) != null)&#123;</span><br><span class="line">        bw.write(str);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line">&#125;    </span><br><span class="line">bw.close();  </span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：字符编码</p><ul><li>编码表的由来<br>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</li><li>常见的编码表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ASCII：美国标准信息交换码。</span><br><span class="line">用一个字节的7位可以表示。</span><br><span class="line"></span><br><span class="line">ISO8859-1：拉丁码表。欧洲码表</span><br><span class="line">用一个字节的8位表示。</span><br><span class="line"></span><br><span class="line">GB2312：中国的中文编码表。</span><br><span class="line"></span><br><span class="line">GBK：中国的中文编码表升级，融合了更多的中文文字符号。</span><br><span class="line"></span><br><span class="line">Unicode：国际标准码，融合了多种文字。</span><br><span class="line">所有文字都用两个字节来表示,Java语言使用的就是unicode</span><br><span class="line">UTF-8：最多用三个字节来表示一个字符</span><br><span class="line"></span><br><span class="line">编码：字符串字节数组</span><br><span class="line"></span><br><span class="line">解码：字节数组字符串</span><br><span class="line"></span><br><span class="line">转换流的编码应用</span><br><span class="line">可以将字符按指定编码格式存储。</span><br><span class="line">可以对文本数据按指定编码格式来解读。</span><br><span class="line">指定编码表的动作由构造函数完成。</span><br></pre></td></tr></table></figure><h2 id="13-2-6-标准输入-输出流"><a href="#13-2-6-标准输入-输出流" class="headerlink" title="13.2.6 标准输入/输出流"></a>13.2.6 标准输入/输出流</h2><h3 id="标准输入-输出流"><a href="#标准输入-输出流" class="headerlink" title="标准输入/输出流"></a>标准输入/输出流</h3><ul><li>System.in和System.out分别代表了系统标准的输入和输出设备</li><li>默认输入设备是键盘，输出设备是显示器</li><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类<br>λ    通过System类的setIn，setOut方法对默认设备进行改变。<ul><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ul></li></ul><h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;请输入信息(退出输入e或exit):&quot;);</span><br><span class="line">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s = null;</span><br><span class="line">try &#123;</span><br><span class="line">// 读取用户输入的一行数据 --&gt; 阻塞程序</span><br><span class="line">while ((s = br.readLine()) != null) &#123;</span><br><span class="line">if (s.equalsIgnoreCase(&quot;e&quot;) || s.equalsIgnoreCase(&quot;exit&quot;)) &#123;</span><br><span class="line">System.out.println(&quot;安全退出!!&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">// 将读取到的整行字符串转成大写输出</span><br><span class="line">System.out.println(&quot;--&gt;:&quot; + s.toUpperCase());</span><br><span class="line">System.out.println(&quot;继续输入信息&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; castch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (br != null) &#123;</span><br><span class="line">br.close(); // 关闭过滤流时,会自动关闭它包装的底层节点流</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-2-7-打印流"><a href="#13-2-7-打印流" class="headerlink" title="13.2.7 打印流"></a>13.2.7 打印流</h2><ul><li>实现将基本数据类型的数据格式转化为字符串输出</li><li>打印流：PrintStream和PrintWriter<ul><li>提供了一系列重载的print和println方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>System.out返回的是PrintStream的实例</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">fos = new FileOutputStream(new File(&quot;D:\\IO\\text.txt&quot;));</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &apos;\n&apos; 时都会刷新输出缓冲区)</span><br><span class="line">PrintStream ps = new PrintStream(fos, true);</span><br><span class="line">if (ps != null) &#123; // 把标准输出流(控制台输出)改成文件</span><br><span class="line">System.setOut(ps);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符</span><br><span class="line">System.out.print((char) i);</span><br><span class="line">if (i % 50 == 0) &#123; // 每50个数据一行</span><br><span class="line">System.out.println(); // 换行</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps.close();</span><br></pre></td></tr></table></figure><h2 id="13-2-8-数据流"><a href="#13-2-8-数据流" class="headerlink" title="13.2.8 数据流"></a>13.2.8 数据流</h2><ul><li>为了方便地操作Java语言的基本数据类型的数据，可以使用数据流。</li><li>数据流有两个类：(用于读取和写出基本数据类型的数据）<ul><li>DataInputStream 和 DataOutputStream</li><li>分别“套接”在 InputStream 和 OutputStream 节点流上</li></ul></li><li>DataInputStream中的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean readBoolean()byte readByte()</span><br><span class="line">     char readChar()float readFloat()</span><br><span class="line">     double readDouble()short readShort()</span><br><span class="line">     long readLong()int readInt()</span><br><span class="line">     String readUTF()           void readFully(byte[] b)</span><br></pre></td></tr></table></figure><ul><li>DataOutputStream中的方法<br>将上述的方法的read改为相应的write即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream dos = null;</span><br><span class="line">try &#123; // 创建连接到指定文件的数据输出流对象</span><br><span class="line">dos=newDataOutputStream(new FileOutputStream(&quot;d:\\IOTest\\destData.dat&quot;));</span><br><span class="line">dos.writeUTF(&quot;ab中国&quot;); // 写UTF字符串</span><br><span class="line">dos.writeBoolean(false); // 写入布尔值</span><br><span class="line">dos.writeLong(1234567890L); // 写入长整数</span><br><span class="line">System.out.println(&quot;写文件成功!&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123; // 关闭流对象</span><br><span class="line">try &#123;</span><br><span class="line">if (dos != null) &#123;</span><br><span class="line">// 关闭过滤流时,会自动关闭它包装的底层节点流</span><br><span class="line">dos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-2-9-对象流"><a href="#13-2-9-对象流" class="headerlink" title="13.2.9 对象流"></a>13.2.9 对象流</h2><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><ul><li><p>ObjectInputStream和OjbectOutputSteam</p><ul><li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li></ul></li><li><p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</p></li><li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制<ul><li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li></ul></li></ul><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><ul><li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</li><li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li><li>序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础</li><li><p>如果需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p><ul><li>Serializable</li><li>Externalizable</li></ul></li><li><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p><ul><li>private static final long serialVersionUID;</li><li>serialVersionUID用来表明类的不同版本间的兼容性</li><li>如果类没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的源代码作了修改，serialVersionUID 可能发生变化。故建议，显示声明</li></ul></li><li><p>显示定义serialVersionUID的用途</p><ul><li>希望类的不同版本对序列化兼容，因此需确保类的不同版本具有相同的serialVersionUID</li><li>不希望类的不同版本对序列化兼容，因此需确保类的不同版本具有不同的serialVersionUID</li></ul></li></ul><h3 id="使用对象流序列化对象"><a href="#使用对象流序列化对象" class="headerlink" title="使用对象流序列化对象"></a>使用对象流序列化对象</h3><ul><li><p>若某个类实现了 Serializable 接口，该类的对象就是可序列化的：</p><ul><li>创建一个 ObjectOutputStream</li><li>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象。注意写出一次，操作flush()</li></ul></li><li><p>反序列化</p><ul><li>创建一个 ObjectInputStream</li><li>调用 readObject() 方法读取流中的对象</li></ul></li><li><p>强调：如果某个类的字段不是基本数据类型或 String  类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的 Field 的类也不能序列化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = </span><br><span class="line">new ObjectOutputStream(new FileOutputStream(&quot;test3.txt&quot;));</span><br><span class="line">Person p = new Person(&quot;韩梅梅&quot;, 18, &quot;中华大街&quot;, new Pet());</span><br><span class="line">oos.writeObject(p);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line">// 反序列化：将磁盘中的对象数据源读出。</span><br><span class="line">ObjectInputStream ois = </span><br><span class="line">new ObjectInputStream(new FileInputStream(&quot;test3.txt&quot;));</span><br><span class="line">Person p1 = (Person) ois.readObject();</span><br><span class="line">System.out.println(p1.toString());</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><h2 id="13-2-10-随机存取文件流"><a href="#13-2-10-随机存取文件流" class="headerlink" title="13.2.10 随机存取文件流"></a>13.2.10 随机存取文件流</h2><h3 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h3><ul><li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件<ul><li>支持只访问文件的部分内容</li><li>可以向已存在的文件后追加内容</li></ul></li></ul><ul><li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针：<ul><li>long getFilePointer()：获取文件记录指针的当前位置</li><li>void seek(long pos)：将文件记录指针定位到 pos 位置</li></ul></li></ul><h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = new RandomAccessFile(“test.txt”, “rw”）;raf.seek(5);</span><br><span class="line">byte [] b = new byte[1024];</span><br><span class="line">int off = 0;</span><br><span class="line">int len = 5;</span><br><span class="line">raf.read(b, off, len);</span><br><span class="line"></span><br><span class="line">String str = new String(b, 0, len);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure><h3 id="写入文件内容"><a href="#写入文件内容" class="headerlink" title="写入文件内容"></a>写入文件内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = new RandomAccessFile(&quot;test.txt&quot;, &quot;rw&quot;);</span><br><span class="line">raf.seek(5);</span><br><span class="line"></span><br><span class="line">//先读出来</span><br><span class="line">String temp = raf.readLine();</span><br><span class="line"></span><br><span class="line">raf.seek(5);</span><br><span class="line">raf.write(&quot;xyz&quot;.getBytes());</span><br><span class="line">raf.write(temp.getBytes());</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure><h2 id="13-2-11-流的基本应用小节"><a href="#13-2-11-流的基本应用小节" class="headerlink" title="13.2.11 流的基本应用小节"></a>13.2.11 流的基本应用小节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">流是用来处理数据的。</span><br><span class="line"></span><br><span class="line">处理数据时，一定要先明确数据源，与数据目的地</span><br><span class="line">数据源可以是文件，可以是键盘。</span><br><span class="line">数据目的地可以是文件、显示器或者其他设备。</span><br><span class="line"></span><br><span class="line">而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、转换处理等。</span><br><span class="line"></span><br><span class="line">字节流-缓冲流（重点）</span><br><span class="line">输入流InputStream-FileInputStream-BufferedInputStream</span><br><span class="line">输出流OutputStream-FileOutputStream-BufferedOutputStream</span><br><span class="line"></span><br><span class="line">字符流-缓冲流（重点）</span><br><span class="line">输入流Reader-FileReader-BufferedReader</span><br><span class="line">输出流Writer-FileWriter-BufferedWriter</span><br><span class="line"></span><br><span class="line">转换流</span><br><span class="line">InputSteamReader和OutputStreamWriter</span><br><span class="line"></span><br><span class="line">对象流ObjectInputStream和ObjectOutputStream（难点）</span><br><span class="line">序列化</span><br><span class="line">反序列化</span><br><span class="line"></span><br><span class="line">随机存取流RandomAccessFile（掌握读取、写入）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;13-1-File类的使用&quot;&gt;&lt;a href=&quot;#13-1-File类的使用&quot; class=&quot;headerlink&quot; title=&quot;13.1 File类的使用&quot;&gt;&lt;/a&gt;13.1 File类的使用&lt;/h1&gt;&lt;h2 id=&quot;13-1-1-File类&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>12. JavaSE-泛型</title>
    <link href="http://yoursite.com/2017/01/15/12.%20JavaSE-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/01/15/12. JavaSE-泛型/</id>
    <published>2017-01-14T16:00:00.000Z</published>
    <updated>2019-06-04T01:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-1-泛型的概念"><a href="#12-1-泛型的概念" class="headerlink" title="12.1 泛型的概念"></a>12.1 泛型的概念</h1><p>泛型：标签<br>举例：  </p><blockquote><ul><li>超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li><li>中药店，每个抽屉外面贴着标签</li></ul></blockquote><ul><li>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<e>，List<e>，ArrayList<e>   这个<e>就是类型参数，即泛型</e></e></e></e></li><li>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<string>，这表明该List只能保存字符串类型的对象。</string></li><li>所谓泛型，就是允许在定义类、接口时指定类型参数（我们称为类型形参），这个类型形参将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</li></ul><h2 id="12-1-1-为什么要使用泛型"><a href="#12-1-1-为什么要使用泛型" class="headerlink" title="12.1.1 为什么要使用泛型"></a>12.1.1 为什么要使用泛型</h2><p>那么为什么要有泛型呢，直接Object不是也可以存储数据吗？<br>1 解决元素存储的安全性问题，好比商品、药品标签，不会弄错<br>2 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603111458.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603111516.png" alt></p><p>泛型就是为了解决哪种在声明时不能确定类型，但在使用时才能确定类型的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*ArrayList list = new ArrayList();</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(&quot;java&quot;);</span><br><span class="line">list.add(2);</span><br><span class="line"></span><br><span class="line">//麻烦</span><br><span class="line">int i = (int) list.get(0);</span><br><span class="line">//不安全</span><br><span class="line">int j = (int) list.get(1);*/</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);</span><br><span class="line">//list.add(&quot;java&quot;);//类型检查，安全   在编译期间就确保类型安全</span><br><span class="line">list.add(2);</span><br><span class="line"></span><br><span class="line">//省事</span><br><span class="line">int i = list.get(0);</span><br><span class="line">int j = list.get(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-1-2-掌握集合中的泛型使用"><a href="#12-1-2-掌握集合中的泛型使用" class="headerlink" title="12.1.2 掌握集合中的泛型使用"></a>12.1.2 掌握集合中的泛型使用</h2><h1 id="12-2-自定义泛型"><a href="#12-2-自定义泛型" class="headerlink" title="12.2 自定义泛型"></a>12.2 自定义泛型</h1><h2 id="泛型字母"><a href="#泛型字母" class="headerlink" title="泛型字母"></a>泛型字母</h2><ul><li>形式类型参数（formal type parameters）即泛型字母</li><li>命名：泛型字母可以随意指定，尽量使用单个的大写字母（有时候多个泛型类型时会加上数字，比如T1，T2）</li><li>常见字母（见名知意）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T：Type</span><br><span class="line">K V：Key Value</span><br><span class="line">E：Element</span><br></pre></td></tr></table></figure><h2 id="12-2-1-泛型声明形式之一：泛型类、接口"><a href="#12-2-1-泛型声明形式之一：泛型类、接口" class="headerlink" title="12.2.1  泛型声明形式之一：泛型类、接口"></a>12.2.1  泛型声明形式之一：泛型类、接口</h2><p>需求：定义学生类，其中有学生成绩</p><ul><li>整数</li><li>小数</li><li>字符串“优秀、良好、合格、不及格”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Student&lt;T&gt;&#123;</span><br><span class="line">private String name;</span><br><span class="line">private T score;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public Student(String name, T score) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public T getScore() &#123;</span><br><span class="line">return score;</span><br><span class="line">&#125;</span><br><span class="line">public void setScore(T score) &#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;姓名：&quot; + name + &quot;, 成绩：&quot; + score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestStudentScore &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student&lt;Integer&gt; s1 = new Student&lt;Integer&gt;(&quot;张三&quot;,89);</span><br><span class="line">Integer score = s1.getScore();</span><br><span class="line"></span><br><span class="line">Student&lt;Integer&gt; s2 = new Student&lt;Integer&gt;();</span><br><span class="line">//s2.setScore(&quot;优秀&quot;);</span><br><span class="line">s2.setScore(99);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明时的要点"><a href="#声明时的要点" class="headerlink" title="声明时的要点"></a>声明时的要点</h3><ul><li>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型</li><li>在类/接口上声明的泛型不能使用在静态成员上</li><li>泛型类的构造器如下：public GenericClass(){}。</li><li>而如下是错误的：public GenericClass<e>(){}</e></li><li>泛型类在声明时还可以指定泛型的上限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.generic.classtype;</span><br><span class="line"></span><br><span class="line">public class TestPerson &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//Person&lt;Dog&gt; p = new Person&lt;Dog&gt;();</span><br><span class="line">//Person&lt;Object&gt; = new Person&lt;Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*class Human&lt;T super Person&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;*/</span><br><span class="line">class Person&lt;T extends Person&gt;&#123;</span><br><span class="line">private T parnter;//伴侣</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Man extends Person&lt;Woman&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Woman extends Person&lt;Man&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Dog&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定时的要点"><a href="#指定时的要点" class="headerlink" title="指定时的要点"></a>指定时的要点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当类或接口被使用时，会使用具体的实际类型参数（actual type argument）代替</span><br><span class="line">泛型的指定中不能使用基本数据类型，可以使用包装类替换</span><br><span class="line">泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（1）ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();  </span><br><span class="line">声明集合变量或创建集合对象，指定泛型</span><br><span class="line">（2）class Dog implements Comparable&lt;Dog&gt;&#123;...&#125;  </span><br><span class="line">实现接口时，指定泛型</span><br><span class="line">（3）public void test(ArrayList&lt;Student&gt; list)&#123;&#125;  </span><br><span class="line">使用泛型类或接口作为形参时，此处指定为学生类型</span><br><span class="line">（4）public void test(ArrayList&lt;?&gt; list)&#123;&#125;     </span><br><span class="line">使用泛型类或接口作为形参时，此处指定为任意类型</span><br><span class="line">（5）public void test(ArrayList&lt;? extends Person&gt; </span><br><span class="line">使用泛型类或接口作为形参时，此处指定为Person或其子类</span><br><span class="line">（6）public void test(ArrayList&lt;? super Son&gt;    </span><br><span class="line">使用泛型类或接口作为形参时，此处指定为Son或其父类</span><br></pre></td></tr></table></figure><h3 id="关于泛型类-接口的继承-实现说明"><a href="#关于泛型类-接口的继承-实现说明" class="headerlink" title="关于泛型类/接口的继承/实现说明"></a>关于泛型类/接口的继承/实现说明</h3><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p><ul><li>子类不保留父类的泛型：按需实现</li></ul><blockquote><ul><li>没有类型  擦除</li><li>具体类型</li></ul></blockquote><ul><li>子类保留父类的泛型：泛型子类<blockquote><ul><li>全部保留</li><li>部分保留        </li></ul></blockquote></li></ul><p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Father&lt;T1,T2&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//子类不保留父类的泛型</span><br><span class="line">//1)没有类型  擦除</span><br><span class="line">class Son extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2)具体类型</span><br><span class="line">class Son2 extends Father&lt;Integer,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//子类保留父类的泛型</span><br><span class="line">//1)全部保留</span><br><span class="line">class Son3&lt;T1,T2&gt; extends Father&lt;T1,T2&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//2)部分保留</span><br><span class="line">class Son4&lt;T2&gt; extends Father&lt;Integer,T2&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Father&lt;T1,T2&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//子类不保留父类的泛型</span><br><span class="line">//1)没有类型  擦除</span><br><span class="line">class Son&lt;A,B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//2)具体类型</span><br><span class="line">class Son2&lt;A,B&gt; extends Father&lt;Integer,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//子类保留父类的泛型</span><br><span class="line">//1)全部保留</span><br><span class="line">class Son3&lt;T1,T2,A,B&gt; extends Father&lt;T1,T2&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//2)部分保留</span><br><span class="line">class Son4&lt;T2,A,B&gt; extends Father&lt;Integer,T2&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Dog implements Comparable&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Object o) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Cat implements Comparable&lt;Cat&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Cat o) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MySet&lt;E&gt; implements Collection&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于泛型的擦除说明"><a href="#关于泛型的擦除说明" class="headerlink" title="关于泛型的擦除说明"></a>关于泛型的擦除说明</h3><p>使用泛型类时未指定泛型的具体类型：类似于Object，不等同于Object</p><ul><li>泛型擦除，默认按照Object处理但编译不会类型检查</li><li>明确指定Object，编译会按Object类型检查</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TestGenericErasure &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//1、使用时：类似于Object，不等同于Object</span><br><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">//list.add(new Date());//有风险</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">test(list);//泛型擦除，编译不会类型检查</span><br><span class="line"></span><br><span class="line">//ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;();</span><br><span class="line">//test(list2);//一旦指定Object，编译会类型检查，必须按照Object处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void test(ArrayList&lt;String&gt; list)&#123;</span><br><span class="line">String str = &quot;&quot;;</span><br><span class="line">for(String s:list)&#123;</span><br><span class="line">str += s + &quot;,&quot;;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;元素:&quot;+str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-2-泛型形式之二：泛型方法"><a href="#12-2-2-泛型形式之二：泛型方法" class="headerlink" title="12.2.2 泛型形式之二：泛型方法"></a>12.2.2 泛型形式之二：泛型方法</h2><ul><li>如果某个类不是泛型类，而某个方法需要使用泛型</li><li>如果某个类是泛型类，但是需要在静态方法上使用泛型</li></ul><h3 id="泛型方法的格式："><a href="#泛型方法的格式：" class="headerlink" title="泛型方法的格式："></a>泛型方法的格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问权限]  &lt;泛型字母&gt;  返回类型  方法名([泛型字母 参数名称])  抛出的异常</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.generic.method;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestMyArrays &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer[] arr = &#123;1,2,3,4&#125;;</span><br><span class="line">String str = MyArrays.toString(arr);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyArrays&#123;</span><br><span class="line">public static &lt;T&gt; String toString(T[] arr)&#123;</span><br><span class="line">String str = &quot;[&quot;;</span><br><span class="line">int i = 0;</span><br><span class="line">for (T t : arr) &#123;</span><br><span class="line">str += t;</span><br><span class="line">if(i!=arr.length-1)&#123;</span><br><span class="line">str += &quot;,&quot;;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">str += &quot;]&quot;;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例：java-util-Arrays类"><a href="#示例：java-util-Arrays类" class="headerlink" title="示例：java.util.Arrays类"></a>示例：java.util.Arrays类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br><span class="line">注意：Arrays.asList(…) 方法返回的 List 集合既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…)  返回值是一个固定长度的 List 集合</span><br><span class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</span><br><span class="line">public static &lt;T&gt; T[] copyOfRange(T[] original, int from,int to)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;);</span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(1,2,3);</span><br><span class="line"></span><br><span class="line">//public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</span><br><span class="line">String[] str = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;</span><br><span class="line">String[] array = Arrays.copyOf(str, 10);</span><br><span class="line"></span><br><span class="line">//public static &lt;T&gt; T[] copyOfRange(T[] original, int from,int to)</span><br><span class="line">String[] as = Arrays.copyOfRange(array, 0, 3);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line">System.out.println(Arrays.toString(as));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>泛型方法可以是静态方法也可以是非静态方法</li><li>泛型方法声明泛型时也可以指定上限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.generic.method;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestMyArrays &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(4);</span><br><span class="line">list.add(5);</span><br><span class="line">list.add(1);</span><br><span class="line">MyArrays.sort(list);</span><br><span class="line"></span><br><span class="line">for (Integer integer : list) &#123;</span><br><span class="line">System.out.println(integer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class MyArrays&#123;</span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(List&lt;T&gt; list)&#123;</span><br><span class="line">for(int i=0; i&lt;list.size()-1; i++)&#123;</span><br><span class="line">for(int j=0; j&lt;list.size()-i-1; j++)&#123;</span><br><span class="line">Comparable&lt;T&gt; c1 = (Comparable&lt;T&gt;)list.get(j);</span><br><span class="line">if(c1.compareTo(list.get(j+1))&lt;0)&#123;</span><br><span class="line">T temp = list.get(j);</span><br><span class="line">list.set(j, list.get(j+1));</span><br><span class="line">list.set(j+1, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*test(new String());</span><br><span class="line">test(new Object());*/</span><br><span class="line">test(new Person());</span><br><span class="line">test(new Man());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T extends Person&gt; void test(T t)&#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*public static &lt;T super Person&gt; void test(T t)&#123;</span><br><span class="line">//错误</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Man extends Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Closeable&gt; void free(T... t)&#123;</span><br><span class="line">for(T c : t)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(c!=null)&#123;</span><br><span class="line">c.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-3-泛型通配符"><a href="#12-3-泛型通配符" class="headerlink" title="12.3 泛型通配符"></a>12.3 泛型通配符</h1><ul><li>只能用于声明变量|形参上，一般是形参类型上，表示可以接收任意</li><li>不能用在<ul><li>1、创建对象，即new 后面</li><li>2、声明泛型类、泛型接口，即class和interface</li><li>3、声明泛型方法，即返回值类型前面&lt;&gt;中</li></ul></li></ul><h2 id="1、匹配任意类型的通配符"><a href="#1、匹配任意类型的通配符" class="headerlink" title="1、匹配任意类型的通配符"></a>1、匹配任意类型的通配符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * ?  通配符，类型不确定</span><br><span class="line"> * 1、用于声明变量|形参上</span><br><span class="line"> * 不能用在</span><br><span class="line"> * 1、创建对象</span><br><span class="line"> * 2、声明泛型类、泛型接口、泛型方法</span><br><span class="line"> */</span><br><span class="line">public class TestGenericWildcard &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ArrayList&lt;?&gt; list = new ArrayList();</span><br><span class="line">list = new ArrayList&lt;String&gt;();</span><br><span class="line">list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">list = Collections.list(new StringTokenizer(&quot;this is a test&quot;));</span><br><span class="line">//但是此list不能添加任意类型的对象，除了null</span><br><span class="line">list.add(null);</span><br><span class="line">//list.add(&quot;&quot;);//因为?类似于Object,但不等价与Object，所以还是类型不确定，所以除了null可以给任意引用类型之外，其他类型对象都不能随便赋</span><br><span class="line">Object obj = list.get(0);//可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line">test(new ArrayList&lt;Object&gt;());</span><br><span class="line">test(new ArrayList&lt;String&gt;());</span><br><span class="line">test(new ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">//编译错误：不能用在创建对象上，右边属于创建集合对象</span><br><span class="line">//ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;();</span><br><span class="line">&#125;</span><br><span class="line">public static void test(ArrayList&lt;?&gt; list)&#123;</span><br><span class="line">list.add(null);</span><br><span class="line">//list.add(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span><br><span class="line">//public static &lt;?&gt; void test(ArrayList&lt;?&gt; list)&#123;</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译错误：不能用在泛型类的声明上</span><br><span class="line">/*class GenericTypeClass&lt;?&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure><h2 id="2、受限泛型：上限、下限"><a href="#2、受限泛型：上限、下限" class="headerlink" title="2、受限泛型：上限、下限"></a>2、受限泛型：上限、下限</h2><h3 id="（1）通配符指定上限"><a href="#（1）通配符指定上限" class="headerlink" title="（1）通配符指定上限"></a>（1）通配符指定上限</h3><p>上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= ，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends Person</span><br><span class="line">? extends Comparable</span><br></pre></td></tr></table></figure><h4 id="满足以下规则"><a href="#满足以下规则" class="headerlink" title="满足以下规则"></a>满足以下规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Fruit&gt; 满足 List&lt;? extends Fruit&gt;</span><br><span class="line">List&lt;Apple&gt; 满足 List&lt;? extends Fruit&gt;</span><br><span class="line">List&lt;FujiApple&gt; 满足 List&lt;? extends Fruit&gt;</span><br><span class="line">List&lt;? extends Apple&gt; 满足 List&lt;? extends Fruit&gt;</span><br><span class="line">List&lt;?&gt; 不满足 List&lt;? extends Fruit&gt; 因为List&lt;?&gt; 等价于List&lt;? extends Object&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ArrayList&lt;Fruit&gt; list1= new ArrayList&lt;Fruit&gt;();</span><br><span class="line">test(list1);</span><br><span class="line">ArrayList&lt;Apple&gt; list2= new ArrayList&lt;Apple&gt;();</span><br><span class="line">test(list2);</span><br><span class="line">ArrayList&lt;FujiApple&gt; list3= new ArrayList&lt;FujiApple&gt;();</span><br><span class="line">test(list3);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;? extends Fruit&gt; list= new ArrayList&lt;Fruit&gt;();</span><br><span class="line">test(list);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;? extends Apple&gt; list4= new ArrayList&lt;FujiApple&gt;();</span><br><span class="line">test(list4);</span><br><span class="line">ArrayList&lt;? extends Apple&gt; list5= new ArrayList&lt;Apple&gt;();</span><br><span class="line">test(list5);</span><br><span class="line"></span><br><span class="line">//编译错误，因为ArrayList&lt;?&gt;类似于ArrayList&lt;? extends Object&gt;</span><br><span class="line">//而且list6有可能赋值new ArrayList&lt;String&gt;();</span><br><span class="line">//而且list6有可能赋值new ArrayList&lt;Object&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list6 = new ArrayList();</span><br><span class="line">//test(list6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void test(ArrayList&lt;? extends Fruit&gt; list)&#123;</span><br></pre></td></tr></table></figure><p>如果使用“？ extends  类型”接收泛型对象的时候，则不能设置被泛型指定的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void test(ArrayList&lt;? extends Fruit&gt; list)&#123;</span><br><span class="line">/*</span><br><span class="line"> * 通通编译错误</span><br><span class="line"> * 只能接收使用，不能修改</span><br><span class="line"> * 因为不知道list最终传入的到底是什么样的集合</span><br><span class="line">list.add(new Fruit());</span><br><span class="line">list.add(new Apple());</span><br><span class="line">list.add(new Peach());*/</span><br><span class="line"></span><br><span class="line">//此处只能是Fruit或以上，不能是Apple等子类，因为可能传入的是ArrayList&lt;Fruit&gt;或ArrayList&lt;Peach&gt;</span><br><span class="line">for(Fruit f:list)&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Iterator只能使用Iterator&lt;?&gt;或Iterator&lt;? extends Fruit&gt;</span><br><span class="line">Iterator&lt;? extends Fruit&gt; iter = list.iterator();</span><br><span class="line">          // Iterator&lt;Fruit&gt; iter = list.iterator();//编译错误，因为泛型不支持多态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）通配符指定下限"><a href="#（2）通配符指定下限" class="headerlink" title="（2）通配符指定下限"></a>（2）通配符指定下限</h3><p>下限super：使用时指定的类型不能小于操作的类，即&gt;=，如<br>? super Apple<br>存在以下规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Apple&gt;  满足 ArrayList&lt;? super Apple&gt;</span><br><span class="line">ArrayList&lt;Fruit&gt;  满足 ArrayList&lt;? super Apple&gt;</span><br><span class="line">ArrayList&lt;Object&gt;  满足 ArrayList&lt;? super Apple&gt;</span><br><span class="line">ArrayList&lt;? super Apple&gt; 满足 ArrayList&lt;? super Apple&gt;</span><br><span class="line">ArrayList&lt;? super Fruit&gt; 满足 ArrayList&lt;? super Apple&gt;</span><br><span class="line">ArrayList&lt;?&gt; 不满足 ArrayList&lt;? super Apple&gt;因为List&lt;?&gt; 等价于List&lt;? extends Object&gt;，那么可能ArrayList&lt;String&gt;</span><br><span class="line">ArrayList&lt;? super FujiApple&gt; 不满足 ArrayList&lt;? super Apple&gt; 因为可能ArrayList&lt; FujiApple&gt;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ArrayList&lt;Apple&gt; list1= new ArrayList&lt;Apple&gt;();</span><br><span class="line">test(list1);</span><br><span class="line">ArrayList&lt;Fruit&gt; list2= new ArrayList&lt;Fruit&gt;();</span><br><span class="line">test(list2);</span><br><span class="line">ArrayList&lt;Object&gt; list3= new ArrayList&lt;Object&gt;();</span><br><span class="line">test(list3);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;? super Apple&gt; list4= new ArrayList&lt;Apple&gt;();</span><br><span class="line">test(list4);</span><br><span class="line">ArrayList&lt;? super Fruit&gt; list5= new ArrayList&lt;Fruit&gt;();</span><br><span class="line">test(list5);</span><br><span class="line">ArrayList&lt;? super Fruit&gt; list6= new ArrayList&lt;Object&gt;();</span><br><span class="line">test(list6);</span><br><span class="line">//编译错误</span><br><span class="line">/*ArrayList&lt;? super FujiApple&gt; list= new ArrayList&lt;FujiApple&gt;();</span><br><span class="line">test(list);*/</span><br><span class="line"></span><br><span class="line">////编译错误，因为FujiApple是Apple的子类</span><br><span class="line">//ArrayList&lt;? super Apple&gt; list7= new ArrayList&lt;FujiApple&gt;();</span><br><span class="line">//test(list7);</span><br><span class="line"></span><br><span class="line">//编译错误，因为ArrayList&lt;?&gt;类似于ArrayList&lt;? extends Object&gt;</span><br><span class="line">//而且list8有可能赋值new ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list8 = new ArrayList();</span><br><span class="line">//test(list8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void test(ArrayList&lt;? super Apple&gt; list)&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果使用“？ super类型”接收泛型对象的时候，则能够添加数据，但是不能添加父对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void test(ArrayList&lt;? super Apple&gt; list)&#123;</span><br><span class="line">/*</span><br><span class="line"> * 通通编译错误</span><br><span class="line"> * 只能接收本类或子类对象</span><br><span class="line"> * 因为不知道list最终传入的到底是什么样的集合，如果传入的是ArrayList&lt;Apple&gt;，那添加Fruit对象就有问题了*/</span><br><span class="line">list.add(new FujiApple());</span><br><span class="line">list.add(new Apple());</span><br><span class="line">//list.add(new Fruit());</span><br><span class="line"></span><br><span class="line">//此处只能是Object,不能是Apple,Fruit，因为可能传入的是ArrayList&lt;Object&gt;</span><br><span class="line">for(Object a:list)&#123;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-4-泛型嵌套：由外到内分析"><a href="#12-4-泛型嵌套：由外到内分析" class="headerlink" title="12.4 泛型嵌套：由外到内分析"></a>12.4 泛型嵌套：由外到内分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">HashMap&lt;String,ArrayList&lt;Citizen&gt;&gt; map = new HashMap&lt;String,ArrayList&lt;Citizen&gt;&gt;();</span><br><span class="line">ArrayList&lt;Citizen&gt; list = new ArrayList&lt;Citizen&gt;();</span><br><span class="line">list.add(new Citizen(&quot;刘恺威&quot;));</span><br><span class="line">list.add(new Citizen(&quot;杨幂&quot;));</span><br><span class="line">list.add(new Citizen(&quot;小糯米&quot;));</span><br><span class="line">map.put(&quot;刘恺威&quot;, list);</span><br><span class="line"></span><br><span class="line">Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; next = iterator.next();</span><br><span class="line">String key = next.getKey();</span><br><span class="line">ArrayList&lt;Citizen&gt; value = next.getValue();</span><br><span class="line">System.out.println(&quot;户主：&quot;+key);</span><br><span class="line">System.out.println(&quot;家庭成员：&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-5-泛型的特殊点"><a href="#12-5-泛型的特殊点" class="headerlink" title="12.5 泛型的特殊点"></a>12.5 泛型的特殊点</h1><h2 id="1、泛型没有多态"><a href="#1、泛型没有多态" class="headerlink" title="1、泛型没有多态"></a>1、泛型没有多态</h2><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<b>并不是G<a>的子类型！<br>比如：</a></b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String是Object的子类，但是List&lt;String &gt;并不是List&lt;Object&gt;的子类。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603113046.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Fruit f = new Apple();//多态</span><br><span class="line">//泛型没有多态</span><br><span class="line">//ArrayList&lt;Fruit&gt; list = new ArrayList&lt;Apple&gt;();//泛型没有多态</span><br><span class="line">ArrayList&lt;? extends Fruit&gt; list = new ArrayList&lt;Apple&gt;();//使用通配符可以</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、没有泛型数组"><a href="#2、没有泛型数组" class="headerlink" title="2、没有泛型数组"></a>2、没有泛型数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestGenericPolymophism &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//泛型没有数组</span><br><span class="line">//Tiger&lt;String&gt;[] as = new Tiger&lt;String&gt;[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Tiger&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ArrayList源代码</span><br><span class="line">public class ArrayList&lt;E&gt;  。。。&#123;</span><br><span class="line">    transient Object[] elementData;</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、jdk1-7简化泛型"><a href="#3、jdk1-7简化泛型" class="headerlink" title="3、jdk1.7简化泛型"></a>3、jdk1.7简化泛型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//jdk1.7，泛型的简化操作</span><br><span class="line">ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="4、不能在try-catch中使用泛型定义"><a href="#4、不能在try-catch中使用泛型定义" class="headerlink" title="4、不能在try-catch中使用泛型定义"></a>4、不能在try-catch中使用泛型定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">&#125;catch(T t)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-6-Collections工具类"><a href="#12-6-Collections工具类" class="headerlink" title="12.6 Collections工具类"></a>12.6 Collections工具类</h1><ul><li>参考操作数组的工具类：Arrays</li><li>Collections 是一个操作 Set、List 和 Map 等集合的工具类</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li></ul><ul><li>排序操作：（均为static方法）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements)</span><br><span class="line">将所有指定元素添加到指定 collection 中。</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)</span><br><span class="line">在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象</span><br><span class="line">，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)</span><br><span class="line">在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，</span><br><span class="line">而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</span><br><span class="line"></span><br><span class="line">public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</span><br><span class="line">在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)</span><br><span class="line">在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，</span><br><span class="line"></span><br><span class="line">public static void reverse</span><br><span class="line">反转指定列表List中元素的顺序。</span><br><span class="line"></span><br><span class="line">public static void shuffle(List&lt;?&gt; list) List</span><br><span class="line">集合元素进行随机排序，类似洗牌</span><br><span class="line"></span><br><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</span><br><span class="line">根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)</span><br><span class="line">根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line"></span><br><span class="line">public static void swap(List&lt;?&gt; list,int i,int j)</span><br><span class="line">将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br><span class="line"></span><br><span class="line">public static int frequency(Collection&lt;?&gt; c,Object o)</span><br><span class="line">返回指定集合中指定元素的出现次数</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)</span><br><span class="line">将src中的内容复制到dest中</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)</span><br><span class="line">使用新值替换 List 对象的所有旧值</span><br><span class="line"></span><br><span class="line">Collections 类中提供了多个 synchronizedXxx() 方法，</span><br><span class="line">该方法可使将指定集合包装成线程同步的集合</span><br><span class="line">，从而可以解决多线程并发访问集合时的线程安全问题</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;12-1-泛型的概念&quot;&gt;&lt;a href=&quot;#12-1-泛型的概念&quot; class=&quot;headerlink&quot; title=&quot;12.1 泛型的概念&quot;&gt;&lt;/a&gt;12.1 泛型的概念&lt;/h1&gt;&lt;p&gt;泛型：标签&lt;br&gt;举例：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>11. JavaSE-集合</title>
    <link href="http://yoursite.com/2017/01/10/11.%20JavaSE-%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2017/01/10/11. JavaSE-集合/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2019-06-04T01:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-1-数组与集合"><a href="#11-1-数组与集合" class="headerlink" title="11.1 数组与集合"></a>11.1 数组与集合</h1><h2 id="11-1-1数组"><a href="#11-1-1数组" class="headerlink" title="11.1.1数组"></a>11.1.1数组</h2><ul><li>逻辑结构：线性的</li><li>物理结构：顺序的存储结构</li><li>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</li><li>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603084709.png" alt></p><ul><li>操作<ul><li>查询：每一个元素都有一个数值下标，可以通过下标瞬间定位到某个元素</li><li>增加：</li></ul></li></ul><blockquote><ul><li>从尾部增加：数组名[total++]=新元素</li><li>从其他位置插入：先把index位置开始所有元素后移，然后数组名[index]=新元素</li></ul></blockquote><ul><li><ul><li>删除：先把index后面的元素前移，然后数组名[total–]=null</li><li>改：直接数组名[index]=新元素</li></ul></li><li><p>优缺点</p><ul><li>优点：查询效率高</li><li>缺点：添加/删除效率低，因为都涉及到移动元素；无法直接获取有效元素的个数，需要total来辅助</li></ul></li><li><p>使用范围：查询操作远多于插入和删除操作的场景</p></li></ul><h3 id="11-1-2集合"><a href="#11-1-2集合" class="headerlink" title="11.1.2集合"></a>11.1.2集合</h3><p>为了可以满足用户数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型。<br>总的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、只能存对象</span><br><span class="line">2、容量可以自动调节</span><br><span class="line">3、可以直接获取有效元素的个数：size()</span><br></pre></td></tr></table></figure><h4 id="1、集合的几个常用接口"><a href="#1、集合的几个常用接口" class="headerlink" title="1、集合的几个常用接口"></a>1、集合的几个常用接口</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603101859.png" alt></p><h4 id="2、详细描述"><a href="#2、详细描述" class="headerlink" title="2、详细描述"></a>2、详细描述</h4><ul><li>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 <ul><li>List：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li><li>Set：一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。 </li></ul></li></ul><blockquote><ul><li>SortedSet进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。（此接口是 SortedMap 的 set 对应接口）。 </li></ul></blockquote><ul><li>Map：将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。<ul><li>SortedMap进一步提供关于键的总体排序 的 Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。对有序映射的 collection 视图（由 entrySet、keySet 和 values 方法返回）进行迭代时，此顺序就会反映出来。要采用此排序方式，还需要提供一些其他操作（此接口是 SortedSet 的对应映射）。 </li></ul></li></ul><h4 id="3、概况总结"><a href="#3、概况总结" class="headerlink" title="3、概况总结"></a>3、概况总结</h4><ul><li>Collection接口：定义了存取一组对象的方法，其子接口Set和List分别定义了存储方式<ul><li>Set：中的数据对象没有顺序且不可以重复</li><li>List：中的数据对象有顺序且可以重复</li></ul></li></ul><ul><li>Map接口定义了存储“键（key）-值（value）映射对”的方法</li></ul><h1 id="11-2-Collection接口"><a href="#11-2-Collection接口" class="headerlink" title="11.2 Collection接口"></a>11.2 Collection接口</h1><p>Collection 层次结构 中的根接口。<br>常用方法：</p><h2 id="1、添加"><a href="#1、添加" class="headerlink" title="1、添加"></a>1、添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）add(Object obj)</span><br><span class="line">（2）addAll(Collection coll)</span><br></pre></td></tr></table></figure><h2 id="2、获取有效元素的个数"><a href="#2、获取有效元素的个数" class="headerlink" title="2、获取有效元素的个数"></a>2、获取有效元素的个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int size()</span><br></pre></td></tr></table></figure><h2 id="3、清空集合"><a href="#3、清空集合" class="headerlink" title="3、清空集合"></a>3、清空集合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void clear();</span><br></pre></td></tr></table></figure><h2 id="4、是否包含某个元素"><a href="#4、是否包含某个元素" class="headerlink" title="4、是否包含某个元素"></a>4、是否包含某个元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象</span><br><span class="line"></span><br><span class="line">coll.add(&quot;柴林燕&quot;);</span><br><span class="line">coll.contains(&quot;柴林燕&quot;)  true</span><br><span class="line"></span><br><span class="line">本质上是拿集合中的元素与”柴林燕”比较，如果存在就会出现&quot;柴林燕&quot;.equals(&quot;柴林燕&quot;)所以返回true，</span><br><span class="line">因为String类对equals进行了重写，表示比较的字符串的内容</span><br><span class="line"></span><br><span class="line">coll.add(new Student(&quot;柴林燕&quot;))</span><br><span class="line">coll.contains(new Student(&quot;柴林燕&quot;)) false</span><br><span class="line">本质上调用new Student(&quot;柴林燕&quot;).equals(new Student(&quot;柴林燕&quot;)) </span><br><span class="line">用的是Student类中equals，而这个没有重写equals，用的是父类Object的equals，</span><br><span class="line">默认比较的是地址值和“==”等价，所以返回false</span><br><span class="line"> </span><br><span class="line">（2）boolean containsAll(Collection c)也是调用元素的equals方法来比较的。</span><br><span class="line">拿两个集合的元素挨个比较。</span><br></pre></td></tr></table></figure><h2 id="5、是否空集合"><a href="#5、是否空集合" class="headerlink" title="5、是否空集合"></a>5、是否空集合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isEmpty()</span><br></pre></td></tr></table></figure><h2 id="6、删除"><a href="#6、删除" class="headerlink" title="6、删除"></a>6、删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1） boolean remove(Object obj) 通过元素的equals方法判断是否是要删除的那个元素</span><br><span class="line"> 只会删除找到的第一个元素</span><br><span class="line">    只是把元素从集合删除，内存中还是存在的。</span><br><span class="line">（2）boolean removeAll(Collection coll)</span><br></pre></td></tr></table></figure><h2 id="7、取两个集合的交集"><a href="#7、取两个集合的交集" class="headerlink" title="7、取两个集合的交集"></a>7、取两个集合的交集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean retainAll(Collection c)</span><br><span class="line"></span><br><span class="line">把交集的结果存在当前集合中，不影响c</span><br></pre></td></tr></table></figure><h2 id="8、转成对象数组"><a href="#8、转成对象数组" class="headerlink" title="8、转成对象数组"></a>8、转成对象数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray()</span><br></pre></td></tr></table></figure><h1 id="11-3-集合的遍历"><a href="#11-3-集合的遍历" class="headerlink" title="11.3 集合的遍历"></a>11.3 集合的遍历</h1><h2 id="11-3-1-foreach迭代"><a href="#11-3-1-foreach迭代" class="headerlink" title="11.3.1 foreach迭代"></a>11.3.1 foreach迭代</h2><p>Java 5 提供了 foreach 循环迭代访问 Collection<br>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素的类型  迭代变量 : 数组/集合名称)&#123;</span><br><span class="line">  //迭代变量代表的是每一个元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = new ArrayList();</span><br><span class="line">coll.add(1);</span><br><span class="line">coll.add(2);</span><br><span class="line">coll.add(3);</span><br><span class="line">coll.add(4);</span><br><span class="line"></span><br><span class="line">for(Object obj : coll)&#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">//foreach循环4次，obj每一次代表一个元素</span><br><span class="line">注意：</span><br><span class="line">foreach遍历只适用于查看/查找集合中的元素，不能在遍历集合时有任何影响集合中元素个数或数据的操作，否则操作结果将不确定。</span><br><span class="line">for(Object obj : coll)&#123;</span><br><span class="line">coll.remove(obj);//错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-2-Iterator迭代"><a href="#11-3-2-Iterator迭代" class="headerlink" title="11.3.2 Iterator迭代"></a>11.3.2 Iterator迭代</h2><h3 id="1、迭代器概述"><a href="#1、迭代器概述" class="headerlink" title="1、迭代器概述"></a>1、迭代器概述</h3><ul><li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</li><li>因为Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li><li>仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603102703.png" alt></p><ul><li>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li><li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = coll.iterator();//多态引用</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">Object obj = iter.next();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">Iterator iter = coll.iterator();//回到起点</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">Object obj = iter.next();</span><br><span class="line">if(obj.equals(&quot;李四&quot;))&#123;</span><br><span class="line">iter.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法</p><h3 id="2、查看Iterator迭代器源码"><a href="#2、查看Iterator迭代器源码" class="headerlink" title="2、查看Iterator迭代器源码"></a>2、查看Iterator迭代器源码</h3><ul><li>概念：迭代器（iterator）有时又称为游标（cursor），提供一种方法访问一个容器（container）对象中各个元素，而又不需要暴露该对象的内部细节。</li><li>作用：是为容器遍历而生，用以方便的实现对容器内元素的遍历操作。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”，售票员关注公交车上的每个乘客。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603102930.png" alt></p><ul><li>走到每个座位之前，看看是否有乘客，如果有检查该乘客，如果该乘客未购票，可以请他下车，也只能请刚刚检查过的乘客下车。</li><li>每一类集合都有自己的迭代器，迭代器是为对应的集合服务的，因此迭代器都是作为对应集合的内部类定义的。</li></ul><p>示例：只摘取关键代码ArrayList的内部迭代器Itr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        int cursor;       // index of next element to return</span><br><span class="line">        int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            int i = cursor;</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            return (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -1;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="11-4-List接口"><a href="#11-4-List接口" class="headerlink" title="11.4 List接口"></a>11.4 List接口</h1><ul><li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li><li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li></ul><h2 id="11-4-1-List接口的方法"><a href="#11-4-1-List接口的方法" class="headerlink" title="11.4.1 List接口的方法"></a>11.4.1 List接口的方法</h2><ul><li>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法<ul><li>void add(int index, Object ele)</li><li>boolean addAll(int index, Collection eles)</li><li>Object get(int index)</li><li>int indexOf(Object obj)</li><li>int lastIndexOf(Object obj)</li><li>Object remove(int index)</li><li>Object set(int index, Object ele)</li><li>List subList(int fromIndex, int toIndex)</li></ul></li></ul><h2 id="11-4-2-List接口的迭代器ListIterator"><a href="#11-4-2-List接口的迭代器ListIterator" class="headerlink" title="11.4.2 List接口的迭代器ListIterator"></a>11.4.2 List接口的迭代器ListIterator</h2><p>除了foreach和Iterator迭代器之外，List 额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</p><ul><li>void add()</li><li>void set(Object obj)</li><li><p>void remove()</p></li><li><p>boolean hasPrevious()</p></li><li>Object previous()</li><li><p>int previousIndex()</p></li><li><p>boolean hasNext()</p></li><li>Object next()</li><li>int nextIndex()</li></ul><h2 id="11-4-3-List的实现类"><a href="#11-4-3-List的实现类" class="headerlink" title="11.4.3 List的实现类"></a>11.4.3 List的实现类</h2><ul><li>ArrayList：底层实现是数组，线程不安全，效率高，所以，查询块，修改、插入、删除慢</li><li>LinkedList：底层实现是链表，线程不安全，效率高。所以，查询慢，修改、插入、删除快</li><li>Vector：底层实现是数组，线程安全，效率低。但是即使为保证 List 集合线程安全，也不推荐使用Vector。</li></ul><p>ArrayList的JDK1.8之前与之后的实现区别？</p><ul><li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li><li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li></ul><h3 id="1、ArrayList与Vector的区别？"><a href="#1、ArrayList与Vector的区别？" class="headerlink" title="1、ArrayList与Vector的区别？"></a>1、ArrayList与Vector的区别？</h3><ul><li>底层都是数组，Vector默认初始容量是10，ArrayList看版本.</li><li>ArrayList扩容增加原来的50%，Vector扩容增加原来的1倍。</li><li>ArrayList线程不安全，效率高，Vector线程安全，效率低。</li><li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。<br>自学：Enumeration 迭代器的使用</li></ul><h3 id="2、LinkedList的特点"><a href="#2、LinkedList的特点" class="headerlink" title="2、LinkedList的特点"></a>2、LinkedList的特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList：双向链表，除了保存数据，还定义了两个变量：</span><br><span class="line">prev变量记录前一个元素的位置</span><br><span class="line">next变量记录下一个元素的位置</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604002932.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604003005.png" alt></p><p>例如：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604003031.png" alt></p><p><img src="http://note.youdao.com/yws/res/6876/B1A9D580AE5F46BFBDEE4663E6D0D869" alt="image"></p><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。新增方法：</p><ul><li>void addFirst(Object obj)</li><li>void addLast(Object obj)    </li><li>Object getFirst()</li><li>Object getLast()</li><li>Object removeFirst()</li><li>Object removeLast()</li></ul><h1 id="11-5-Set接口"><a href="#11-5-Set接口" class="headerlink" title="11.5 Set接口"></a>11.5 Set接口</h1><ul><li>Set接口是Collection的子接口，set接口没有提供额外的方法。</li><li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</li><li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法。因此存放到Set集合中的元素一定要注意equals方法的重写。  </li></ul><p>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p><h2 id="11-5-1-HashSet"><a href="#11-5-1-HashSet" class="headerlink" title="11.5.1 HashSet"></a>11.5.1 HashSet</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul><li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</li><li>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。</li><li>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。<ul><li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</li><li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败，如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。</li></ul></li></ul><ul><li>HashSet 具有以下特点：<ul><li>不能保证元素的排列顺序</li><li>HashSet 不是线程安全的</li><li>集合元素可以有一个是 null</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603104425.png" alt></p><p>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等）</p><p><strong>结论：存放到Set集合中的元素一定要注意equals和hashcode方法的重写。</strong></p><h3 id="2、hashCode和equals方法"><a href="#2、hashCode和equals方法" class="headerlink" title="2、hashCode和equals方法"></a>2、hashCode和equals方法</h3><p>重写equals()方法的原则：</p><ul><li>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</li><li>自反性：x.equals(x)必须返回是“true”。</li><li>类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</li><li>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。</li><li>任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。</li><li>重写 hashCode() 方法的基本原则</li><li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值</li><li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等</li><li>对象中用作 equals() 方法比较的属性Field，都应该用来计算 hashCode 值</li></ul><h2 id="11-5-2-LinkedHashSet"><a href="#11-5-2-LinkedHashSet" class="headerlink" title="11.5.2 LinkedHashSet"></a>11.5.2 LinkedHashSet</h2><ul><li>LinkedHashSet 是 HashSet 的子类</li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</li><li>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li><li>LinkedHashSet 不允许集合元素重复。</li></ul><h2 id="11-5-3-TreeSet"><a href="#11-5-3-TreeSet" class="headerlink" title="11.5.3 TreeSet"></a>11.5.3 TreeSet</h2><ul><li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</li><li>TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。</li></ul><h3 id="1、自然排序"><a href="#1、自然排序" class="headerlink" title="1、自然排序"></a>1、自然排序</h3><ul><li>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列，如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</li><li>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</li><li>因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象</li><li>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值</li><li>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过 equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则让人难以理解。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparable 的典型实现：</span><br><span class="line">BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</span><br><span class="line">Character：按字符的 unicode值来进行比较</span><br><span class="line">Boolean：true 对应的包装类实例大于 false 对应的包装类实例</span><br><span class="line">String：按字符串中字符的 unicode 值进行比较</span><br><span class="line">Date、Time：后边的时间、日期比前面的时间、日期大</span><br></pre></td></tr></table></figure><h3 id="2、定制排序"><a href="#2、定制排序" class="headerlink" title="2、定制排序"></a>2、定制排序</h3><ul><li>TreeSet的自然排序是根据集合元素的大小，进行元素升序排列。如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li><li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li><li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</li><li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li><li>当使用具有与 equals 不一致的强行排序能力的 Comparator 对有序 set（或有序映射）进行排序时，应该小心谨慎。假定一个带显式 Comparator c 的有序 set（或有序映射）与从 set S 中抽取出来的元素（或键）一起使用。如果 c 强行对 S 进行的排序是与 equals 不一致的，那么有序 set（或有序映射）将是行为“怪异的”。</li></ul><h3 id="3、结论"><a href="#3、结论" class="headerlink" title="3、结论"></a>3、结论</h3><ul><li>放到TreeSet集合中的元素必须是同一个类型的元素</li><li>放到TreeSet集合中的元素必须实现Comparable接口，重写compareTo(Object obj)方法，并且需要使得equals方法的与compareTo方法结果一直，即如果两个对象通过 equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。</li><li>TreeSet的自然排序是根据集合元素的大小，进行元素升序排列。如果需要定制排序，比如降序排列，可以将实现Comparator接口的实例作为形参传递给TreeSet的构造器，那么添加元素时，将调用compare(T o1,T o2)方法作为排序依据。同时也应该注意equals方法与compare(T o1,T o2)方法的结果一致。</li></ul><h1 id="11-6-Collection集合框架集"><a href="#11-6-Collection集合框架集" class="headerlink" title="11.6 Collection集合框架集"></a>11.6 Collection集合框架集</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603104836.png" alt></p><h1 id="11-7-Map"><a href="#11-7-Map" class="headerlink" title="11.7 Map"></a>11.7 Map</h1><h2 id="11-7-1-Map概述"><a href="#11-7-1-Map概述" class="headerlink" title="11.7.1 Map概述"></a>11.7.1 Map概述</h2><ul><li>Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value</li><li>Map 中的 key 和 value 都可以是任何引用类型的数据</li><li>Map 中的 key 不允许重复</li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li><li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。</li><li>HashMap是 Map 接口使用频率最高的实现类。</li><li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li></ul><h3 id="Map的常用方法："><a href="#Map的常用方法：" class="headerlink" title="Map的常用方法："></a>Map的常用方法：</h3><h4 id="1、添加、删除操作："><a href="#1、添加、删除操作：" class="headerlink" title="1、添加、删除操作："></a>1、添加、删除操作：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object put(Object key,Object value)</span><br><span class="line">Object remove(Object key)</span><br><span class="line">void putAll(Map t)</span><br><span class="line">void clear()</span><br></pre></td></tr></table></figure><h4 id="2、元素查询的操作："><a href="#2、元素查询的操作：" class="headerlink" title="2、元素查询的操作："></a>2、元素查询的操作：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object get(Object key)</span><br><span class="line">boolean containsKey(Object key)</span><br><span class="line">boolean containsValue(Object value)</span><br><span class="line">int size()</span><br><span class="line">boolean isEmpty()</span><br></pre></td></tr></table></figure><h4 id="3、元视图操作的方法："><a href="#3、元视图操作的方法：" class="headerlink" title="3、元视图操作的方法："></a>3、元视图操作的方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set keySet()</span><br><span class="line">Collection values()</span><br><span class="line">Set entrySet()</span><br></pre></td></tr></table></figure><h2 id="11-7-2-Map的遍历"><a href="#11-7-2-Map的遍历" class="headerlink" title="11.7.2 Map的遍历"></a>11.7.2 Map的遍历</h2><p>Collection集合的遍历： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）foreach</span><br><span class="line">（2）通过Iterator对象遍历</span><br></pre></td></tr></table></figure><p>Map的遍历，不能支持foreach</p><ul><li><p>分开遍历：</p><ul><li>单独遍历所有key，还可以根据key获取对应value</li><li>单独遍历所有value</li></ul></li><li><p>成对遍历：遍历的是映射关系Map.Entry<br>Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类<br>在Map中存储数据，实际上是将Key—-&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象，如图示： </p></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603105233.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;邢涛&quot;, 60);</span><br><span class="line">map.put(&quot;林明明&quot;, 70);</span><br><span class="line">map.put(&quot;田杰&quot;, 80);</span><br><span class="line">map.put(&quot;李铠&quot;, 90);</span><br><span class="line">map.put(&quot;李信&quot;, 60);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;map的所有key:&quot;);</span><br><span class="line">Set keys = map.keySet();//HashSet</span><br><span class="line">for(Object key : keys)&#123;</span><br><span class="line">System.out.println(key+&quot;-&gt;&quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;map的所有的value：&quot;);</span><br><span class="line">Collection values = map.values();</span><br><span class="line">Iterator iter = values.iterator();</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">System.out.println(iter.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;map所有的映射关系：&quot;);</span><br><span class="line">//映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span><br><span class="line">Set mappings = map.entrySet();</span><br><span class="line">for(Object mapping : mappings)&#123;</span><br><span class="line">//System.out.println(mapping);</span><br><span class="line">Map.Entry entry = (Map.Entry)mapping;</span><br><span class="line">System.out.println(&quot;key是：&quot;+ entry.getKey()+ &quot;，value是：&quot;+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-7-3-Map的实现类"><a href="#11-7-3-Map的实现类" class="headerlink" title="11.7.3 Map的实现类"></a>11.7.3 Map的实现类</h2><h3 id="1、HashMap"><a href="#1、HashMap" class="headerlink" title="1、HashMap"></a>1、HashMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</span><br><span class="line">HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。</span><br><span class="line">HashMap线程不安全</span><br></pre></td></tr></table></figure><h4 id="JDK1-8之前："><a href="#JDK1-8之前：" class="headerlink" title="JDK1.8之前："></a>JDK1.8之前：</h4><ul><li>HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</li><li>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603105350.png" alt></p><ul><li>HashMap的扩容<ul><li>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</li></ul></li></ul><ul><li><p>那么HashMap什么时候进行扩容呢？</p><ul><li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</li></ul></li></ul><h4 id="JDK1-8之后："><a href="#JDK1-8之后：" class="headerlink" title="JDK1.8之后："></a>JDK1.8之后：</h4><ul><li>HashMap的内部存储结构其实是数组和链表/树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</li><li>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last,或树的叶子结点。（七上八下）</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603105548.png" alt></p><p>那么HashMap什么时候进行扩容和树形化呢？</p><ul><li><p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p></li><li><p>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树在转为链表。</p></li></ul><p>关于映射关系的key是否可以修改？</p><ul><li>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</li></ul><p>HashSet的底层实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; ......&#123;</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">private static final Object PRESENT = new Object();</span><br><span class="line"></span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    public HashSet(int initialCapacity) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、LinkedHashMap"><a href="#2、LinkedHashMap" class="headerlink" title="2、LinkedHashMap"></a>2、LinkedHashMap</h3><p>LinkedHashMap 是 HashMap 的子类<br>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</p><h3 id="3、TreeMap"><a href="#3、TreeMap" class="headerlink" title="3、TreeMap"></a>3、TreeMap</h3><ul><li>TreeMap存储 Key-Value 对时，需要根据 key进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</li><li><p>TreeMap 的 Key 的排序：</p><ul><li>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li></ul></li><li><p>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。</p></li><li>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</li><li>若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。</li></ul><h3 id="4、Hashtable"><a href="#4、Hashtable" class="headerlink" title="4、Hashtable"></a>4、Hashtable</h3><ul><li>Hashtable是个古老的 Map 实现类，线程安全。</li><li>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li><li>Hashtable判断两个key相等、两个value相等的标准，与hashMap一致。</li></ul><h3 id="5、Properties"><a href="#5、Properties" class="headerlink" title="5、Properties"></a>5、Properties</h3><ul><li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li><li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</li><li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</li></ul><h2 id="11-7-4-Map集合框架集"><a href="#11-7-4-Map集合框架集" class="headerlink" title="11.7.4 Map集合框架集"></a>11.7.4 Map集合框架集</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603105930.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;11-1-数组与集合&quot;&gt;&lt;a href=&quot;#11-1-数组与集合&quot; class=&quot;headerlink&quot; title=&quot;11.1 数组与集合&quot;&gt;&lt;/a&gt;11.1 数组与集合&lt;/h1&gt;&lt;h2 id=&quot;11-1-1数组&quot;&gt;&lt;a href=&quot;#11-1-1数组&quot; cla
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>10. JavaSE-常用类</title>
    <link href="http://yoursite.com/2017/01/01/10.%20JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/01/01/10. JavaSE-常用类/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2019-06-04T01:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-1包装类Wrapper"><a href="#10-1包装类Wrapper" class="headerlink" title="10.1包装类Wrapper"></a>10.1包装类Wrapper</h1><p>学习API更深的意义在于复习面向对象的知识。查看源代码，学习源代码。</p><h2 id="10-1-1-为什么需要包装类"><a href="#10-1-1-为什么需要包装类" class="headerlink" title="10.1.1 为什么需要包装类"></a>10.1.1 为什么需要包装类</h2><p>Java并不是纯面向对象的语言。Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的。基本数据类型有它的优势：性能（效率高，节省空间）。<br>但是我们在实际使用中经常需要将基本数据类型转化成对象，便于操作。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）集合的操作，</span><br><span class="line">（2）使用Object类型接收任意类型的数据等，</span><br><span class="line">（3）泛型实参，这时，我们就需要将基本数据类型数据转化为对象。</span><br></pre></td></tr></table></figure><h2 id="10-1-2-包装类"><a href="#10-1-2-包装类" class="headerlink" title="10.1.2 包装类"></a>10.1.2 包装类</h2><p>包装类均位于java.lang包，包装类和基本数据类型的对应关系，如图10-1：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530233521.png" alt></p><p>其中有六个都是继承自java.lang.Number类：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530234032.png" alt></p><h2 id="10-1-3自动装箱（auto-boxing）与自动拆箱（unboxing）"><a href="#10-1-3自动装箱（auto-boxing）与自动拆箱（unboxing）" class="headerlink" title="10.1.3自动装箱（auto_boxing）与自动拆箱（unboxing）"></a>10.1.3自动装箱（auto_boxing）与自动拆箱（unboxing）</h2><p>JDK1.5之前需要手动装箱与拆箱，JDK1.5之后支持自动装箱与自动拆箱。</p><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title=". 自动装箱"></a>. 自动装箱</h3><p>基本数据类型就自动的封装到与它相同类型的包装中，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br></pre></td></tr></table></figure><p>本质上是，编译器编译时为我们添加了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br></pre></td></tr></table></figure><h3 id="2-自动拆箱"><a href="#2-自动拆箱" class="headerlink" title="2. 自动拆箱"></a>2. 自动拆箱</h3><p>包装类对象自动转换成基本类型数据。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = new Integer(100);</span><br></pre></td></tr></table></figure><p>本质上，编译器编译时为我们添加了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = new Integer(100).intValue();</span><br></pre></td></tr></table></figure><h2 id="10-1-4-包装类的作用"><a href="#10-1-4-包装类的作用" class="headerlink" title="10.1.4 包装类的作用"></a>10.1.4 包装类的作用</h2><h3 id="1-数据类型的范围"><a href="#1-数据类型的范围" class="headerlink" title="1 数据类型的范围"></a>1 数据类型的范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIN_VALUE、MAX_VALUE</span><br></pre></td></tr></table></figure><ul><li>Float和Double中还有正无穷大POSITIVE_INFINITY、负无穷大NEGATIVE_INFINITY，还NaN，是Not a Number的缩写。NaN 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。</li><li>程序员可以利用这种定制的 NaN 值中的特定位模式来表达某些诊断信息。</li></ul><h3 id="2-数据类型的转换"><a href="#2-数据类型的转换" class="headerlink" title="2 数据类型的转换"></a>2 数据类型的转换</h3><h4 id="1、字符串转成包装类对象"><a href="#1、字符串转成包装类对象" class="headerlink" title="1、字符串转成包装类对象"></a>1、字符串转成包装类对象</h4><p>（1）使用包装类型的构造方法<br>除了Character类型，其他7中类型都有1个构造方法，其参数是字符串类型<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer t2=new Integer(&quot;500&quot;);//参数是字符串，字符串的值是必须对应的数值</span><br><span class="line">Integer t3=new Integer(&quot;abc&quot;);// java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>（2）使用包装类的valueOf方法<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i=Integer.valueOf(&quot;500&quot;);</span><br></pre></td></tr></table></figure><h4 id="2、字符串转成基本数据类型"><a href="#2、字符串转成基本数据类型" class="headerlink" title="2、字符串转成基本数据类型"></a>2、字符串转成基本数据类型</h4><p>通过包装类的parseXxx(String s)静态方法<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i=Integer.parseInt(&quot;500&quot;);</span><br></pre></td></tr></table></figure><h3 id="3-包装类的其他方法"><a href="#3-包装类的其他方法" class="headerlink" title="3. 包装类的其他方法"></a>3. 包装类的其他方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、Integer类型</span><br><span class="line">public static String toBinaryString(int i)  //把十进制转成二进制</span><br><span class="line">public static String toHexString(int i)     //把十进制转成十六进制</span><br><span class="line">public static String toOctalString(int i)   //把十进制转成八进制</span><br><span class="line">2、Character类型</span><br><span class="line">public static char toUpperCase(char ch)  //转成大写字母</span><br><span class="line">public static char toLowerCase(char ch)  //转成小写字母</span><br><span class="line">其他的查看相关API文档即可</span><br><span class="line">3、equals</span><br><span class="line">按照包装的基本数据类型的值比较</span><br><span class="line">4、compareTo</span><br><span class="line">按照包装的基本数据类型的值比较</span><br></pre></td></tr></table></figure><h2 id="10-1-5-缓存问题"><a href="#10-1-5-缓存问题" class="headerlink" title="10.1.5 缓存问题"></a>10.1.5 缓存问题</h2><p>我们在编程时大量需要值在-128到127范围之间的Integer对象。如果只能通过new来创建，需要在堆中开辟大量值一样的Integer对象。这是相当不划算的，IntegerCache.cache很好的起到了缓存的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">缓存</span><br><span class="line">byte Byte -128–127</span><br><span class="line">short Short -128–127</span><br><span class="line">int Integer -128—127</span><br><span class="line">long Long -128—127</span><br><span class="line">float Float 不缓存</span><br><span class="line">double Double 不缓存</span><br><span class="line">char Character 0–127</span><br><span class="line">boolean Boolean TURE，FALSE</span><br></pre></td></tr></table></figure><h1 id="10-2-字符串String类"><a href="#10-2-字符串String类" class="headerlink" title="10.2 字符串String类"></a>10.2 字符串String类</h1><h2 id="10-2-1-字符串String类的特点"><a href="#10-2-1-字符串String类的特点" class="headerlink" title="10.2.1 字符串String类的特点"></a>10.2.1 字符串String类的特点</h2><p>字符串的学习，有的同学就看看API，记下方法，有的同学看看源代码，还有的同学画画图，自然学的深度是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The &#123;@code String&#125; class represents character strings. All</span><br><span class="line"> * string literals in Java programs, such as &#123;@code &quot;abc&quot;&#125;, are</span><br><span class="line"> * implemented as instances of this class.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Strings are constant; their values cannot be changed after they</span><br><span class="line"> * are created. String buffers support mutable strings.</span><br><span class="line"> * Because String objects are immutable they can be shared. For example:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> *     String str = &quot;abc&quot;;</span><br><span class="line"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;</span><br><span class="line"> * is equivalent to:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> *     char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;</span><br><span class="line"> *     String str = new String(data);</span><br><span class="line"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;</span><br><span class="line"> * Here are some more examples of how strings can be used:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> *     System.out.println(&quot;abc&quot;);</span><br><span class="line"> *     String cde = &quot;cde&quot;;</span><br><span class="line"> *     System.out.println(&quot;abc&quot; + cde);</span><br><span class="line"> *     String c = &quot;abc&quot;.substring(2,3);</span><br><span class="line"> *     String d = cde.substring(1, 2);</span><br><span class="line"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The class &#123;@code String&#125; includes methods for examining</span><br><span class="line"> * individual characters of the sequence, for comparing strings, for</span><br><span class="line"> * searching strings, for extracting substrings, and for creating a</span><br><span class="line"> * copy of a string with all characters translated to uppercase or to</span><br><span class="line"> * lowercase. Case mapping is based on the Unicode Standard version</span><br><span class="line"> * specified by the &#123;@link java.lang.Character Character&#125; class.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The Java language provides special support for the string</span><br><span class="line"> * concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of</span><br><span class="line"> * other objects to strings. String concatenation is implemented</span><br><span class="line"> * through the &#123;@code StringBuilder&#125;(or &#123;@code StringBuffer&#125;)</span><br><span class="line"> * class and its &#123;@code append&#125; method.</span><br><span class="line"> * String conversions are implemented through the method</span><br><span class="line"> * &#123;@code toString&#125;, defined by &#123;@code Object&#125; and</span><br><span class="line"> * inherited by all classes in Java. For additional information on</span><br><span class="line"> * string concatenation and conversion, see Gosling, Joy, and Steele,</span><br><span class="line"> * &lt;i&gt;The Java Language Specification&lt;/i&gt;.</span><br></pre></td></tr></table></figure><ul><li>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 </li><li>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。例如： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;</span><br></pre></td></tr></table></figure><p> 等效于： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;</span><br><span class="line">     String str = new String(data);</span><br></pre></td></tr></table></figure><p>下面给出了一些如何使用字符串的更多示例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;abc&quot;);</span><br><span class="line">     String cde = &quot;cde&quot;;</span><br><span class="line">     System.out.println(&quot;abc&quot; + cde);</span><br><span class="line">     String c = &quot;abc&quot;.substring(2,3);</span><br><span class="line">     String d = cde.substring(1, 2);</span><br></pre></td></tr></table></figure><ul><li>String 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。</li><li><p>大小写映射基于 Character 类指定的 Unicode 标准版。 </p></li><li><p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。</p></li><li>字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。</li><li>字符串转换是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。</li><li>有关字符串串联和转换的更多信息，请参阅 Gosling、Joy 和 Steele 合著的 The Java Language Specification。 </li></ul><h3 id="1-String是个final类"><a href="#1-String是个final类" class="headerlink" title="1 String是个final类"></a>1 String是个final类</h3><h3 id="2-String是不可变的字符序列"><a href="#2-String是不可变的字符序列" class="headerlink" title="2 String是不可变的字符序列"></a>2 String是不可变的字符序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br></pre></td></tr></table></figure><ul><li>String对象的字符内容是存储在一个字符数组中的。</li><li>private意味着外面无法直接获取字符数组，而且String没有提供value的get和set方法，</li><li>final意味着字符数组的引用不可改变，即通过让value指向新的数组对象来实现修改String对象，</li><li>而且String也没有提供方法来修改value数组某个元素值，因此字符串的字符数组内容也不可变。</li></ul><p>疑问？那么字符串的拼接、字符串的截取、字符串的替换等操作是如何实现的呢？<br>每次修改都创建一个新的char数组表示修改结果。</p><h3 id="3-String对象的创建"><a href="#3-String对象的创建" class="headerlink" title="3 String对象的创建"></a>3 String对象的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = “hello”;</span><br><span class="line">String  s1 = new String();   //  本质上  this.value = new char[0];</span><br><span class="line">String  s2 = new String(String original);  //this.value = original.value;</span><br><span class="line">String  s3 = new String(char[] a);  //this.value = Arrays.copyOf(value, value.length);</span><br><span class="line">String  s4 = new String(char[] a,int startIndex,int count)</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530235002.png" alt></p><h3 id="4-字符串对象是如何存储的"><a href="#4-字符串对象是如何存储的" class="headerlink" title="4 字符串对象是如何存储的"></a>4 字符串对象是如何存储的</h3><p>字符串常量存储在字符串常量池，目的是共享<br>字符串非常量对象存储在堆中。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530235346.png" alt></p><h3 id="5-String的拼接"><a href="#5-String的拼接" class="headerlink" title="5 String的拼接"></a>5 String的拼接</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530235426.png" alt></p><p>结论：<br>常量与常量的拼接结果在常量池<br>只要其中有一个是变量，结果就在堆中<br>如果拼接的结果调用intern()方法，就在常量池中</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530235538.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530235559.png" alt></p><h3 id="6、String对象的比较"><a href="#6、String对象的比较" class="headerlink" title="6、String对象的比较"></a>6、String对象的比较</h3><p><strong>==比较的是地址。</strong><br>equals比较的是字符串的内容，重写了Object的equals方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-2-String类的常用方法"><a href="#10-2-2-String类的常用方法" class="headerlink" title="10.2.2 String类的常用方法"></a>10.2.2 String类的常用方法</h2><h3 id="1、常用方法系列之一"><a href="#1、常用方法系列之一" class="headerlink" title="1、常用方法系列之一"></a>1、常用方法系列之一</h3><ul><li>int length()：返回字符串的长度： return value.length;</li><li>boolean isEmpty()：判断是否是空字符串：return value.length == 0;</li><li>String toLowerCase()：使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</li><li>String toUpperCase()：使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</li><li>String trim()：返回字符串的副本，忽略前导空白和尾部空白。</li><li>boolean equals(Object obj)：比较字符串的内容</li><li>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写</li><li>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”</li></ul><h3 id="2-String类和字符相关操作"><a href="#2-String类和字符相关操作" class="headerlink" title="2 String类和字符相关操作"></a>2 String类和字符相关操作</h3><ul><li>char charAt(int index)： 返回某索引处的字符return value[index];</li><li>char[ ] toCharArray()：将此字符串转换为一个新的字符数组</li><li>String(char[ ] value)：分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。 </li><li>String(char[ ] value, int offset, int count)：分配一个新的 String，它包含取自字符数组参数一个子数组的字符。 </li></ul><h3 id="3-String类字节与字符串操作方法"><a href="#3-String类字节与字符串操作方法" class="headerlink" title="3 String类字节与字符串操作方法"></a>3 String类字节与字符串操作方法</h3><p>编码：把字符–&gt;字节</p><ul><li>byte[ ] getBytes()：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li><li>byte[ ] getBytes(Charset charset) ：使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li><li>byte[ ] getBytes(String charsetName) ：使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>解码：把字节–&gt;字符</li><li>String(byte[] bytes) ：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 </li><li>String(byte[] bytes, Charset charset)：通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。 </li><li>String(byte[] bytes, int offset, int length) ：通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。 </li><li>String(byte[] bytes, int offset, int length, Charset charset)：通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。 </li><li>String(byte[] bytes, int offset, int length, String charsetName)：通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。 </li><li>String(byte[] bytes, String charsetName)：通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。 </li></ul><h3 id="4-String类判断是否以指定内容开头或结尾"><a href="#4-String类判断是否以指定内容开头或结尾" class="headerlink" title="4 String类判断是否以指定内容开头或结尾"></a>4 String类判断是否以指定内容开头或结尾</h3><ul><li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。 </li><li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。 </li><li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</li></ul><h3 id="5-String类字符串查找操作"><a href="#5-String类字符串查找操作" class="headerlink" title="5 String类字符串查找操作"></a>5 String类字符串查找操作</h3><ul><li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true。</li><li>int indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。 </li><li>int indexOf(int ch, int fromIndex)：返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 </li><li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引。 </li><li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 </li><li>int lastIndexOf(int ch)：返回指定字符在此字符串中最后一次出现处的索引。 </li><li>int lastIndexOf(int ch, int fromIndex)：返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 </li><li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引。 </li><li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。<br>indexOf和lastIndexOf方法如果未找到都是返回-1</li></ul><h3 id="6-String类字符串截取操作"><a href="#6-String类字符串截取操作" class="headerlink" title="6 String类字符串截取操作"></a>6 String类字符串截取操作</h3><ul><li>String substring(int beginIndex) <pre><code>返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 </code></pre></li><li>String substring(int beginIndex, int endIndex) <pre><code>返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 </code></pre></li></ul><h3 id="7-String类是否匹配正则"><a href="#7-String类是否匹配正则" class="headerlink" title="7 String类是否匹配正则"></a>7 String类是否匹配正则</h3><ul><li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str = &quot;12345&quot;;</span><br><span class="line">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span><br><span class="line">boolean matches = str.matches(&quot;\\d+&quot;);</span><br><span class="line">System.out.println(matches);</span><br><span class="line">String tel = &quot;0571-4534289&quot;;</span><br><span class="line">//判断这是否是一个杭州的固定电话</span><br><span class="line">boolean result = tel.matches(&quot;0571-\\d&#123;7,8&#125;&quot;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-String类替换操作"><a href="#8-String类替换操作" class="headerlink" title="8 String类替换操作"></a>8 String类替换操作</h3><ul><li>String replace(char oldChar, char newChar)： <pre><code>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </code></pre></li><li>String replace(CharSequence target, CharSequence replacement)： <pre><code>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </code></pre></li><li>replaceAll(String regex, String replacement)： <pre><code>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </code></pre></li><li>String replaceFirst(String regex, String replacement)： <pre><code>使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 </code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str = &quot;12hello34world5java7891mysql456&quot;;</span><br><span class="line">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span><br><span class="line">String string = str.replaceAll(&quot;\\d+&quot;, &quot;,&quot;).replaceAll(&quot;^,|,$&quot;, &quot;&quot;);</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-String类字符串拆分操作"><a href="#9-String类字符串拆分操作" class="headerlink" title="9 String类字符串拆分操作"></a>9 String类字符串拆分操作</h3><ul><li>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 </li><li>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str = &quot;hello|world|java&quot;;</span><br><span class="line">String[] strings = str.split(&quot;\\|&quot;);</span><br><span class="line">for (String string : strings) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">String str2 = &quot;hello.world.java&quot;;</span><br><span class="line">String[] strings2 = str2.split(&quot;\\.&quot;);</span><br><span class="line">for (String string : strings2) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-3-可变字符序列：字符串缓冲区"><a href="#10-3-可变字符序列：字符串缓冲区" class="headerlink" title="10.3 可变字符序列：字符串缓冲区"></a>10.3 可变字符序列：字符串缓冲区</h1><h2 id="10-3-1-StringBuffer、StringBuilder、String的区别"><a href="#10-3-1-StringBuffer、StringBuilder、String的区别" class="headerlink" title="10.3.1 StringBuffer、StringBuilder、String的区别"></a>10.3.1 StringBuffer、StringBuilder、String的区别</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531000436.png" alt></p><h3 id="1-一个类似于-String"><a href="#1-一个类似于-String" class="headerlink" title="1 一个类似于 String"></a>1 一个类似于 String</h3><p>的字符串缓冲区，但能被修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容，所有对StringBuffer或StringBuilder对象的字符序列的修改不会产生新的StringBuffer或StringBuilder对象，这点和String很大的不同。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531000517.png" alt></p><p>value没有final声明,value可以不断扩容，count记录有效字符的个数。</p><h3 id="2-StringBuilder："><a href="#2-StringBuilder：" class="headerlink" title="2 StringBuilder："></a>2 StringBuilder：</h3><p>线程安全，效率低；StringBuffer：线程不安全，效率高</p><h2 id="10-3-2-StringBuffer和StringBuilder不同的API"><a href="#10-3-2-StringBuffer和StringBuilder不同的API" class="headerlink" title="10.3.2 StringBuffer和StringBuilder不同的API"></a>10.3.2 StringBuffer和StringBuilder不同的API</h2><h3 id="1、构造器"><a href="#1、构造器" class="headerlink" title="1、构造器"></a>1、构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer或StringBuilder对象的创建必须用new+构造器。</span><br><span class="line">StringBuffer()   初始容量为16的字符串缓冲区</span><br><span class="line">StringBuffer(int size)   构造指定容量的字符串缓冲区</span><br><span class="line">StringBuffer(String str)  将内容初始化为指定字符串内容</span><br></pre></td></tr></table></figure><h3 id="2、和字符序列改变有关的方法"><a href="#2、和字符序列改变有关的方法" class="headerlink" title="2、和字符序列改变有关的方法"></a>2、和字符序列改变有关的方法</h3><p>而且所有这些方法支持方法链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串拼接</span><br><span class="line">StringBuffer delete(int start,int end)：删除指定位置的内容</span><br><span class="line">StringBuffer insert(int offset, xx)：在指定位置插入xx</span><br><span class="line">StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span><br><span class="line">StringBuffer reverse() ：把当前字符序列逆转</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StringBuffer sf = new StringBuffer();</span><br><span class="line">sf.append(&quot;hello&quot;).append(&quot;world&quot;).append(&quot;java&quot;);</span><br><span class="line">System.out.println(sf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法链的原理</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531000702.png" alt></p><p>当append和insert时，如果原来value数组长度不够，可扩容</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531000722.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531000744.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531000842.png" alt></p><h2 id="10-3-3-效率测试"><a href="#10-3-3-效率测试" class="headerlink" title="10.3.3 效率测试"></a>10.3.3 效率测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.api.string;</span><br><span class="line"></span><br><span class="line">public class TestStringBuilder &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">testStringBuilder();</span><br><span class="line">testStringBuffer();</span><br><span class="line">testString();</span><br><span class="line">&#125;</span><br><span class="line">public static void testString()&#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">String s = new String(&quot;0&quot;);</span><br><span class="line">for(int i=1;i&lt;=10000;i++)&#123;</span><br><span class="line">s += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;String拼接+用时：&quot;+(end-start));</span><br><span class="line">long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(&quot;String拼接+memory: &quot; + memory);</span><br><span class="line">&#125;</span><br><span class="line">public static void testStringBuilder()&#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">StringBuilder s = new StringBuilder(&quot;0&quot;);</span><br><span class="line">for(int i=1;i&lt;=10000;i++)&#123;</span><br><span class="line">s.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;StringBuilder拼接+用时：&quot;+(end-start));</span><br><span class="line">long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(&quot;StringBuilder拼接+memory: &quot; + memory);</span><br><span class="line">&#125;</span><br><span class="line">public static void testStringBuffer()&#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">StringBuffer s = new StringBuffer(&quot;0&quot;);</span><br><span class="line">for(int i=1;i&lt;=10000;i++)&#123;</span><br><span class="line">s.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;StringBuffer拼接+用时：&quot;+(end-start));</span><br><span class="line">long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(&quot;StringBuffer拼接+memory: &quot; + memory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-4-System系统类"><a href="#10-4-System系统类" class="headerlink" title="10.4 System系统类"></a>10.4 System系统类</h1><ul><li>System 类包含一些有用的类字段和方法。它不能被实例化。 </li><li>在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。 </li></ul><h2 id="10-4-1-标准输入、标准输出和错误输出流对象"><a href="#10-4-1-标准输入、标准输出和错误输出流对象" class="headerlink" title="10.4.1 标准输入、标准输出和错误输出流对象"></a>10.4.1 标准输入、标准输出和错误输出流对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PrintStream err：“标准”错误输出流。 </span><br><span class="line">InputStream in：“标准”输入流。 </span><br><span class="line">PrintStream out：“标准”输出流。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class TestSystem&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.print(&quot;请输入成绩：&quot;);</span><br><span class="line">int score = input.nextInt();</span><br><span class="line"></span><br><span class="line">if(score&gt;=0 &amp;&amp; score&lt;=100)&#123;</span><br><span class="line">System.out.println(&quot;成绩是：&quot; + score);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.err.println(&quot;输入有误，成绩应该在[0,100]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-2-常用方法"><a href="#10-4-2-常用方法" class="headerlink" title="10.4.2 常用方法"></a>10.4.2 常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</span><br><span class="line">long currentTimeMillis() ：返回以毫秒为单位的当前时间。  </span><br><span class="line">void exit(int status) ：终止当前正在运行的 Java 虚拟机。</span><br><span class="line">void gc()：运行垃圾回收器。  </span><br><span class="line">Properties getProperties()：确定当前的系统属性。 </span><br><span class="line">String getProperty(String key)：获取指定键指示的系统属性。 </span><br><span class="line">void setErr(PrintStream err) ：重新分配“标准”错误输出流。 </span><br><span class="line">void setIn(InputStream in)：重新分配“标准”输入流。 </span><br><span class="line">void setOut(PrintStream out)：重新分配“标准”输出流。 </span><br><span class="line">String setProperty(String key, String value) ：设置指定键指示的系统属性。</span><br></pre></td></tr></table></figure><h1 id="10-5-JDK1-8之前日期时间类"><a href="#10-5-JDK1-8之前日期时间类" class="headerlink" title="10.5 JDK1.8之前日期时间类"></a>10.5 JDK1.8之前日期时间类</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531001054.png" alt></p><h2 id="10-5-1-java-lang-System类"><a href="#10-5-1-java-lang-System类" class="headerlink" title="10.5.1 java.lang.System类"></a>10.5.1 java.lang.System类</h2><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒GMT之间以毫秒为单位的时间差。此方法适于计算时间差。</p><h2 id="10-5-2-java-util-Date"><a href="#10-5-2-java-util-Date" class="headerlink" title="10.5.2 java.util.Date"></a>10.5.2 java.util.Date</h2><p>它的对象表示一个特定的瞬间，精确到毫秒。<br>Java中时间的表示说白了也是数字，是从标准纪元1970年1月1日0时0分0秒GMT到某个时刻的毫秒数，类型是long<br>理解：一维的时间轴，选择1970年1月1日0时0分0秒时间为0刻度，1毫秒一刻度  </p><h3 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h3><ul><li>Date()：      源代码：this(System.currentTimeMillis());</li><li>Date(long date)</li></ul><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul><li>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li><li>toString():把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中：<br> dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)， zzz是时间标准。</li></ul><h3 id="已过时的方法："><a href="#已过时的方法：" class="headerlink" title="已过时的方法："></a>已过时的方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-public Date(int year,int month,int date,int hrs,int min,int sec)</span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">year - 减 1900 的年份。</span><br><span class="line">month - 0-11 之间的月份。</span><br><span class="line">date - 一月中 1-31 之间的某一天。</span><br><span class="line">hrs - 0-23 之间的小时数。</span><br><span class="line">min - 0-59 之间的分钟数。</span><br><span class="line">sec - 0-59 之间的秒数。</span><br></pre></td></tr></table></figure><ul><li>getYear() 从 JDK 1.1 开始，由 Calendar.get(Calendar.YEAR) - 1900 取代。</li><li>getMonth()从 JDK 1.1 开始，由 Calendar.get(Calendar.MONTH) 取代。返回的值在 0 和 11 之间，值 0 表示 1 月。 </li><li>getDate() JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_MONTH) 取代。返回的值在 1 和 31 之间</li><li>getDay()从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_WEEK) 取代。 返回值 (0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday) 表示一周中的某一天</li><li>getHours()从 JDK 1.1 开始，由 Calendar.get(Calendar.HOUR_OF_DAY) 取代。返回值是一个数字（0 至 23）</li><li>getMinutes()从 JDK 1.1 开始，由 Calendar.get(Calendar.MINUTE) 取代。 返回值在 0 和 59 之间。 </li><li>getSeconds()从 JDK 1.1 开始，由 Calendar.get(Calendar.SECOND) 取代。回的值在 0 和 61 之间。值 60 和 61 只可能发生在考虑了闰秒的 Java 虚拟机上。 </li></ul><h2 id="10-5-3-java-util-TimeZone和Locale"><a href="#10-5-3-java-util-TimeZone和Locale" class="headerlink" title="10.5.3 java.util.TimeZone和Locale"></a>10.5.3 java.util.TimeZone和Locale</h2><ul><li>Locale 对象表示了特定的地理、政治和文化地区。需要 Locale 来执行其任务的操作称为语言环境敏感的 操作，它使用 Locale 为用户量身定制信息。例如，显示一个数值，日期就是语言环境敏感的操作，应该根据用户的国家、地区或文化的风俗/传统来格式化该数值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取Locale对象：</span><br><span class="line"> Locale(String language)</span><br><span class="line"> Locale(String language, String country)</span><br><span class="line"> Locale.CHINA、Locale.US等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Locale loc = Locale.CHINA;</span><br><span class="line">System.out.println(loc);//zh_CN</span><br><span class="line">System.out.println(Locale.US);//en_US</span><br><span class="line">System.out.println(Locale.JAPAN);//ja_JP</span><br><span class="line"></span><br><span class="line">Locale c = new Locale(&quot;zh&quot;,&quot;CN&quot;);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通常，使用 TimeZone的getDefault 获取 TimeZone，getDefault 基于程序运行所在的时区创建 TimeZone。例如，对于在日本运行的程序，getDefault 基于日本标准时间创建 TimeZone 对象。 </p></li><li><p>也可以用TimeZone的 getTimeZone 及时区 ID 获取 TimeZone 。例如美国太平洋时区的时区 ID 是 “America/Los_Angeles”。因此，可以使用下面语句获得美国太平洋时间 TimeZone 对象： </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TimeZone tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TimeZone t = TimeZone.getDefault();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line">TimeZone t1 = TimeZone.getTimeZone(&quot;America/New_York&quot;);</span><br><span class="line">System.out.println(t1);</span><br><span class="line"></span><br><span class="line">TimeZone t2 = TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line">for (String id : all) &#123;</span><br><span class="line">System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-5-4-java-util-Calendar"><a href="#10-5-4-java-util-Calendar" class="headerlink" title="10.5.4 java.util.Calendar"></a>10.5.4 java.util.Calendar</h2><ul><li>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 </li><li>人们对于时间的认识是：某年某月某日，这样的日期概念。计算机是long类型的数字。通过Calendar在二者之间搭起桥梁。而且Calendar提供了很多关于日期时间计算的方法。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531001631.png" alt></p><ul><li>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</li></ul><p>注意：<br>月份：一月是0，二月是1，以此类推，12月是11<br>星期：周日是1，周二是2,。。。。周六是7</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531001747.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//默认语言环境的时间（时区）</span><br><span class="line">Calendar c = new GregorianCalendar();</span><br><span class="line">/*</span><br><span class="line"> * java.util.GregorianCalendar[</span><br><span class="line"> * time=1480667849712,</span><br><span class="line"> * areFieldsSet=true,</span><br><span class="line"> * areAllFieldsSet=true,</span><br><span class="line"> * lenient=true,</span><br><span class="line"> * zone=sun.util.calendar.ZoneInfo[id=&quot;Asia/Shanghai&quot;,offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null],</span><br><span class="line"> * firstDayOfWeek=1,</span><br><span class="line"> * minimalDaysInFirstWeek=1,</span><br><span class="line"> * ERA=1,</span><br><span class="line"> * YEAR=2016,</span><br><span class="line"> * MONTH=11,</span><br><span class="line"> * WEEK_OF_YEAR=49,//本年第49周</span><br><span class="line"> * WEEK_OF_MONTH=1,//本月第1周</span><br><span class="line"> * DAY_OF_MONTH=2,</span><br><span class="line"> * DAY_OF_YEAR=337,//本年第337天</span><br><span class="line"> * DAY_OF_WEEK=6,</span><br><span class="line"> * DAY_OF_WEEK_IN_MONTH=1,</span><br><span class="line"> * AM_PM=1, //下午</span><br><span class="line"> * HOUR=4,</span><br><span class="line"> * HOUR_OF_DAY=16,  //HOUR是12小时制， HOUR_OF_DAY是24小时制</span><br><span class="line"> * MINUTE=37,</span><br><span class="line"> * SECOND=29,</span><br><span class="line"> * MILLISECOND=712,</span><br><span class="line"> * ZONE_OFFSET=28800000,</span><br><span class="line"> * DST_OFFSET=0]</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//默认语言环境的时间（时区）</span><br><span class="line">Calendar c = new GregorianCalendar();</span><br><span class="line"></span><br><span class="line">int year=c.get(Calendar.YEAR);</span><br><span class="line">int month=c.get(Calendar.MONTH);</span><br><span class="line">int date=c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">int hour=c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">int minute=c.get(Calendar.MINUTE);</span><br><span class="line">int second=c.get(Calendar.SECOND);</span><br><span class="line">int mill=c.get(Calendar.MILLISECOND);</span><br><span class="line">int week=c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line"></span><br><span class="line">StringBuffer dateStr=new StringBuffer();</span><br><span class="line">dateStr.append(year).append(&quot;年&quot;);</span><br><span class="line">dateStr.append(month+1).append(&quot;月&quot;);</span><br><span class="line">dateStr.append(date).append(&quot;日&quot;).append(&quot;  &quot;);</span><br><span class="line">dateStr.append(hour).append(&quot;时&quot;);</span><br><span class="line">dateStr.append(minute).append(&quot;分&quot;);</span><br><span class="line">dateStr.append(second).append(&quot;秒&quot;);</span><br><span class="line">dateStr.append(mill).append(&quot;毫秒&quot;).append(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line">String[] weeks=&#123;&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;&#125;;</span><br><span class="line">dateStr.append(&quot;星期&quot;).append(weeks[week-1]);</span><br><span class="line"></span><br><span class="line">System.out.println(dateStr);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Calendar c = new GregorianCalendar(2015, 6, 13);</span><br><span class="line">//c.set(2016, Calendar.DECEMBER, 4, 12, 12, 0);</span><br><span class="line">//c.setTime(new Date());</span><br><span class="line">//15天之后</span><br><span class="line">//c.add(Calendar.DATE, 15);</span><br><span class="line">//2个月之前</span><br><span class="line">//c.add(Calendar.DAY_OF_MONTH, -2);</span><br><span class="line">//12小时之后</span><br><span class="line">c.add(Calendar.HOUR, 12);</span><br><span class="line"></span><br><span class="line">Date time = c.getTime();//转成日期</span><br><span class="line">System.out.println(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public static Calendar getInstance()使用默认时区和语言环境获得一个日历。返回的 Calendar 基于当前时间，使用了默认时区和默认语言环境。 </li><li>public static Calendar getInstance(TimeZone zone, Locale aLocale)使用指定时区和语言环境获得一个日历。返回的 Calendar 基于当前时间，使用了给定的时区和给定的语言环境。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line">Calendar c2 = Calendar.getInstance(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;), Locale.CHINA);</span><br><span class="line">System.out.println(c2);</span><br><span class="line"></span><br><span class="line">Calendar c3 = Calendar.getInstance(TimeZone.getTimeZone(&quot;America/New_York&quot;), Locale.US);</span><br><span class="line">System.out.println(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-5-5-java-text-DateFormat和SimpleDateFormat"><a href="#10-5-5-java-text-DateFormat和SimpleDateFormat" class="headerlink" title="10.5.5 java.text.DateFormat和SimpleDateFormat"></a>10.5.5 java.text.DateFormat和SimpleDateFormat</h2><p>完成字符串和时间对象的转化：</p><ul><li>format(date)</li><li>Date parse(string)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss 是本年的第几D&quot;);</span><br><span class="line">System.out.println(sf.format(date));</span><br><span class="line"></span><br><span class="line">String s = &quot;2016-12-01 14:12:23&quot;;</span><br><span class="line">SimpleDateFormat sf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Date d = sf2.parse(s);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531002016.png" alt></p><h1 id="10-6-数学相关类Math、BigInteger、BigDecimal"><a href="#10-6-数学相关类Math、BigInteger、BigDecimal" class="headerlink" title="10.6 数学相关类Math、BigInteger、BigDecimal"></a>10.6 数学相关类Math、BigInteger、BigDecimal</h1><h2 id="10-6-1-java-lang-Math类"><a href="#10-6-1-java-lang-Math类" class="headerlink" title="10.6.1 java.lang.Math类"></a>10.6.1 java.lang.Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算；<br>其方法的参数和返回值类型一般为double型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abs     绝对值</span><br><span class="line">acos,asin,atan,cos,sin,tan  三角函数</span><br><span class="line">sqrt     平方根</span><br><span class="line">pow(double a,doble b)     a的b次幂</span><br><span class="line">log    自然对数</span><br><span class="line">exp    e为底指数</span><br><span class="line">max(double a,double b)</span><br><span class="line">min(double a,double b)</span><br><span class="line">random()      返回0.0到1.0的随机数</span><br><span class="line">long round(double a)     double型数据a转换为long型（四舍五入）</span><br><span class="line">toDegrees(double angrad)     弧度—&gt;角度</span><br><span class="line">toRadians(double angdeg)     角度—&gt;弧度</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">System.out.println(Math.random());//随机值</span><br><span class="line">System.out.println(Math.round(1.8));//四舍五入  保留整数部分</span><br><span class="line">System.out.println(Math.floor(1.2));//1.0  向下取</span><br><span class="line">System.out.println(Math.ceil(1.2));//2.0  向上取</span><br><span class="line">System.out.println(Math.floor(-2.4));//-3.0</span><br><span class="line">System.out.println(Math.ceil(-2.4));//-2.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-6-2-java-math包的BigInteger和BigDecimal"><a href="#10-6-2-java-math包的BigInteger和BigDecimal" class="headerlink" title="10.6.2 java.math包的BigInteger和BigDecimal"></a>10.6.2 java.math包的BigInteger和BigDecimal</h2><p>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。<br>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p><ul><li>构造方法<ul><li>BigInteger(String val)：根据字符串构建BigInteger对象</li></ul></li></ul><ul><li>常用方法<ul><li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger。 </li><li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger。</li><li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger。</li><li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li><li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li><li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li><li>BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。 </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">//long num1 = 12345678901234567890L;//out of range 超过long的范围</span><br><span class="line">BigInteger num1 = new BigInteger(&quot;12345678901234567890&quot;);</span><br><span class="line">BigInteger num2 = new BigInteger(&quot;92345678901234567890&quot;);</span><br><span class="line"></span><br><span class="line">//System.out.println(&quot;和：&quot; + (num1 + num2));//错误的</span><br><span class="line">System.out.println(&quot;和：&quot; + num1.add(num2));</span><br><span class="line">System.out.println(&quot;减：&quot; + num1.subtract(num2));</span><br><span class="line">System.out.println(&quot;乘：&quot; + num1.multiply(num2));</span><br><span class="line">System.out.println(&quot;除：&quot; + num2.divide(num1));//两个整数相除只保留整数部分</span><br><span class="line">System.out.println(&quot;幂次方：&quot; + num2.pow(5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的Float类和Double类可以用来做科学计算或工程计算，但是在商业计算中，要求数字精度比较高，所以用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><ul><li>构造器<ul><li>BigDecimal(double val)</li><li>BigDecimal(String val)</li></ul></li></ul><ul><li>常用方法<ul><li>BigDecimal add(BigDecimal augend) :返回一个 BigDecimal，其值为 (this + augend)，其标度为 max(this.scale(), augend.scale())。</li><li>BigDecimal subtract(BigDecimal subtrahend) ：返回一个 BigDecimal，其值为 (this - subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。 </li><li>BigDecimal multiply(BigDecimal multiplicand)：返回一个 BigDecimal，其值为 (this × multiplicand)，其标度为 (this.scale() + multiplicand.scale())。</li><li>BigDecimal pow(int n) ：返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。</li><li>BigDecimal divide(BigDecimal divisor)： 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。</li><li>BigDecimal divide(BigDecimal divisor, int roundingMode) ：返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。  </li><li>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) ：返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。 </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">BigDecimal num1 = new BigDecimal(&quot;-12.1234567890123456567899554544444332&quot;);</span><br><span class="line">BigDecimal num2 = new BigDecimal(&quot;89.6734567890123456567899554544444333&quot;);</span><br><span class="line">System.out.println(&quot;和：&quot; + num1.add(num2));</span><br><span class="line">System.out.println(&quot;减：&quot; + num1.subtract(num2));</span><br><span class="line">System.out.println(&quot;乘：&quot; + num1.multiply(num2));</span><br><span class="line">System.out.println(&quot;除：&quot; + num2.divide(new BigDecimal(&quot;2&quot;)));//可以整除（除尽）就对，不能整除就报异常</span><br><span class="line">System.out.println(&quot;除：&quot; + num2.divide(num1,BigDecimal.ROUND_HALF_UP));</span><br><span class="line">System.out.println(&quot;除：&quot; + num2.divide(num1,BigDecimal.ROUND_DOWN));//往零的方向舍去</span><br><span class="line">System.out.println(&quot;除：&quot; + num2.divide(num1,BigDecimal.ROUND_FLOOR));//往小的方向舍去</span><br><span class="line">System.out.println(&quot;除：&quot; + num2.divide(num1,BigDecimal.ROUND_CEILING));//往大的方向舍去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-7-比较器：自然排序与定制排序"><a href="#10-7-比较器：自然排序与定制排序" class="headerlink" title="10.7 比较器：自然排序与定制排序"></a>10.7 比较器：自然排序与定制排序</h1><h2 id="10-7-1-自然排序：java-lang-Comparable"><a href="#10-7-1-自然排序：java-lang-Comparable" class="headerlink" title="10.7.1 自然排序：java.lang.Comparable"></a>10.7.1 自然排序：java.lang.Comparable</h2><ul><li><p>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo(T t) 方法被称为它的自然比较方法。当前对象this与指定对象t比较“大小”，如果当前对象this大于指定对象t，则返回正整数，如果当前对象this小于指定对象t，则返回负整数，如果当前对象this等于指定对象t，则返回零。</p></li><li><p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p></li><li><p>Comparable的典型实现：</p><ul><li>String：按照字符串中字符的Unicode值进行比较</li><li>Character：按照字符的Unicode值来进行比较</li><li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li><li>Date、Time等：后面的日期时间比前面的日期时间大</li></ul></li></ul><h2 id="10-7-2-定制排序：java-util-Compartor"><a href="#10-7-2-定制排序：java-util-Compartor" class="headerlink" title="10.7.2 定制排序：java.util.Compartor"></a>10.7.2 定制排序：java.util.Compartor</h2><ul><li><p>强行对某个对象 collection 进行整体排序 的比较函数。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p></li><li><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序。</p></li></ul><h2 id="10-7-3-示例"><a href="#10-7-3-示例" class="headerlink" title="10.7.3 示例"></a>10.7.3 示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">com.api.compare;</span><br><span class="line"></span><br><span class="line">import java.text.Collator;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">public class TestCompare &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Goods[] all = new Goods[4];</span><br><span class="line">all[0] = new Goods(&quot;《红楼梦》&quot;,100);</span><br><span class="line">all[1] = new Goods(&quot;《西游记》&quot;,80);</span><br><span class="line">all[2] = new Goods(&quot;《三国演义》&quot;,140);</span><br><span class="line">all[3] = new Goods(&quot;《水浒传》&quot;,120);</span><br><span class="line"></span><br><span class="line">Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(all));</span><br><span class="line"></span><br><span class="line">Arrays.sort(all , new Comparator() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compare(Object o1, Object o2) &#123;</span><br><span class="line">Goods g1 = (Goods) o1;</span><br><span class="line">Goods g2 = (Goods) o2;</span><br><span class="line"></span><br><span class="line">return Collator.getInstance(Locale.CHINA).compare(g1.getName(),g2.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(all));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Goods implements Comparable&#123;</span><br><span class="line">private String name;</span><br><span class="line">private double price;</span><br><span class="line">public Goods(String name, double price) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">return price;</span><br><span class="line">&#125;</span><br><span class="line">public void setPrice(double price) &#123;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;商品名：&quot; + name + &quot;, 价格：&quot; + price;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Object o) &#123;</span><br><span class="line">Goods other = (Goods) o;</span><br><span class="line">if(this.price &gt; other.price)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;else if(this.price &lt; other.price)&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-8-JDK1-8新增日期时间类型"><a href="#10-8-JDK1-8新增日期时间类型" class="headerlink" title="10.8 JDK1.8新增日期时间类型"></a>10.8 JDK1.8新增日期时间类型</h1><p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。Java1.0中包含了一个Date类，但是它的大多数方法已经在Java 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p><ul><li>可变性：象日期和时间这样的类应该是不可变的。Calendar类中可以使用三种方法更改日历字段：set()、add() 和 roll()。</li><li>偏移性：Date中的年份是从1900开始的，而月份都是从0开始的。</li><li>格式化：格式化只对Date有用，Calendar则不行。</li><li>此外，它们也不是线程安全的，不能处理闰秒等。</li></ul><p>Date的API： </p><blockquote><p>尽管 Date 类打算反映协调世界时 (UTC)，但无法做到如此准确，这取决于 Java 虚拟机的主机环境。当前几乎所有操作系统都假定 1 天 = 24 × 60 × 60 = 86400 秒。但对于 UTC，大约每一两年出现一次额外的一秒，称为“闰秒”。闰秒始终作为当天的最后一秒增加，并且始终在 12 月 31 日或 6 月 30 日增加。例如，1995 年的最后一分钟是 61 秒，因为增加了闰秒。大多数计算机时钟不是特别的准确，因此不能反映闰秒的差别。<br>在类 Date 所有可以接受或返回年、月、日期、小时、分钟和秒值的方法中，将使用下面的表示形式： </p></blockquote><ul><li>年份 y 由整数 y - 1900 表示。 </li><li>月份由从 0 至 11 的整数表示；0 是一月、1 是二月等等；因此 11 是十二月。 </li><li>日期（一月中的某天）按通常方式由整数 1 至 31 表示。 </li><li>小时由从 0 至 23 的整数表示。因此，从午夜到 1 a.m. 的时间是 0 点，从中午到 1 p.m. 的时间是 12 点。 </li><li>分钟按通常方式由 0 至 59 的整数表示。 </li><li>秒由 0 至 61 的整数表示；值 60 和 61 只对闰秒发生，尽管那样，也只用在实际正确跟踪闰秒的 Java 实现中。于按当前引入闰秒的方式，两个闰秒在同一分钟内发生是极不可能的，但此规范遵循 ISO C 的日期和时间约定。 </li></ul><p>在所有情形中，针对这些目的赋予方法的参数不需要在指定的范围内；例如，可以把日期指定为 1 月 32 日，并把它解释为 2 月 1 日的相同含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = new Date(2017-1900,8-1,28);</span><br><span class="line">System.out.println(date);//Mon Aug 28 00:00:00 CST 2017</span><br></pre></td></tr></table></figure><ul><li>可以说，对日期和时间的操作一直是Java程序员最痛苦的地方之一。第三次引入的API是成功的，并且java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。  </li><li>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.time – 包含值对象的基础包</span><br><span class="line">java.time.chrono – 提供对不同的日历系统的访问。</span><br><span class="line">java.time.format – 格式化和解析时间和日期</span><br><span class="line">java.time.temporal – 包括底层框架和扩展特性</span><br><span class="line">java.time.zone – 包含时区支持的类</span><br></pre></td></tr></table></figure><blockquote><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p></blockquote><ul><li>说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531003328.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531003703.png" alt></p><h2 id="10-8-1-java-time"><a href="#10-8-1-java-time" class="headerlink" title="10.8.1 java.time"></a>10.8.1 java.time</h2><h3 id="1、本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）"><a href="#1、本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）" class="headerlink" title="1、本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）"></a>1、本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</span><br><span class="line">LocalTime表示一个时间，而不是日期</span><br><span class="line">LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</span><br></pre></td></tr></table></figure><p>描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">now() / now(ZoneId zone)</span><br><span class="line">静态方法，根据当前时间创建对象/指定时区的对象</span><br><span class="line">of()</span><br><span class="line">静态方法，根据指定日期/时间创建对象</span><br><span class="line">getDayOfMonth()/getDayOfYear()</span><br><span class="line">获得月份天数(1-31) /获得年份天数(1-366)</span><br><span class="line">getDayOfWeek()</span><br><span class="line">获得星期几(返回一个 DayOfWeek 枚举值)</span><br><span class="line">getMonth()</span><br><span class="line">获得月份, 返回一个 Month 枚举值</span><br><span class="line">getMonthValue() / getYear()</span><br><span class="line">获得月份(1-12) /获得年份</span><br><span class="line">getHours()/getMinute()/getSecond()</span><br><span class="line">获得当前对象对应的小时、分钟、秒</span><br><span class="line">withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</span><br><span class="line">将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</span><br><span class="line"> with(TemporalAdjuster  t)</span><br><span class="line">将当前日期时间设置为校对器指定的日期时间</span><br><span class="line">plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</span><br><span class="line">向当前对象添加几天、几周、几个月、几年、几小时</span><br><span class="line">minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</span><br><span class="line">从当前对象减去几月、几周、几天、几年、几小时</span><br><span class="line">plus(TemporalAmount t)/minus(TemporalAmount t)</span><br><span class="line">添加或减少一个 Duration 或 Period</span><br><span class="line">isBefore()/isAfter()</span><br><span class="line">比较两个 LocalDate</span><br><span class="line">isLeapYear()</span><br><span class="line">判断是否是闰年（在LocalDate类中声明）</span><br><span class="line"> format(DateTimeFormatter  t)</span><br><span class="line">格式化本地日期、时间，返回一个字符串</span><br><span class="line"> parse(Charsequence text)</span><br><span class="line">将指定格式的字符串解析为日期、时间</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//now()</span><br><span class="line">    @Test</span><br><span class="line">public void testLocalDateTime()&#123;</span><br><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">LocalDateTime datetime = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    //of()或parse</span><br><span class="line">@Test</span><br><span class="line">public void testLocalDate() &#123;</span><br><span class="line">// LocalDate date = LocalDate.now();</span><br><span class="line">// LocalDate date = LocalDate.of(2017, 3, 20);</span><br><span class="line">LocalDate date = LocalDate.parse(&quot;2017-03-12&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LocalDateTime t = LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;这一天是这一年的第几天：&quot;+t.getDayOfYear());</span><br><span class="line">System.out.println(&quot;年：&quot;+t.getYear());</span><br><span class="line">System.out.println(&quot;月：&quot;+t.getMonth());</span><br><span class="line">System.out.println(&quot;月份值：&quot;+t.getMonthValue());</span><br><span class="line">System.out.println(&quot;日：&quot;+t.getDayOfMonth());</span><br><span class="line">System.out.println(&quot;星期：&quot;+t.getDayOfWeek());</span><br><span class="line">System.out.println(&quot;时：&quot;+t.getHour());</span><br><span class="line">System.out.println(&quot;分：&quot;+t.getMinute());</span><br><span class="line">System.out.println(&quot;秒：&quot;+t.getSecond());</span><br><span class="line">System.out.println(t.getMonthValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testLocalDate2() &#123;</span><br><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line"></span><br><span class="line">       //withXxx()方法，不改变原来的date对象，返回一个新的对象，不可变性</span><br><span class="line">// LocalDate date2 = date.withDayOfMonth(1);//获取这个月的第一天</span><br><span class="line">LocalDate date2 = date.with(TemporalAdjusters.firstDayOfMonth());// 获取这个月的第一天</span><br><span class="line">System.out.println(date2);</span><br><span class="line"></span><br><span class="line">// 获取这个月的最后一天</span><br><span class="line">LocalDate date3 = date.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(date3);</span><br><span class="line"></span><br><span class="line">//45天后的日期</span><br><span class="line">LocalDate date4 = date.plusDays(45);</span><br><span class="line">System.out.println(date4);</span><br><span class="line"></span><br><span class="line">//20天前的日期</span><br><span class="line">LocalDate date5 = date.minusDays(20);</span><br><span class="line">System.out.println(date5);</span><br><span class="line"></span><br><span class="line">boolean before = date.isBefore(date5);</span><br><span class="line">System.out.println(date+&quot;是否比&quot;+date5+&quot;早&quot; + before);</span><br><span class="line"></span><br><span class="line">System.out.println(date+&quot;是否是闰年：&quot;+date.isLeapYear());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MonthDay month = MonthDay.of(8, 14);</span><br><span class="line">MonthDay today = MonthDay.from(date);</span><br><span class="line">System.out.println(&quot;今天是否是生日：&quot; + month.equals(today));</span><br></pre></td></tr></table></figure><h3 id="2、瞬时：Instant"><a href="#2、瞬时：Instant" class="headerlink" title="2、瞬时：Instant"></a>2、瞬时：Instant</h3><ul><li>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</li><li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</li><li>java.time包通过值类型Instant提供机器视图。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531004049.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531004148.png" alt></p><p>时间戳：指格林威治时间1970年01月01日00时00分00秒（北京时间1970年01月01日08时00分00秒）起至现在的总秒数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Instant t = Instant.now();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line">//偏移8个小时</span><br><span class="line">OffsetDateTime atOffset = t.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(atOffset);</span><br><span class="line"></span><br><span class="line">long milli = t.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br><span class="line"></span><br><span class="line">Instant in2 = Instant.ofEpochSecond(10000000);</span><br><span class="line">System.out.println(in2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、带时区的日期、时间的处理"><a href="#3、带时区的日期、时间的处理" class="headerlink" title="3、带时区的日期、时间的处理"></a>3、带时区的日期、时间的处理</h3><p>作为一个开发者，如果不用去处理时区和它带来的复杂性，那是幸运的。java.time包下的LocalDate、LocalTime、LocalDateTime和Instant基本能满足需求。当你不可避免时区时，ZonedDateTime等类可以满足我们的需求。  </p><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p><ul><li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等</li><li>now()：使用系统时间获取当前的ZonedDateTime</li><li>now(ZoneId)：返回指定时区的ZonedDateTime</li></ul><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p><ul><li>getAvailableZoneIds()：静态方法，可以获取所有时区信息</li><li>of(String id)：静态方法，用指定的时区信息获取ZoneId对象</li></ul><p>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">for (String string : availableZoneIds) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZonedDateTime t = ZonedDateTime.now();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line">ZonedDateTime t1 = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));</span><br><span class="line">System.out.println(t1);</span><br><span class="line"></span><br><span class="line">//Clock clock = Clock.systemDefaultZone();</span><br><span class="line">Clock c = Clock.system(ZoneId.of(&quot;America/New_York&quot;));</span><br><span class="line">System.out.println(c.getZone());</span><br><span class="line">System.out.println(c.instant());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、持续时间：Duration"><a href="#4、持续时间：Duration" class="headerlink" title="4、持续时间：Duration"></a>4、持续时间：Duration</h3><p>Duration:用于计算两个“时间”间隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LocalDateTime t1 = LocalDateTime.now();</span><br><span class="line">LocalDateTime t2 = LocalDateTime.of(2017, 8, 29, 0, 0, 0, 0);</span><br><span class="line">Duration between = Duration.between(t1, t2);</span><br><span class="line">System.out.println(between);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;相差的总天数：&quot;+between.toDays());</span><br><span class="line">System.out.println(&quot;相差的总小时数：&quot;+between.toHours());</span><br><span class="line">System.out.println(&quot;相差的总分钟数：&quot;+between.toMinutes());</span><br><span class="line">System.out.println(&quot;相差的总秒数：&quot;+between.getSeconds());</span><br><span class="line">System.out.println(&quot;相差的总毫秒数：&quot;+between.toMillis());</span><br><span class="line">System.out.println(&quot;相差的总纳秒数：&quot;+between.toNanos());</span><br><span class="line">System.out.println(&quot;不够一秒的纳秒数：&quot;+between.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、日期间隔：Period"><a href="#5、日期间隔：Period" class="headerlink" title="5、日期间隔：Period"></a>5、日期间隔：Period</h3><p>Period:用于计算两个“日期”间隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LocalDate t1 = LocalDate.now();</span><br><span class="line">LocalDate t2 = LocalDate.of(2018, 12, 31);</span><br><span class="line">Period between = Period.between(t1, t2);</span><br><span class="line">System.out.println(between);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;相差的年数：&quot;+between.getYears());//1年</span><br><span class="line">System.out.println(&quot;相差的月数：&quot;+between.getMonths());//又7个月</span><br><span class="line">System.out.println(&quot;相差的天数：&quot;+between.getDays());//零25天</span><br><span class="line">System.out.println(&quot;相差的总数：&quot;+between.toTotalMonths());//总共19个月</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-8-2-java-time-temporal-TemporalAdjuster-时间校正器"><a href="#10-8-2-java-time-temporal-TemporalAdjuster-时间校正器" class="headerlink" title="10.8.2 java.time.temporal.TemporalAdjuster : 时间校正器"></a>10.8.2 java.time.temporal.TemporalAdjuster : 时间校正器</h2><ul><li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</li><li>TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">System.out.println(&quot;下一个周日:&quot;+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)));</span><br><span class="line">System.out.println(&quot;下周五&quot; + now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY)));</span><br><span class="line">        System.out.println(&quot;本月最后一天:&quot;+now.with(TemporalAdjusters.lastDayOfMonth()));//2017-08-31</span><br><span class="line">LocalDate week = LocalDate.now().with(new TemporalAdjuster()&#123;</span><br><span class="line">@Override</span><br><span class="line">public Temporal adjustInto(Temporal temporal) &#123;</span><br><span class="line">LocalDate date = (LocalDate) temporal;</span><br><span class="line">if(date.getDayOfWeek().equals(DayOfWeek.MONDAY))&#123;</span><br><span class="line">return date.plusDays(7);</span><br><span class="line">&#125;else if(date.getDayOfWeek().equals(DayOfWeek.TUESDAY))&#123;</span><br><span class="line">return date.plusDays(6);</span><br><span class="line">&#125;else if(date.getDayOfWeek().equals(DayOfWeek.WEDNESDAY))&#123;</span><br><span class="line">return date.plusDays(5);</span><br><span class="line">&#125;else if(date.getDayOfWeek().equals(DayOfWeek.THURSDAY))&#123;</span><br><span class="line">return date.plusDays(4);</span><br><span class="line">&#125;else if(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">return date.plusDays(3);</span><br><span class="line">&#125;else if(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">return date.plusDays(2);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return date.plusDays(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;下一个工作日：&quot; + week);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-8-3-java-time-format-DateTimeFormatter-类"><a href="#10-8-3-java-time-format-DateTimeFormatter-类" class="headerlink" title="10.8.3 java.time.format.DateTimeFormatter 类"></a>10.8.3 java.time.format.DateTimeFormatter 类</h2><ul><li>该类提供了三种格式化方法：</li><li>预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE</li><li>本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM)</li><li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE.format(LocalDate.now()));</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">//FULL和SHORT适用于LocalDate和LocalTime</span><br><span class="line">System.out.println(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).format(LocalDate.now()));</span><br><span class="line">System.out.println(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(LocalTime.now()));</span><br><span class="line"></span><br><span class="line">//LONG和MEDIUM适用于LocalDateTime</span><br><span class="line">System.out.println(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">DateTimeFormatter op = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(op.format(LocalDateTime.now()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-8-4-与传统日期处理的转换"><a href="#10-8-4-与传统日期处理的转换" class="headerlink" title="10.8.4 与传统日期处理的转换"></a>10.8.4 与传统日期处理的转换</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190531004958.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10-1包装类Wrapper&quot;&gt;&lt;a href=&quot;#10-1包装类Wrapper&quot; class=&quot;headerlink&quot; title=&quot;10.1包装类Wrapper&quot;&gt;&lt;/a&gt;10.1包装类Wrapper&lt;/h1&gt;&lt;p&gt;学习API更深的意义在于复习面向对象的知识。
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>9. JavaSE-Java异常处理</title>
    <link href="http://yoursite.com/2016/12/24/9.%20JavaSE-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/12/24/9. JavaSE-Java异常处理/</id>
    <published>2016-12-23T16:00:00.000Z</published>
    <updated>2019-06-04T01:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>#9.1 异常的概述</p><h2 id="9-1-1-什么是异常"><a href="#9-1-1-什么是异常" class="headerlink" title="9.1.1 什么是异常"></a>9.1.1 什么是异常</h2><blockquote><ul><li>异常，又称为例外，是指不可预知的非正常的情况，例如：正常开车突然路口窜出一条狗来，或者正常上下班的路上，某个街角偶遇了爱情，或者在每天晨跑的小树林遭遇了歹徒。这些突发的情况的发生是不可预知的，where,when……，但是如果处理好了，美好的生活不受影响，可以继续，如果处理不好，可能就“挂”了。</li><li>Java语言将程序执行中发生的不正常情况称为“异常”，异常是一种对程序运行过程中发生错误时进行通知的机制。如：网络连接失败、用户输入错误或打开文件失败等。</li></ul></blockquote><p> <img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530165032.png" alt></p><h2 id="9-1-2-Java异常的堆栈式抛出机制"><a href="#9-1-2-Java异常的堆栈式抛出机制" class="headerlink" title="9.1.2 Java异常的堆栈式抛出机制"></a>9.1.2 Java异常的堆栈式抛出机制</h2><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line">public class TestException &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = Integer.parseInt(args[0]);</span><br><span class="line">int b = Integer.parseInt(args[1]);</span><br><span class="line">System.out.println(a + &quot;/&quot; + b + &quot;=&quot; + a/b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  com.exception.TestException  12  3</span><br></pre></td></tr></table></figure><p>运行结果显示12/3=4，结果正常。</p><h3 id="1-ArrayIndexOutOfBoundsException数组下标越界异常"><a href="#1-ArrayIndexOutOfBoundsException数组下标越界异常" class="headerlink" title="1. ArrayIndexOutOfBoundsException数组下标越界异常"></a>1. ArrayIndexOutOfBoundsException数组下标越界异常</h3><p>命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  com.exception.TestException</span><br></pre></td></tr></table></figure><p>出现异常形式，如图9-1：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530165238.png" alt></p><h3 id="2-NumberFormatException数字格式化异常"><a href="#2-NumberFormatException数字格式化异常" class="headerlink" title="2. NumberFormatException数字格式化异常"></a>2. NumberFormatException数字格式化异常</h3><p>命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  com.exception.TestException  a  b</span><br></pre></td></tr></table></figure><p>出现异常形式，如图9-2：</p><p><img src="http://note.youdao.com/yws/res/6111/E0EEA67E326B44F88C522355472DF277" alt="image"></p><h3 id="3-ArithmeticException算术异常"><a href="#3-ArithmeticException算术异常" class="headerlink" title="3. ArithmeticException算术异常"></a>3. ArithmeticException算术异常</h3><p>命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  com.exception.TestException  12  0</span><br></pre></td></tr></table></figure><p>出现异常形式，如图9-3：</p><p><img src="http://note.youdao.com/yws/res/6115/6B2236572F2549EEA6C1290778B0667D" alt="image"></p><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h3><p>在Java中异常以对象的形式出现，不同的异常对象中封装了相应的错误信息。<br>Java是采用面向对象的方式来处理异常的。处理过程：</p><ul><li>抛出异常：在执行一个方法时，如果在某句代码发生异常，则会在该句代码处生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE，不同的异常对象中封装了相应的错误信息。</li><li>捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。如果没有找到处理代码，那么程序终止运行<br>Java中异常的是以堆栈式抛出机制来进行错误通知的，如图10-4。</li></ul><p><img src="http://note.youdao.com/yws/res/6118/2A148296222146499CEC8890FAE7A502" alt="image"></p><h1 id="9-2-异常体系结构"><a href="#9-2-异常体系结构" class="headerlink" title="9.2 异常体系结构"></a>9.2 异常体系结构</h1><p>如10.1.2所示的ArrayIndexOutOfBoundsException数组下标越界异常，NumberFormatException数字格式化异常，ArithmeticException算术异常，查看它们的API，例如图9-5,9-6,9-7。</p><p><img src="http://note.youdao.com/yws/res/6120/E6C67A0CEABC4234A6F158AB8563DAAD" alt="image"></p><p><img src="http://note.youdao.com/yws/res/6122/047861140C034F1AA897892453C30046" alt="image"></p><p><img src="http://note.youdao.com/yws/res/6124/6B44AF6FC34148B9A9EE29CB92F31693" alt="image"></p><h2 id="9-2-1-异常的分类"><a href="#9-2-1-异常的分类" class="headerlink" title="9.2.1 异常的分类"></a>9.2.1 异常的分类</h2><p>Java语言提供了两大类异常，如图9-8：</p><ul><li>编译时异常（受检异常Checked）<br>编译时异常：指程序中必须接受检查和处理的异常，由Exception 类表示。</li><li>运行时异常（非受检异常UnChecked）<br>运行时异常：程序中可以不接受检查和处理，或致命性错误异常，由RuntimeException类或Error类表示。</li></ul><p><img src="http://note.youdao.com/yws/res/6131/C962A64258584FDEB8E0ADEF0B71771E" alt="image"></p><h2 id="9-2-2-Throwable"><a href="#9-2-2-Throwable" class="headerlink" title="9.2.2 Throwable"></a>9.2.2 Throwable</h2><ul><li>Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。 </li><li>两个子类的实例，Error 和 Exception，通常用于指示发生了异常情况。通常，这些实例是在异常情况的上下文中新近创建的，因此包含了相关的信息（比如堆栈跟踪数据）。 <h2 id="9-2-3-Error"><a href="#9-2-3-Error" class="headerlink" title="9.2.3 Error"></a>9.2.3 Error</h2></li><li>Error 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。 </li><li>在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。 <h2 id="9-2-4-Exception"><a href="#9-2-4-Exception" class="headerlink" title="9.2.4 Exception"></a>9.2.4 Exception</h2>Exception 类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。<br>应该在程序中尽可能的预知并处理异常。</li><li>checkedException：受检异常。这一类异常，编译时必须对其进行处理，如果不处理，编译不通过。（checked表示编译器检查过已经处理过的）。例如：疲劳必须休息、喝酒必须不能开车、刹车必须好用。</li><li>RuntimeException（uncheckedException）：运行时异常（非受检异常）。一类特殊的异常，如被0除、数组下标越界等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。因此由系统自动检测并将它们交给缺省的异常处理程序，即交给JVM处理，用户不显式处理。但是应该尽量避免！！！<br>例如：前车急刹车、有人加塞、路口突然窜出的电动车等等。换句话说，出现RuntimeException一定是你的问题，可以不捕获，因为小心点这些异常是可以避免的，例如：数组下标越界异常ArrayIndexOutOfBoundsException，空指针异常NullPointerException，类型转换异常ClassCastException等等。<h1 id="9-3-异常处理机制"><a href="#9-3-异常处理机制" class="headerlink" title="9.3 异常处理机制"></a>9.3 异常处理机制</h1><h2 id="9-3-1-捕获异常（try…catch…finally）"><a href="#9-3-1-捕获异常（try…catch…finally）" class="headerlink" title="9.3.1 捕获异常（try…catch…finally）"></a>9.3.1 捕获异常（try…catch…finally）</h2>可使用try…catch…finally语句捕获异常，避免程序不正常终止  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">try &#123;</span><br><span class="line">……</span><br><span class="line">&#125; [catch (&lt;异常类型&gt;  &lt;异常引用变量&gt;) &#123;</span><br><span class="line">……</span><br><span class="line">&#125; ]*  </span><br><span class="line">[finally &#123;</span><br><span class="line">……</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>说明：<br>（1）*可使用多个catch子句捕获多个异常，[]表示可选。<br>（2）可以有如下组合形式：<code>try...catch，try...finally，try...catch...finally</code>。  </p><h3 id="1-try"><a href="#1-try" class="headerlink" title="1. try"></a>1. try</h3><ul><li>try块中是可能发生异常的代码。其中某句代码发生异常，就会跳过try块中该句后面的代码，该句代码处会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。  </li><li>注意：<br>一个try必须带一个catch块或finally块或两者都有，即try块不能单独存在。<br>当异常处理的代码执行结束以后，是不会回到try语句块去执行尚未执行的代码的。只会执行try…catch…finally后面的代码。  <h3 id="2-catch"><a href="#2-catch" class="headerlink" title="2. catch"></a>2. catch</h3></li><li>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。  </li><li>catch块如果多个，异常对象将从上到下依次匹配类型，一旦某个catch的异常类型匹配成功，其他的catch将不再执行，即一个异常只能进入一个catch块。  </li><li>catch可以有多个，但是多个catch中的异常类型如果是“互斥关系（没有继承关系）”，顺序随意；如果是“包含关系（继承关系）”，必须小上大下/子上父下。<h3 id="3-finally"><a href="#3-finally" class="headerlink" title="3. finally"></a>3. finally</h3></li><li>有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。</li><li>通常在finally中关闭程序块已打开的资源，比如：文件流、释放数据库连接等。<h3 id="4-运行示意图"><a href="#4-运行示意图" class="headerlink" title="4. 运行示意图"></a>4. 运行示意图</h3>try…catch…finally的运行示意图，如图10-9</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530171700.png" alt></p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>####（1）示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">public class TestException &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">int a = Integer.parseInt(args[0]);</span><br><span class="line">int b = Integer.parseInt(args[1]);</span><br><span class="line">System.out.println(a + &quot;/&quot; + b + &quot;=&quot; + a/b);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序继续...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####（2）示例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestFileReader &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">FileReader fr = null;</span><br><span class="line">try &#123;</span><br><span class="line">fr = new FileReader(&quot;d:/a.txt&quot;);</span><br><span class="line">char c = (char) fr.read();</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">//IOException不能放前面，因为FileNotFoundException 是子类</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">              //可以嵌套</span><br><span class="line">try &#123;</span><br><span class="line">if(fr!=null)&#123;//需要判断非空</span><br><span class="line">fr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序继续...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-2-显式声明抛出异常（throws）"><a href="#9-3-2-显式声明抛出异常（throws）" class="headerlink" title="9.3.2 显式声明抛出异常（throws）"></a>9.3.2 显式声明抛出异常（throws）</h3><ul><li>如果一个方法出现Checked Exception，但是并不能确定如何处理这种异常或者不立刻处理它，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</li><li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。如果一个方法抛出多个受检异常，就必须在方法的签名中列出所有的异常，之间以逗号隔开。<h4 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestFileReader2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">readFile(&quot;d:/a.txt&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void readFile(String filename) throws FileNotFoundException,IOException&#123;</span><br><span class="line">FileReader fr = new FileReader(&quot;d:/a.txt&quot;);</span><br><span class="line">char c = (char) fr.read();</span><br><span class="line">System.out.println(c);</span><br><span class="line">fr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重写方法对throws异常的要求"><a href="#2-重写方法对throws异常的要求" class="headerlink" title="2. 重写方法对throws异常的要求"></a>2. 重写方法对throws异常的要求</h4><p>重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对重写方法的调用–异常的捕获按父类声明的异常处理。即</p><ul><li>父类被重写的方法没有声明抛出checked受检异常，那么重写的方法也不能声明抛出异常</li><li>子类重写方法声明抛出的异常的类型和父类被重写的方法声明抛出异常类型一致</li><li>子类重写方法声明抛出的异常的类型是父类被重写的方法声明抛出异常的子类</li><li>子类重写方法可以在方法内部处理异常，而不声明抛出异常<br>正确的示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public void method()throws IOException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">public void method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class C extends A&#123;</span><br><span class="line">public void method() throws FileNotFoundException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class D extends A&#123;</span><br><span class="line">public void method() throws IOException,FileNotFoundException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class E extends A&#123;</span><br><span class="line">public void method() throws IOException,RuntimeException&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public void method()throws IOException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class F extends A&#123;</span><br><span class="line">public void method() throws Exception &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class G extends A&#123;</span><br><span class="line">public void method() throws IOException,SQLException&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-4-手动抛出异常（throw）"><a href="#9-4-手动抛出异常（throw）" class="headerlink" title="9.4 手动抛出异常（throw）"></a>9.4 手动抛出异常（throw）</h1><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可以根据需要手动创建并抛出。可以抛出的异常必须是Throwable或其子类的实例。<br>首先要创建异常类对象，然后通过throw语句实现抛出操作，提交给Java运行环境。<br>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw 异常对象;</span><br></pre></td></tr></table></figure><p>不管系统自动生成的还是手动创建的，异常对象一旦抛出都需要使用捕获try…catch或继续抛出throws的方式处理。<br>其次，throw语句可以代替return语句结束方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">public class TestThrow &#123;</span><br><span class="line">public static void check(String username,String password)&#123;</span><br><span class="line">if(username==null || &quot;&quot;.equals(username.trim()))&#123;</span><br><span class="line">throw new RuntimeException(&quot;用户名不能为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(password==null || &quot;&quot;.equals(password.trim()))&#123;</span><br><span class="line">throw new RuntimeException(&quot;密码不能为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-5-自定义异常"><a href="#9-5-自定义异常" class="headerlink" title="9.5 自定义异常"></a>9.5 自定义异常</h1><ul><li>在程序中，可能会遇到任何标准异常类都没能充分的描述清楚的问题，这种情况下可以创建自己的异常类。</li><li>从Exception类或者它的子类派生一个子类即可</li><li>习惯上，自定义异常类应该包含2个构造器：一个是无参构造，另一个是带有详细信息的构造器</li><li>自定义的异常只能通过throw抛出。</li><li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">public class TestMyException &#123;</span><br><span class="line">public static void login(String username,String password) throws WrongUsernameOrPassWordException&#123;</span><br><span class="line">if(!(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123&quot;.equals(password)))&#123;</span><br><span class="line">throw new WrongUsernameOrPassWordException(&quot;用户名或密码错误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;登录成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class WrongUsernameOrPassWordException extends Exception&#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">public WrongUsernameOrPassWordException() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public WrongUsernameOrPassWordException(String message) &#123;</span><br><span class="line">super(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-6-finally与return"><a href="#9-6-finally与return" class="headerlink" title="9.6 finally与return"></a>9.6 finally与return</h1><p>执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、执行try,catch，给“返回值”临时变量赋值</span><br><span class="line">2、执行finally</span><br><span class="line">3、return</span><br><span class="line">return语句两个作用：给返回值赋值，结束方法运行</span><br></pre></td></tr></table></figure><h2 id="9-6-1-从finally的return回来"><a href="#9-6-1-从finally的return回来" class="headerlink" title="9.6.1 从finally的return回来"></a>9.6.1 从finally的return回来</h2><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">public class TestReturn &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int result = test(&quot;a&quot;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int test(String str)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">Integer.parseInt(str);</span><br><span class="line">return 1;</span><br><span class="line">&#125;catch(NumberFormatException e)&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">            System.out.println(&quot;test结束&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test结束</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="9-6-2-从catch的return回来"><a href="#9-6-2-从catch的return回来" class="headerlink" title="9.6.2 从catch的return回来"></a>9.6.2 从catch的return回来</h2><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">public class TestReturn &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int result = test(&quot;a&quot;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int test(String str)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">Integer.parseInt(str);</span><br><span class="line">return 1;</span><br><span class="line">&#125;catch(NumberFormatException e)&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">System.out.println(&quot;test结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test结束</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="9-6-3-从try的return回来"><a href="#9-6-3-从try的return回来" class="headerlink" title="9.6.3 从try的return回来"></a>9.6.3 从try的return回来</h2><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.exception;</span><br><span class="line"></span><br><span class="line">public class TestReturn &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int result = test(&quot;12&quot;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int test(String str)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">Integer.parseInt(str);</span><br><span class="line">return 1;</span><br><span class="line">&#125;catch(NumberFormatException e)&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">System.out.println(&quot;test结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test结束</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7 小结"></a>9.7 小结</h1><ul><li>要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。</li><li>不要进行小粒度的异常处理——应该将整个任务包装在一个try语句块中。</li><li>异常往往在高层处理。例如：（高层）领导—&gt;员工。调用关系。有问题赶紧上报<br>Java的异常处理机制总体示意图，如图10-10：</li></ul><p><img src="http://note.youdao.com/yws/res/6167/B96E6C21D3064CFE8883B3FD2DD151A2" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#9.1 异常的概述&lt;/p&gt;
&lt;h2 id=&quot;9-1-1-什么是异常&quot;&gt;&lt;a href=&quot;#9-1-1-什么是异常&quot; class=&quot;headerlink&quot; title=&quot;9.1.1 什么是异常&quot;&gt;&lt;/a&gt;9.1.1 什么是异常&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>8. JavaSE-枚举与注解</title>
    <link href="http://yoursite.com/2016/11/12/8.%20JavaSE-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/11/12/8. JavaSE-枚举与注解/</id>
    <published>2016-11-11T16:00:00.000Z</published>
    <updated>2019-06-04T01:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-1-枚举"><a href="#8-1-枚举" class="headerlink" title="8.1 枚举"></a>8.1 枚举</h1><h2 id="8-1-1-什么是枚举"><a href="#8-1-1-什么是枚举" class="headerlink" title="8.1.1 什么是枚举"></a>8.1.1 什么是枚举</h2><p>类的对象只有有限个的、确定的<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">星期：Monday(星期一)......Sunday(星期天)</span><br><span class="line">性别：Man(男)、Woman(女)</span><br><span class="line">月份：January(1月)......December(12月)</span><br><span class="line">季节：Spring(春节)......Winter(冬天)</span><br><span class="line">七彩标准色：Red(红)......Purple(紫)</span><br><span class="line">支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</span><br><span class="line">就职状态：Busy、Free、Vocation、Dimission</span><br><span class="line">订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</span><br></pre></td></tr></table></figure></p><h2 id="8-1-2-如何定义枚举类型"><a href="#8-1-2-如何定义枚举类型" class="headerlink" title="8.1.2 如何定义枚举类型"></a>8.1.2 如何定义枚举类型</h2><p>要点：</p><ul><li>私有化类的构造器，保证不能在类的外部创建其对象 </li><li>在类的内部创建枚举类的实例。声明为：public static final </li></ul><p>JDK1.5之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TestEnumType &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Season s = Season.SPRING;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Season&#123;</span><br><span class="line">public static final Season SPRING = new Season();</span><br><span class="line">public static final Season SUMMER = new Season();</span><br><span class="line">public static final Season AUTUMN = new Season();</span><br><span class="line">public static final Season WINTER = new Season();</span><br><span class="line"></span><br><span class="line">private Season()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()&#123;</span><br><span class="line">if(this == SPRING)&#123;</span><br><span class="line">return &quot;SPRING&quot;;</span><br><span class="line">&#125;else if(this == SUMMER)&#123;</span><br><span class="line">return &quot;SUMMER&quot;;</span><br><span class="line">&#125;else if(this == AUTUMN)&#123;</span><br><span class="line">return &quot;AUTUMN&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return &quot;WINTER&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.5之后：</p><ul><li>使用 enum 定义的枚举类默认继承了 java.lang.Enum类。因此不能再继承其他类。</li><li>枚举类的所有构造器只能使用 private 访问控制符</li><li>枚举类的所有实例必须在枚举类中显式列出(, 分隔    ; 结尾)，必须在枚举类的第一行声明枚举类对象。列出的实例系统会自动添加 public static final 修饰</li><li>JDK 1.5 之后可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.enumtype.after15;</span><br><span class="line"></span><br><span class="line">public class TestEnumType &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Season s = Season.SPRING;</span><br><span class="line">switch(s)&#123;</span><br><span class="line">case SPRING:</span><br><span class="line">System.out.println(&quot;春暖花开&quot;);break;</span><br><span class="line">case SUMMER:</span><br><span class="line">System.out.println(&quot;夏日炎炎&quot;);break;</span><br><span class="line">case AUTUMN:</span><br><span class="line">System.out.println(&quot;秋高气爽&quot;);break;</span><br><span class="line">case WINTER:</span><br><span class="line">System.out.println(&quot;白雪皑皑&quot;);break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">enum Season&#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-1-3-java-lang-Enum类的方法"><a href="#8-1-3-java-lang-Enum类的方法" class="headerlink" title="8.1.3 java.lang.Enum类的方法"></a>8.1.3 java.lang.Enum类的方法</h2><p>除了toString方法，都是final修饰的方法，因此都不能重写</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530132629.png" alt></p><p>还有两个API文档中没有，但枚举类类拥有并且常用的方法</p><ul><li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li><li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常。</li></ul><h2 id="8-1-4-枚举的特别说明"><a href="#8-1-4-枚举的特别说明" class="headerlink" title="8.1.4 枚举的特别说明"></a>8.1.4 枚举的特别说明</h2><h3 id="1、枚举中定义属性"><a href="#1、枚举中定义属性" class="headerlink" title="1、枚举中定义属性"></a>1、枚举中定义属性</h3><ul><li>枚举类对象的属性不应允许被改动, 所以应该使用 private final修饰。不是语法要求，而是语义要求。</li><li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值。</li><li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.enumtype.before15;</span><br><span class="line"></span><br><span class="line">public class TestWeekField &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Week w = Week.MONDAY;</span><br><span class="line">System.out.println(w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enum Week&#123;</span><br><span class="line">MONDAY(&quot;星期一&quot;),</span><br><span class="line">TUESDAY(&quot;星期二&quot;),</span><br><span class="line">WEDNESDAY(&quot;星期三&quot;),</span><br><span class="line">THURSDAY(&quot;星期四&quot;),</span><br><span class="line">FRIDAY(&quot;星期五&quot;),</span><br><span class="line">SATURDAY(&quot;星期六&quot;),</span><br><span class="line">SUNDAY(&quot;星期日&quot;);</span><br><span class="line">private final String DESCRPTION;</span><br><span class="line"></span><br><span class="line">private Week(String dESCRPTION) &#123;</span><br><span class="line">DESCRPTION = dESCRPTION;</span><br><span class="line">&#125;</span><br><span class="line">public String toString()&#123;</span><br><span class="line">return DESCRPTION;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、枚举类可以自定义方法"><a href="#2、枚举类可以自定义方法" class="headerlink" title="2、枚举类可以自定义方法"></a>2、枚举类可以自定义方法</h3><p>静态和非静态</p><h3 id="3、枚举类可以实现一个或者多个接口（了解）"><a href="#3、枚举类可以实现一个或者多个接口（了解）" class="headerlink" title="3、枚举类可以实现一个或者多个接口（了解）"></a>3、枚举类可以实现一个或者多个接口（了解）</h3><ul><li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Change&#123;</span><br><span class="line">void degenerate();</span><br><span class="line">&#125;</span><br><span class="line">interface Checkable&#123;</span><br><span class="line">void check();</span><br><span class="line">&#125;</span><br><span class="line">enum Gender implements Change,Checkable&#123;</span><br><span class="line">MAN&#123;</span><br><span class="line">public void degenerate()&#123;</span><br><span class="line">System.out.println(&quot;咔嚓一刀&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,WOMAN&#123;</span><br><span class="line">public void degenerate()&#123;</span><br><span class="line">System.out.println(&quot;比较复杂&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">public void check()&#123;</span><br><span class="line">System.out.println(&quot;脱光&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、枚举类可以自己定义抽象方法（了解）"><a href="#4、枚举类可以自己定义抽象方法（了解）" class="headerlink" title="4、枚举类可以自己定义抽象方法（了解）"></a>4、枚举类可以自己定义抽象方法（了解）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">enum Payment&#123;</span><br><span class="line">CASH&#123;</span><br><span class="line">public void pay()&#123;</span><br><span class="line">System.out.println(&quot;现金支付&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">WECHAT&#123;</span><br><span class="line">public void pay()&#123;</span><br><span class="line">System.out.println(&quot;微信支付&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">ALIPAY&#123;</span><br><span class="line">public void pay()&#123;</span><br><span class="line">System.out.println(&quot;支付鸨支付&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">CARD&#123;</span><br><span class="line">public void pay()&#123;</span><br><span class="line">System.out.println(&quot;银行卡支付&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">CREDIT&#123;</span><br><span class="line">public void pay()&#123;</span><br><span class="line">System.out.println(&quot;信用卡支付&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">public abstract void pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-1-5-关于枚举的拓展"><a href="#8-1-5-关于枚举的拓展" class="headerlink" title="8.1.5 关于枚举的拓展"></a>8.1.5 关于枚举的拓展</h2><p>java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的key是enum类型，而value则可以是任意类型。关于这个两个集合的使用就不在这里赘述，可以参考JDK文档。</p><h1 id="8-2-注解Annotation"><a href="#8-2-注解Annotation" class="headerlink" title="8.2 注解Annotation"></a>8.2 注解Annotation</h1><p>注解Annotation是从JDK5.0开始引入的新特性。</p><h2 id="8-2-1-注解的概述"><a href="#8-2-1-注解的概述" class="headerlink" title="8.2.1 注解的概述"></a>8.2.1 注解的概述</h2><h3 id="1、Annotation的作用"><a href="#1、Annotation的作用" class="headerlink" title="1、Annotation的作用"></a>1、Annotation的作用</h3><ul><li>注解不是程序本身，可以对程序作出解释。（这一点，跟注释没什么区别）</li><li>可以被其他程序（比如：编译器，Checker Framework等）读取。（注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义）<h3 id="2、Annotation的格式"><a href="#2、Annotation的格式" class="headerlink" title="2、Annotation的格式"></a>2、Annotation的格式</h3>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(value=”unchecked”)</span><br></pre></td></tr></table></figure><h3 id="3、Annotation在哪里使用"><a href="#3、Annotation在哪里使用" class="headerlink" title="3、Annotation在哪里使用"></a>3、Annotation在哪里使用</h3><p>Annotation 可以像修饰符一样被使用, 可用于修饰包，类, 构造器, 方法, 成员变量, 参数, 局部变量。相当于给它们添加了额外的辅助信息，而且有些注解我们可以通过反射机制编程实现对这些元数据的访问。</p><h2 id="8-2-2-常见的注解示例"><a href="#8-2-2-常见的注解示例" class="headerlink" title="8.2.2 常见的注解示例"></a>8.2.2 常见的注解示例</h2><h3 id="1、生成文档"><a href="#1、生成文档" class="headerlink" title="1、生成文档"></a>1、生成文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@author 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line">@version 标明该类模块的版本</span><br><span class="line">@see 参考转向，也就是相关主题</span><br><span class="line">@since 从哪个版本开始增加的</span><br><span class="line">@param 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line">@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</span><br><span class="line">@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</span><br><span class="line">其中 @param  @return 和 @exception 这三个标记都是只用于方法的。</span><br><span class="line">@param的格式要求：@param 形参名 形参类型  形参说明</span><br><span class="line">@return 的格式要求：@return 返回值类型 返回值说明</span><br><span class="line">@exception的格式要求：@exception 异常类型 异常说明</span><br><span class="line">@param和@exception可以并列多个</span><br><span class="line">javadoc.exe就是这些注解的信息处理流程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.javadoc;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @author Irene</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @see Math.java</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestJavadoc &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 程序的主方法，程序的入口</span><br><span class="line"> * @param args String[] 命令行参数</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 求圆面积的方法</span><br><span class="line"> * @param radius double 半径值</span><br><span class="line"> * @return double 圆的面积</span><br><span class="line"> */</span><br><span class="line">public static double getArea(double radius)&#123;</span><br><span class="line">return Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530133407.png" alt></p><h3 id="2、在编译时进行格式检查"><a href="#2、在编译时进行格式检查" class="headerlink" title="2、在编译时进行格式检查"></a>2、在编译时进行格式检查</h3><p> JDK中系统内置了常用的三个注解：<br> （1）@Override：按照重写的要求检查方法的格式<br> （2）@Deprecated：过时，表示不鼓励程序员使用这样的元素，因为存在危险或有更好的实现<br> （3）@SuppressWarnings：抑制警告 </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000425.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.javadoc;</span><br><span class="line"></span><br><span class="line">public class TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">int a = 10;</span><br><span class="line">&#125;</span><br><span class="line">@Deprecated</span><br><span class="line">public void print()&#123;</span><br><span class="line">System.out.println(&quot;过时的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;重写的toString方法()&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、跟踪代码依赖性，实现替代配置文件功能"><a href="#3、跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="3、跟踪代码依赖性，实现替代配置文件功能"></a>3、跟踪代码依赖性，实现替代配置文件功能</h3><p>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.servlet;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/login&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>spring框架中关于“事务”的管理<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation=Propagation.REQUIRES_NEW,</span><br><span class="line">isolation=Isolation.READ_COMMITTED,</span><br><span class="line">readOnly=false,</span><br><span class="line">                timeout=3)</span><br><span class="line">public void buyBook(String username, String isbn) &#123;</span><br><span class="line">//1.查询书的单价</span><br><span class="line">int price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">//2. 更新库存</span><br><span class="line">bookShopDao.updateBookStock(isbn);</span><br><span class="line">//3. 更新用户的余额</span><br><span class="line">bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line">     &lt;!-- 配置事务属性 --&gt;</span><br><span class="line"> &lt;tx:advice transaction-manager=&quot;dataSourceTransactionManager&quot; id=&quot;txAdvice&quot;&gt;</span><br><span class="line">  &lt;tx:attributes&gt;</span><br><span class="line">  &lt;!-- 配置每个方法使用的事务属性 --&gt;</span><br><span class="line">  &lt;tx:method name=&quot;buyBook&quot; propagation=&quot;REQUIRES_NEW&quot; </span><br><span class="line">     isolation=&quot;READ_COMMITTED&quot;  read-only=&quot;false&quot; </span><br><span class="line">     timeout=&quot;3&quot; /&gt;</span><br><span class="line">  &lt;/tx:attributes&gt;</span><br><span class="line"> &lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure></p><h3 id="4、JUnit框架中的注解"><a href="#4、JUnit框架中的注解" class="headerlink" title="4、JUnit框架中的注解"></a>4、JUnit框架中的注解</h3><ul><li>JUnit是由 Erich Gamma 和 Kent Beck 编写的一个回归测试框架（regression testing framework）,供Java开发人员编写单元测试之用。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。</li><li>Junit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。<h4 id="1-如何使用JUnit"><a href="#1-如何使用JUnit" class="headerlink" title="1 如何使用JUnit"></a>1 如何使用JUnit</h4>要使用JUnit，必须在项目的编译路径中必须引入JUnit的库，即相关的.class文件组成的jar包。<br>如何把JUnit的jar添加到编译路径如图所示：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134033.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134123.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134149.png" alt></p><h4 id="2-JUnit的常用注解"><a href="#2-JUnit的常用注解" class="headerlink" title="2 JUnit的常用注解"></a>2 JUnit的常用注解</h4><ul><li>使用JUnit测试的类必须是public的。</li><li>JUnit4常见的注解和要求：这些方法都必须是public，无参，无返回值。</li><li>@Test：标记在非静态的测试方法上。只有标记@Test的方法才能被作为一个测试方法单独测试。一个类中可以有多个@Test标记的方法。运行时如果只想运行其中一个@Test标记的方法，那么选择这个方法名，然后单独运行，否则整个类的所有标记了@Test的方法都会被执行。-</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test(timeout=1000)：设置超时时间，如果测试时间超过了你定义的timeout，测试失败</span><br><span class="line">@Test(expected)： 申明出会发生的异常，比如 @Test（expected = Exception.class）</span><br><span class="line">了解：</span><br><span class="line">@BeforeClass：标记在静态方法上。因为这个方法只执行一次。在类初始化时执行。</span><br><span class="line">@AfterClass：标记在静态方法上。因为这个方法只执行一次。在所有方法完成后执行。</span><br><span class="line">@Before：标记在非静态方法上。在@Test方法前面执行，而且是在每一个@Test方法前面都执行</span><br><span class="line">@After：标记在非静态方法上。在@Test方法后面执行，而且是在每一个@Test方法后面都执行</span><br><span class="line">@Ignore：标记在本次不参与测试的方法上。这个注解的含义就是“某些方法尚未完成，暂不参与此次测试”。</span><br><span class="line">@BeforeClass、@AfterClass、@Before、@After、@Ignore都是配合@Test它使用的，单独使用没有意义。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.AfterClass;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.BeforeClass;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestJUnit2 &#123;</span><br><span class="line">private static Object[] array;</span><br><span class="line">private static int total;</span><br><span class="line"></span><br><span class="line">@BeforeClass</span><br><span class="line">public static void init()&#123;</span><br><span class="line">System.out.println(&quot;初始化数组&quot;);</span><br><span class="line">array = new Object[5];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void before()&#123;</span><br><span class="line">System.out.println(&quot;调用之前total=&quot; + total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void add()&#123;</span><br><span class="line">//往数组中存储一个元素</span><br><span class="line">System.out.println(&quot;add&quot;);</span><br><span class="line">array[total++] = &quot;hello&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@After</span><br><span class="line">public void after()&#123;</span><br><span class="line">System.out.println(&quot;调用之前total=&quot; + total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterClass</span><br><span class="line">public static void destroy()&#123;</span><br><span class="line">array = null;</span><br><span class="line">System.out.println(&quot;销毁数组&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-如何运行Junit测试方法"><a href="#3-如何运行Junit测试方法" class="headerlink" title="3 如何运行Junit测试方法"></a>3 如何运行Junit测试方法</h4><p>一个类中可以有多个@Test标记的方法，运行时如果只想运行其中一个@Test标记的方法，那么选择这个方法名，然后单独运行，否则整个类的所有标记了@Test的方法都会被执行。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134423.png" alt></p><h2 id="8-2-3-自定义注解与反射读取注解"><a href="#8-2-3-自定义注解与反射读取注解" class="headerlink" title="8.2.3 自定义注解与反射读取注解"></a>8.2.3 自定义注解与反射读取注解</h2><ul><li>定义新的 Annotation 类型使用 @interface 关键字</li><li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明. 其方法名和返回值定义了该成员的名字和类型. 我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li><li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</li><li>如果只有一个参数成员，建议使用参数名为value</li><li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”</li><li>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation</li><li>注意：自定义注解必须配上注解的信息处理流程才有意义。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.javadoc;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@MyAnnotation(value=&quot;尚硅谷&quot;)</span><br><span class="line">public class TestMyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Class clazz = TestMyAnnotation.class;</span><br><span class="line">Annotation a = clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">MyAnnotation m = (MyAnnotation) a;</span><br><span class="line">String info = m.value();</span><br><span class="line">System.out.println(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">String value() default &quot;auguigu&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-4-元注解"><a href="#8-2-4-元注解" class="headerlink" title="8.2.4 元注解"></a>8.2.4 元注解</h2><blockquote><p>Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）@Target</span><br><span class="line">（2）@Retention</span><br><span class="line">（3）@Documented</span><br><span class="line">（4）@Inherited</span><br></pre></td></tr></table></figure><p>在java.lang.annotation包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、@Target</span><br><span class="line">作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530134908.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2、@Retention</span><br><span class="line">@Retention定义了该Annotation被保留的时间长短</span><br><span class="line">作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</span><br><span class="line">@Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:</span><br><span class="line">取值（RetentionPoicy）有：</span><br><span class="line">SOURCE:在源文件中有效（即源文件保留）</span><br><span class="line">CLASS:在class文件中有效（即class保留） 这是默认值</span><br><span class="line">RUNTIME:在运行时有效（即运行时保留）当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000638.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3、@Documented</span><br><span class="line">Documented 注解表明这个注解应该被 javadoc工具记录。默认情况下,javadoc是不包括注解的，但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理。</span><br><span class="line">4、@Inherited</span><br><span class="line">允许子类继承父类中的注解</span><br></pre></td></tr></table></figure></p><h2 id="8-2-5-JDK1-8注解的新特性"><a href="#8-2-5-JDK1-8注解的新特性" class="headerlink" title="8.2.5 JDK1.8注解的新特性"></a>8.2.5 JDK1.8注解的新特性</h2><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。  </p><h3 id="1、可重复注解"><a href="#1、可重复注解" class="headerlink" title="1、可重复注解"></a>1、可重复注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestOldAnnotation &#123;</span><br><span class="line"></span><br><span class="line">@RoleAnnotations(&#123;@RoleAnnotation(role=&quot;admin&quot;),@RoleAnnotation(role=&quot;manager&quot;),@RoleAnnotation(role=&quot;saler&quot;)&#125;)</span><br><span class="line">public void add()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@interface RoleAnnotation&#123;</span><br><span class="line">String role() default &quot;admin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//表示target是所有</span><br><span class="line">@interface RoleAnnotations&#123;</span><br><span class="line">RoleAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8之后，可读性更好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Repeatable;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">public class TestNewAnnotation &#123;</span><br><span class="line"></span><br><span class="line">@LimitAnnotation(role=&quot;admin&quot;)</span><br><span class="line">@LimitAnnotation(role=&quot;manager&quot;)</span><br><span class="line">@LimitAnnotation(role=&quot;saler&quot;)</span><br><span class="line">public void test()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)      此处的target必须与LimitAnnotation一致</span><br><span class="line">@interface LimitAnnotations&#123;</span><br><span class="line">LimitAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(LimitAnnotations.class)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@interface LimitAnnotation&#123;</span><br><span class="line">String role() default &quot;admin&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、类型注解"><a href="#2、类型注解" class="headerlink" title="2、类型注解"></a>2、类型注解</h3><p>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    /** Class, interface (including annotation type), or enum declaration */</span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    /** Field declaration (includes enum constants) */</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    /** Method declaration */</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    /** Formal parameter declaration */</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    /** Constructor declaration */</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    /** Local variable declaration */</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    /** Annotation type declaration */</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    /** Package declaration */</span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在java 8之前，注解只能是在声明的地方所使用，java8开始，注解可以应用在任何地方。</li><li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（eg：泛型声明）。</li><li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package.com.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">public class TestTypeDefine&lt;@TypeDefine() U&gt; &#123;</span><br><span class="line"></span><br><span class="line">private U u;</span><br><span class="line"></span><br><span class="line">public &lt;@TypeDefine() T&gt; void test(T t)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@interface TypeDefine&#123;</span><br><span class="line">&#125;</span><br><span class="line">package com.atguigu.anno;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@MyAnnotation</span><br><span class="line">public class TestAnnotation&lt;U&gt;&#123;</span><br><span class="line">@MyAnnotation</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TestAnnotation &lt;@MyAnnotation String&gt; t = null;</span><br><span class="line">int a = (@MyAnnotation int)2L;</span><br><span class="line">@MyAnnotation int b = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;@MyAnnotation T&gt; void method(T t)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void test(@MyAnnotation String arg)throws @MyAnnotation Exception&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE_USE)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型注解被用来支持在Java的程序中做强类型检查。配合第三方插件工具Checker Framework（使用Checker Framework可以找到类型注解出现的地方并检查），可以在编译的时候检测出<code>runtime error（eg：UnsupportedOperationException； NumberFormatException；NullPointerException异常等都是runtime error）</code>，以提高代码质量。这就是类型注解的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package checker;</span><br><span class="line"></span><br><span class="line">import org.checkerframework.checker.nullness.qual.NonNull;</span><br><span class="line"></span><br><span class="line">public class TestChecker &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Object obj = null;</span><br><span class="line">printNonNullToString(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void printNonNullToString(@NonNull Object object) &#123;</span><br><span class="line">System.out.println(object.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000751.png" alt></p><p>进入源代码目录   通过javac编译  -processor 后面接注释处理流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac  -processor org.checkerframework.checker.nullness.NullnessChecker TestChecker.java</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604000832.png" alt></p><p>警告处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -Xbootclasspath/p:D:\software\eclipse\checker-framework-2.1.13\checker\dist\jdk8.jar -processor org.checkerframework.checker.nullness.NullnessChecker TestChecker.java</span><br></pre></td></tr></table></figure><p>要配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath=.;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar;D:\software\eclipse\checker-framework-2.1.13\checker\dist\checker.jar;D:\software\eclipse\checker-framework-2.1.13\checker\dist\checker-qual.jar;</span><br></pre></td></tr></table></figure><p>注意</p><ul><li>java 5,6,7版本是不支持注解@NonNull，但checker framework 有个向下兼容的解决方案，就是将类型注解@NonNull 用/**/注释起来。 </li></ul><p>这样javac编译器就会忽略掉注释块，但用checker framework里面的javac编译器同样能够检测出@NonNull错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;8-1-枚举&quot;&gt;&lt;a href=&quot;#8-1-枚举&quot; class=&quot;headerlink&quot; title=&quot;8.1 枚举&quot;&gt;&lt;/a&gt;8.1 枚举&lt;/h1&gt;&lt;h2 id=&quot;8-1-1-什么是枚举&quot;&gt;&lt;a href=&quot;#8-1-1-什么是枚举&quot; class=&quot;header
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>7. JavaSE-面向对象高级特性</title>
    <link href="http://yoursite.com/2016/10/28/7.%20JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/10/28/7. JavaSE-面向对象高级特性/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2019-06-04T01:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-1-Object类"><a href="#7-1-Object类" class="headerlink" title="7.1 Object类"></a>7.1 Object类</h1><h2 id="7-1-1-Object类的特点"><a href="#7-1-1-Object类的特点" class="headerlink" title="7.1.1 Object类的特点"></a>7.1.1 Object类的特点</h2><blockquote><p>Object类是所有类的根父类, 也就是说如果一个类没有显式声明父类, 那么这个类的父类就是Object类,<br>所以, Object类中的属性和方法会被所有类继承, 都可以直接调用.</p></blockquote><h2 id="7-1-2-类中的典型方法"><a href="#7-1-2-类中的典型方法" class="headerlink" title="7.1.2 类中的典型方法"></a>7.1.2 类中的典型方法</h2><h3 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString()"></a>1. toString()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String toString()</span><br></pre></td></tr></table></figure><p>这个方法返回当前对象的一个字符串表示, 通常用于描述这个对象的内容.<br>这个方法也会在对象被打印和与字符串拼接时自动调用, 结果还是一个字符串.</p><h3 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals()"></a>2. equals()</h3><p>表示两个对象内容是否相等, 通常情况下, 两个不同的对象是不相等的, 但是我们可以通过覆盖这个方法,实现两个内容相等, 但不同的对象之间具有等同性比较能力. </p><h3 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode()"></a>3. hashCode()</h3><p>当两个对象的内容相等时, <strong>equals方法的结果就应该返回true</strong>, 但同时这两个对象调用hashCode方法返回的哈希码值也必须要相等, 相同的道理, 两个hashCode码值不同的对象, <strong>equals方法一定返回false</strong>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line"></span><br><span class="line">private int x;</span><br><span class="line">private int y;</span><br><span class="line"></span><br><span class="line">public Point() &#123;&#125;</span><br><span class="line">public Point(int x, int y) &#123;</span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setX(int x) &#123;</span><br><span class="line">this.x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getX() &#123;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setY(int y) &#123;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getY() &#123;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;X:&quot; + x + &quot;,Y:&quot; + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override // 可以完成真实的比较</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">if (obj instanceof Point &amp;&amp; this.x == ((Point)obj).x &amp;&amp; this.y == ((Point)obj).y) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">return Integer.parseInt(x * 10 + &quot;&quot; + y * 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回对象的字符串表示, 通常在打印对象时调用</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;x:&quot; + x + &quot;,y:&quot; + y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class PointTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Point p1 = new Point(10, 20);</span><br><span class="line">Point p2 = new Point(10, 20);</span><br><span class="line">System.out.println(p1 == p2); // 打印false, 因为比较两个对象的地址</span><br><span class="line">boolean b = p1.equals(p2); // 返回true, 因为比较两个对象的内容</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line">System.out.println(p1.hashCode()); // 两个对象的哈希码也都一样</span><br><span class="line">System.out.println(p2.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(p1); // 打印对象时, 打印的其实是对象的toString()方法的结果</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-3-Object的使用"><a href="#7-1-3-Object的使用" class="headerlink" title="7.1.3 Object的使用"></a>7.1.3 Object的使用</h2><p>Object类型通常用于表示任意对象的引用类型, 使用Object类型可以兼容任意对象, 很灵活方便, 也因为Object类是根父类, 所以其中的方法具有普遍性, 便于统一处理.</p><h2 id="7-1-4-Object的注意点"><a href="#7-1-4-Object的注意点" class="headerlink" title="7.1.4 Object的注意点"></a>7.1.4 Object的注意点</h2><p>因为Object类型是父类类型, 所以Object类型的对象究竟是什么类型的对象就变得非常复杂, 所以想要处理不同的子类对象, 比较麻烦, 需要配合instanceof操作符和类型转换. </p><h1 id="7-2-static关键字"><a href="#7-2-static关键字" class="headerlink" title="7.2 static关键字"></a>7.2 static关键字</h1><h2 id="7-2-1-static关键字含义"><a href="#7-2-1-static关键字含义" class="headerlink" title="7.2.1 static关键字含义"></a>7.2.1 static关键字含义</h2><h3 id="1-为什么要使用static"><a href="#1-为什么要使用static" class="headerlink" title="1. 为什么要使用static"></a>1. 为什么要使用static</h3><blockquote><ul><li>有一些数据不必要隶属于每个对象, 例如Chinese类的country属性就应该是China,并且所有对象都应该是相同的, 这样的数据就可以声明成static的, 这样的数据就隶属于类, 通过类就可以直接访问, 当然通过对象也可以访问. </li><li>有一些方法也是相同的道理, 可以被static修饰, 这样的方法只需要通过类调用即可, 不需要创建对象.</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095828.png" alt></p><h3 id="2-使用了static后的变化"><a href="#2-使用了static后的变化" class="headerlink" title="2. 使用了static后的变化"></a>2. 使用了static后的变化</h3><p>使用了static以后的数据不再是不确定的, 就像对象的创建就是不确定的(也可称之为动态), static是确定的, 和动态形成对比, 所以称之为静态. </p><h3 id="3-使用范围："><a href="#3-使用范围：" class="headerlink" title="3.使用范围："></a>3.使用范围：</h3><p>在Java类中，可用static修饰属性、方法、代码块、内部类</p><h3 id="4-被修饰后的成员具备以下特点："><a href="#4-被修饰后的成员具备以下特点：" class="headerlink" title="4.被修饰后的成员具备以下特点："></a>4.被修饰后的成员具备以下特点：</h3><p>①    随着类的加载而加载<br>②    优先于对象存在<br>③    修饰的成员，被所有对象所共享<br>④    访问权限允许时，可不创建对象，直接被类调用  </p><h2 id="7-2-2-static修饰属性"><a href="#7-2-2-static修饰属性" class="headerlink" title="7.2.2 static修饰属性"></a>7.2.2 static修饰属性</h2><h3 id="1-类属性"><a href="#1-类属性" class="headerlink" title="1. 类属性"></a>1. 类属性</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530095936.png" alt></p><h3 id="2-类属性的存储"><a href="#2-类属性的存储" class="headerlink" title="2. 类属性的存储"></a>2. 类属性的存储</h3><p>类属性保存在方法区的类信息数据区中</p><h3 id="3-类属性的使用"><a href="#3-类属性的使用" class="headerlink" title="3. 类属性的使用"></a>3. 类属性的使用</h3><p>类属性可以直接通过类名使用</p><h3 id="4-静态属性的特点"><a href="#4-静态属性的特点" class="headerlink" title="4. 静态属性的特点"></a>4. 静态属性的特点</h3><p>因为隶属于类, 所以静态属性通常是共享数据</p><h2 id="7-2-3-static-修饰方法"><a href="#7-2-3-static-修饰方法" class="headerlink" title="7.2.3 static 修饰方法"></a>7.2.3 static 修饰方法</h2><h3 id="1-类方法-class-Method"><a href="#1-类方法-class-Method" class="headerlink" title="1. 类方法(class Method)"></a>1. 类方法(class Method)</h3><ul><li>没有对象的实例时，可以用类名.方法名()的形式访问由static标记的类方法。</li><li>在static方法内部只能访问类的static属性，不能访问类的非static属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">private int id;</span><br><span class="line">       private static int total = 0;</span><br><span class="line">       public static int getTotalPerson() &#123; </span><br><span class="line">    id++;//非法</span><br><span class="line">return total;</span><br><span class="line">       &#125;</span><br><span class="line">       public Person() &#123;</span><br><span class="line">         total++;</span><br><span class="line"> id = total;</span><br><span class="line">       &#125;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line"> System.out.println(&quot;Number of total is &quot; +Person.getTotalPerson());</span><br><span class="line">//没有创建对象也可以访问静态方法</span><br><span class="line"> Person p1 = new Person();</span><br><span class="line">     System.out.println( &quot;Number of total is &quot;+ p1.getTotalPerson());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类方法特点"><a href="#2-类方法特点" class="headerlink" title="2. 类方法特点"></a>2. 类方法特点</h3><p>类方法隶属于类, 不能在其中直接访问对象属性, 如果想要访问对象属性, 必须先创建对象, 通过对象再访问对象属性. 而在非静态方法中, 可以直接调用类方法.</p><h2 id="7-2-4单例设计模式"><a href="#7-2-4单例设计模式" class="headerlink" title="7.2.4单例设计模式"></a>7.2.4单例设计模式</h2><blockquote><ul><li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。</li><li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造方法的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</li></ul></blockquote><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100642.png" alt></p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><img src="http://note.youdao.com/yws/res/5869/67679F24EB994B5487180C512B907812" alt="image"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100824.png" alt></p><h1 id="7-3-代码块"><a href="#7-3-代码块" class="headerlink" title="7.3 代码块"></a>7.3 代码块</h1><h2 id="7-3-1-什么是代码块"><a href="#7-3-1-什么是代码块" class="headerlink" title="7.3.1 什么是代码块"></a>7.3.1 什么是代码块</h2><h3 id="1-什么是代码块"><a href="#1-什么是代码块" class="headerlink" title="1. 什么是代码块"></a>1. 什么是代码块</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530100959.png" alt></p><h3 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2.静态代码块"></a>2.静态代码块</h3><ul><li>一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。</li><li>static块通常用于初始化static (类)属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public static int total;</span><br><span class="line">static &#123;</span><br><span class="line">        total = 100;//为total赋初值 </span><br><span class="line">&#125;</span><br><span class="line">…… //其它属性或方法声明</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-非静态代码块"><a href="#3-非静态代码块" class="headerlink" title="3. 非静态代码块"></a>3. 非静态代码块</h3><ul><li>概念：没有static修饰的代码块</li><li>特点：<br>①    可以有输出语句。<br>②    可以对类的属性、类的声明进行初始化操作。<br>③    可以调用静态的变量或方法。<br>④    若有多个非静态的代码块，那么按照从上到下的顺序依次执行。<br>⑤    每次创建对象的时候，都会执行一次。且先于构造器执行  </li></ul><h3 id="4-静态和非静态关系"><a href="#4-静态和非静态关系" class="headerlink" title="4 静态和非静态关系"></a>4 静态和非静态关系</h3><h4 id="非静态的本质是什么"><a href="#非静态的本质是什么" class="headerlink" title="非静态的本质是什么"></a>非静态的本质是什么</h4><p>非静态也可以称为动态, 意思是确定的, 在程序中对象的创建是不确定的, 因为只要new就会产生对象, 所以非静态的概念必然是和对象相关的.</p><h4 id="静态的本质是什么"><a href="#静态的本质是什么" class="headerlink" title="静态的本质是什么"></a>静态的本质是什么</h4><p>静态的就是确定的, 唯一的, 在程序中是稳定的, 和有无对象无关, 也和有多少对象无关, 只和类相关, 所以, 所以静态成员是稳定并唯一的.</p><h4 id="如何互相使用"><a href="#如何互相使用" class="headerlink" title="如何互相使用"></a>如何互相使用</h4><p>在非静态环境中可以中直接使用静态成员, 因为在非静态环境中, 对象必然是已经创建了, 对象既然已经创建, 类也肯定已经加载过了, 所以在使用上并不会有问题.</p><blockquote><p>但是 在静态环境中却不可以直接使用非静态成员, 因为静态成员可以使用, 不要求对象,只要求类加载好就可以了, 但是类加载, 并不意味着一定要创建对象, 并且对象创建在哪里也不知道. 所以在静态环境中不可以直接访问非静态成员, 因为非静态成员隶属于对象, 所以在静态环境中只能通过创建对象, 并再通过对象来间接访问非静态成员.</p></blockquote><h2 id="7-3-2-执行顺序"><a href="#7-3-2-执行顺序" class="headerlink" title="7.3.2 执行顺序"></a>7.3.2 执行顺序</h2><h3 id="1-创建对象时-在同一个类中执行顺序"><a href="#1-创建对象时-在同一个类中执行顺序" class="headerlink" title="1. 创建对象时, 在同一个类中执行顺序"></a>1. 创建对象时, 在同一个类中执行顺序</h3><p>在同一个类中, 如果创建这个类的对象, 执行顺序是</p><blockquote><p>1静态属性声明<br>2静态语句块或静态属性的显式初始化<br>3非静态属性声明<br>4非静态语句块或非静态属性的显式初始化<br>构造器</p></blockquote><h3 id="2-创建对象时-有继承关系存在时执行顺序"><a href="#2-创建对象时-有继承关系存在时执行顺序" class="headerlink" title="2. 创建对象时, 有继承关系存在时执行顺序"></a>2. 创建对象时, 有继承关系存在时执行顺序</h3><p>a)    父类的静态属性声明<br>b)    父类的静态语句块或父类静态属性的显式赋值<br>c)    子类的静态属性声明<br>d)    子类的静态语句块或子类静态属性的显式赋值<br>e)    父类非静态属性的声明<br>f)    子类非静态属性的声明<br>g)    父类的非静态语句块或父类非静态属性的显式赋值<br>h)    父类构造器<br>i)    子类的非静态语句块或子类非静态属性的显式赋值<br>j)    子类构造器  </p><h1 id="7-4-final关键字"><a href="#7-4-final关键字" class="headerlink" title="7.4 final关键字"></a>7.4 final关键字</h1><h2 id="7-4-1-final关键字的含义"><a href="#7-4-1-final关键字的含义" class="headerlink" title="7.4.1 final关键字的含义"></a>7.4.1 final关键字的含义</h2><h3 id="1-final的作用"><a href="#1-final的作用" class="headerlink" title="1. final的作用"></a>1. final的作用</h3><ul><li>在Java中声明类、属性和方法时，可使用关键字final来修饰,表示“最终”。</li><li>final标记的类不能被继承。提高安全性，提高程序的可读性。<br><code>比如：String类、System类、StringBuffer类</code></li><li>final标记的方法不能被子类重写。<br><code>比如：Object类中的getClass()。</code></li><li>final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。</li><li>final标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。<br><code>比如：final double PI=3.14;</code></li></ul><h2 id="7-4-2-final修饰类"><a href="#7-4-2-final修饰类" class="headerlink" title="7.4.2 final修饰类"></a>7.4.2 final修饰类</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101645.png" alt></p><h2 id="7-4-3-final修饰方法"><a href="#7-4-3-final修饰方法" class="headerlink" title="7.4.3 final修饰方法"></a>7.4.3 final修饰方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101723.png" alt></p><h2 id="7-4-4-final修饰变量"><a href="#7-4-4-final修饰变量" class="headerlink" title="7.4.4 final修饰变量"></a>7.4.4 final修饰变量</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530101918.png" alt></p><h2 id="7-7-5-空final量和final修饰局部变量"><a href="#7-7-5-空final量和final修饰局部变量" class="headerlink" title="7.7.5 空final量和final修饰局部变量"></a>7.7.5 空final量和final修饰局部变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Test &#123;</span><br><span class="line"></span><br><span class="line">public static int totalNumber = 5 ;</span><br><span class="line">public final int ID; // 空final量, 在构造器中初始化</span><br><span class="line"></span><br><span class="line">public Test()&#123;</span><br><span class="line">ID = ++totalNumber;  //可在构造方法中给final变量赋值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test t = new Test();</span><br><span class="line">System.out.println(t.ID);</span><br><span class="line">final int I = 10;</span><br><span class="line">final int J;</span><br><span class="line">J = 20;</span><br><span class="line">J = 30; // 不可以再次赋值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-5-native关键字"><a href="#7-5-native关键字" class="headerlink" title="7.5 native关键字"></a>7.5 native关键字</h1><h2 id="7-5-1-native含义"><a href="#7-5-1-native含义" class="headerlink" title="7.5.1 native含义"></a>7.5.1 native含义</h2><blockquote><p>native表示本地的意思, 可以修饰方法, 被native修饰的方法没有方法体, 所谓本地就是代码是和当前操作系统密切相关的. 方法没有java代码的方法体, 但是一定是使用了C/C++等编写成的, 并且封装在操作系统相关的库文件中. 在执行这样的方法时, 实际执行的是库中的代码.</p></blockquote><h2 id="7-5-2-native关键字使用场景"><a href="#7-5-2-native关键字使用场景" class="headerlink" title="7.5.2 native关键字使用场景"></a>7.5.2 native关键字使用场景</h2><p>有一些代码需要和底层设备交互, 而这些交互的功能并未由JDK提供现成的类库, 那么必须使用native方式让java程序和库交互, 再由库完成对底层设备的使用.</p><h2 id="7-5-3-native关键字特点"><a href="#7-5-3-native关键字特点" class="headerlink" title="7.5.3 native关键字特点"></a>7.5.3 native关键字特点</h2><p><strong>特点</strong>：用native修饰的方法是调用的库中的代码, 所以这样的代码如果再换一个平台就会出现问题, 无法实现跨平台.</p><h1 id="7-6-抽象类"><a href="#7-6-抽象类" class="headerlink" title="7.6 抽象类"></a>7.6 抽象类</h1><h2 id="7-6-1-抽象类概念"><a href="#7-6-1-抽象类概念" class="headerlink" title="7.6.1 抽象类概念"></a>7.6.1 抽象类概念</h2><h3 id="1-抽象类-abstract-class"><a href="#1-抽象类-abstract-class" class="headerlink" title="1.抽象类(abstract class)"></a>1.抽象类(abstract class)</h3><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类就可以声明为抽象类。</p><h3 id="2-抽象类和具体类"><a href="#2-抽象类和具体类" class="headerlink" title="2. 抽象类和具体类"></a>2. 抽象类和具体类</h3><p>抽象类与具体类</p><ul><li>具体类—对现实世界一种实体的抽象定义。</li><li>抽象类—对现实世界一种类型的多种实体的统一抽象定义。<br>例如： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pet类应定义为抽象类</span><br><span class="line">Bird类应定义为具体类</span><br><span class="line">抽象类中可声明抽象方法</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">public abstract class Pet &#123;</span><br><span class="line">            public abstract void speak();</span><br><span class="line">            ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-2特点"><a href="#7-6-2特点" class="headerlink" title="7.6.2特点"></a>7.6.2特点</h2><p>①用abstract关键字来修饰一个类时，这个类叫做抽象类；<br>②用abstract来修饰一个方法时，该方法叫做抽象方法。<br>抽象方法：只有方法的声明，没有方法的实现。以分号结束：<code>abstract int abstractMethod( int a );</code><br>含有抽象方法的类必须被声明为抽象类。</p><ul><li>抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。  </li><li>若没有重写全部的抽象方法，仍为抽象类。  </li><li>不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法。</li></ul><h2 id="7-6-3抽象类使用"><a href="#7-6-3抽象类使用" class="headerlink" title="7.6.3抽象类使用"></a>7.6.3抽象类使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Pet &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">private int weight;</span><br><span class="line"></span><br><span class="line">public Pet(String name, int age, int weight) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void speak(); // 抽象方法,仅有方法签名没有方法体,因此不能执行</span><br><span class="line"></span><br><span class="line">public abstract void eat(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Bird extends Pet &#123;</span><br><span class="line">private int flySpeed;</span><br><span class="line"></span><br><span class="line">public Bird(String name, int age, int weight, int flySpeed) &#123;</span><br><span class="line">super(name, age, weight);</span><br><span class="line">this. flySpeed = flySpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getFlySpeed() &#123;</span><br><span class="line">return flySpeed;</span><br><span class="line">&#125;</span><br><span class="line">public void speak() &#123;</span><br><span class="line">System.out.println(&quot;布谷布谷...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;Eating...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestAbstract &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Pet pet = new Bird(&quot;小布&quot;, 1, 100, 20); // 抽象类适用于多态</span><br><span class="line">        pet.speak(); // 虚拟方法调用, 执行子类方法, 父类方法是抽象的, 无法执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-4-使用场景"><a href="#7-6-4-使用场景" class="headerlink" title="7.6.4 使用场景"></a>7.6.4 使用场景</h2><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java允许类设计者指定：</span><br><span class="line">    超类声明一个方法但不提供实现，</span><br><span class="line">    该方法的实现由子类提供。</span><br><span class="line">    这样的方法称为抽象方法。</span><br><span class="line">    有一个或更多抽象方法的类称为抽象类。</span><br></pre></td></tr></table></figure><p>Vehicle是一个抽象类，有两个抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Vehicle&#123;</span><br><span class="line">public abstract double calcFuelEfficiency();//计算燃料效率的抽象方法</span><br><span class="line">public abstract double calcTripDistance();//计算行驶距离的抽象方法</span><br><span class="line">&#125;</span><br><span class="line">public class Truck extends Vehicle&#123;</span><br><span class="line">public double calcFuelEfficiency( )   &#123; //写出计算卡车的燃料效率的具体方法   &#125;</span><br><span class="line">public double calcTripDistance( )    &#123;  //写出计算卡车行驶距离的具体方法   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RiverBarge extends Vehicle&#123;</span><br><span class="line"> public double calcFuelEfficiency( ) &#123; //写出计算驳船的燃料效率的具体方法  &#125;</span><br><span class="line"> public double calcTripDistance( )  &#123;  //写出计算驳船行驶距离的具体方法&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：抽象类不能实例化   new Vihicle()是非法的</p><h1 id="7-7-接口"><a href="#7-7-接口" class="headerlink" title="7.7 接口"></a>7.7 接口</h1><h2 id="7-7-1-接口的概念"><a href="#7-7-1-接口的概念" class="headerlink" title="7.7.1 接口的概念"></a>7.7.1 接口的概念</h2><h3 id="1-什么是接口"><a href="#1-什么是接口" class="headerlink" title="1. 什么是接口"></a>1. 什么是接口</h3><p>   接口的用途是用来定义现实世界不同类型事物的共同行为特征。<br>    例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">飞行特征（包括起飞，飞行、着陆等行为）是鸟和飞机所共有的。</span><br><span class="line">鸟和飞机可定义为具体类</span><br><span class="line">它们的共同行为特征可被定义在接口中</span><br><span class="line">接口中所有方法均为抽象方法</span><br><span class="line">示例：</span><br><span class="line">public interface Flyer &#123;</span><br><span class="line">  public void takeoff();</span><br><span class="line">  ……</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口的组成"><a href="#2-接口的组成" class="headerlink" title="2. 接口的组成"></a>2. 接口的组成</h3><p>接口可以包含以下成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">①属性</span><br><span class="line">接口中的所有属性均被视静态常量。</span><br><span class="line">例如，下面几种方式的声明是等效的：</span><br><span class="line">int num = 10;</span><br><span class="line">public int num = 10;</span><br><span class="line">public static final int num = 10;</span><br><span class="line">②抽象方法</span><br><span class="line">接口中所有方法均为抽象方法。</span><br><span class="line">例如，下面两种方式的声明是等效的：</span><br><span class="line">public abstract void takeoff();</span><br><span class="line"></span><br><span class="line">public interface Flyer &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void takeoff();</span><br><span class="line">    public void land();</span><br><span class="line">public void fly();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-2-接口的使用"><a href="#7-7-2-接口的使用" class="headerlink" title="7.7.2 接口的使用"></a>7.7.2 接口的使用</h2><p>1、有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。<br>2、一个类可以实现多个接口，<br>3、接口不能被实例化  </p><ul><li>具体类（子类）可以实现接口（父类） ，并实现接口中的全部抽象方法</li><li>class SubClass implements InterfaceA{ }</li></ul><p>4、具体类适用父接口的多态<br>5、接口也可以继承其它接口。<br>6、实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。<br>7、接口的主要用途就是被实现类实现。（面向接口编程）<br>8、一个类可以同时继承父类并实现接口</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103212.png" alt></p><h2 id="7-7-3-接口的注意事项"><a href="#7-7-3-接口的注意事项" class="headerlink" title="7.7.3 接口的注意事项"></a>7.7.3 接口的注意事项</h2><ul><li>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类 </li><li>接口也可以继承另一个接口，使用extends关键字。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface&#123;</span><br><span class="line">String s=“MyInterface”;</span><br><span class="line">public void absM1();</span><br><span class="line">&#125;</span><br><span class="line">interface SubInterface extends MyInterface&#123;</span><br><span class="line">public void absM2();</span><br><span class="line">&#125;</span><br><span class="line">public class SubAdapter implements SubInterface&#123;</span><br><span class="line">public void absM1()&#123;System.out.println(“absM1”);&#125;</span><br><span class="line">public void absM2()&#123;System.out.println(“absM2”);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类SubAdapter必须给出接口SubInterface以及父接口MyInterface中所有方法的实现。</p><h2 id="7-7-4-接口小结"><a href="#7-7-4-接口小结" class="headerlink" title="7.7.4 接口小结"></a>7.7.4 接口小结</h2><p>接口的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">①用interface来定义。</span><br><span class="line">②接口中的所有成员变量都默认是由public static final修饰的。</span><br><span class="line">③接口中的所有方法都默认是由public abstract修饰的。</span><br><span class="line">④接口没有构造器。</span><br><span class="line">⑤接口采用多继承机制。</span><br><span class="line">⑥接口定义举例</span><br><span class="line">    public interface Runner &#123;</span><br><span class="line">int ID = 1;</span><br><span class="line">void start();</span><br><span class="line">public void run();</span><br><span class="line">void stop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-5-接口和抽象类的关系"><a href="#7-7-5-接口和抽象类的关系" class="headerlink" title="7.7.5 接口和抽象类的关系"></a>7.7.5 接口和抽象类的关系</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103339.png" alt></p><h2 id="7-7-6-接口在java8中的变化"><a href="#7-7-6-接口在java8中的变化" class="headerlink" title="7.7.6 接口在java8中的变化"></a>7.7.6 接口在java8中的变化</h2><p>Java 8中，你可以为接口添加默认方法和静态方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p><ul><li>默认方法：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。<br>比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</li><li>静态方法：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface AA &#123;</span><br><span class="line"></span><br><span class="line">    double PI = 3.14;</span><br><span class="line"></span><br><span class="line">public default void method() &#123;</span><br><span class="line">System.out.println(&quot;北京&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default String method1() &#123;</span><br><span class="line">return &quot;上海&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method2() &#123;</span><br><span class="line">System.out.println(“hello lambda!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时<br>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。  </p><p>②接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530103531.png" alt></p><h1 id="7-8-内部类"><a href="#7-8-内部类" class="headerlink" title="7.8 内部类"></a>7.8 内部类</h1><h2 id="7-8-1-什么是内部类"><a href="#7-8-1-什么是内部类" class="headerlink" title="7.8.1 什么是内部类"></a>7.8.1 什么是内部类</h2><ol><li>概念</li></ol><ul><li>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</li><li>Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</li><li>Inner class的名字不能与包含它的类名相同；</li><li>Inner class可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要:内部类.成员或者内部类对象.成员。<br>分类：成员内部类（static成员内部类嵌套类和成员内部类）<pre><code>局部内部类（不谈修饰符）、匿名内部类</code></pre></li></ul><h2 id="7-8-2-成员内部类"><a href="#7-8-2-成员内部类" class="headerlink" title="7.8.2 成员内部类"></a>7.8.2 成员内部类</h2><h3 id="1-普通内部类"><a href="#1-普通内部类" class="headerlink" title="1. 普通内部类"></a>1. 普通内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">private int s;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line"></span><br><span class="line">public void mb() &#123;</span><br><span class="line">s = 100; // 在普通内部类的方法中, 可以直接外部类的私有成员.</span><br><span class="line">System.out.println(&quot;在内部类B中s=&quot; + s);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ma() &#123;</span><br><span class="line">B i = new B();</span><br><span class="line">i.mb();</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">A o = new A();</span><br><span class="line">o.ma(); // 调用外部类的方法, 间接创建了内部类对象并调用了内部类对象的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    </span><br><span class="line">private int s = 111;</span><br><span class="line">        </span><br><span class="line">public class B &#123;</span><br><span class="line"></span><br><span class="line">private int s = 222;</span><br><span class="line"></span><br><span class="line">public void mb(int s) &#123;</span><br><span class="line">        System.out.println(s);        // 访问最近的形参值:333</span><br><span class="line">        System.out.println(this.s);     // 访问本类当前对象的属性:222</span><br><span class="line">        System.out.println(A.this.s);   // 访问外部类的当前对象的属性:111</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;    </span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">A a = new A();</span><br><span class="line">A.B b = a.new B(); // 在测试类中创建普通内部类的对象需要使用外部类对象</span><br><span class="line">b.mb(333); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-嵌套类"><a href="#2-嵌套类" class="headerlink" title="2. 嵌套类"></a>2. 嵌套类</h3><p>被static修饰的成员内部类就称为嵌套类.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">private int s;</span><br><span class="line"></span><br><span class="line">public static class B &#123;</span><br><span class="line"></span><br><span class="line">public void mb() &#123;</span><br><span class="line">//s = 100; // 在嵌套类的方法中, 不可以直接外部类的非静态成员.</span><br><span class="line">//System.out.println(&quot;在内部类B中s=&quot; + s);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ma() &#123;</span><br><span class="line">B i = new B();</span><br><span class="line">i.mb();</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">A.B b = new A.B(); // 创建嵌套类对象, 不需要外部类的对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-8-3-局部内部类"><a href="#7-8-3-局部内部类" class="headerlink" title="7.8.3 局部内部类"></a>7.8.3 局部内部类</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>在方法体中声明的内部类就是局部内部类, 局部内部类的范围和局部变量类似.</p><h3 id="2-普通局部内部类"><a href="#2-普通局部内部类" class="headerlink" title="2. 普通局部内部类"></a>2. 普通局部内部类</h3><p>在方法中声明的内部类, 有类名, 使用和普通类类似.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;    </span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">class A &#123;</span><br><span class="line">public void test();</span><br><span class="line">&#125;; </span><br><span class="line">A a = new A();</span><br><span class="line">a.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3. 匿名内部类"></a>3. 匿名内部类</h3><p>在方法中声明的内部类,   但是没有class关键字和具体类名, 称为匿名内部类, 因为没有类名, 所以必须在声明内部类的同时创建对象, 否则无法创建对象了.<br>所以匿名内部类的语法是 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 引用 = new 父类(实参列表) &#123;类体&#125;;</span><br></pre></td></tr></table></figure><p>匿名内部类最常用用法是new 后面的类名是已经存在的类, 或抽象类, 或接口. 如果是抽象类或接口, 则匿名内部类类体中必须实现全部的抽象方法, 由此可见, 匿名内部类只能作为new后面的类或抽象或接口的子类存在, 但是没有类名, 所以通常在声明的时候就创建对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    public void a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;    </span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">new A() &#123;</span><br><span class="line">            @Override</span><br><span class="line">public void a() &#123;</span><br><span class="line">                System.out.println(“匿名内部类实现接口方法”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.a(); // 打印输出内容…</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;7-1-Object类&quot;&gt;&lt;a href=&quot;#7-1-Object类&quot; class=&quot;headerlink&quot; title=&quot;7.1 Object类&quot;&gt;&lt;/a&gt;7.1 Object类&lt;/h1&gt;&lt;h2 id=&quot;7-1-1-Object类的特点&quot;&gt;&lt;a href=&quot;#7
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>6. JavaSE-面向对象基本特征</title>
    <link href="http://yoursite.com/2016/10/15/6.%20JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"/>
    <id>http://yoursite.com/2016/10/15/6. JavaSE-面向对象基本特征/</id>
    <published>2016-10-14T16:00:00.000Z</published>
    <updated>2019-06-04T01:22:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-1-基本特征一-封装"><a href="#6-1-基本特征一-封装" class="headerlink" title="6.1 基本特征一 封装"></a>6.1 基本特征一 封装</h1><h2 id="6-1-1访问控制修饰符作用"><a href="#6-1-1访问控制修饰符作用" class="headerlink" title="6.1.1访问控制修饰符作用"></a>6.1.1访问控制修饰符作用</h2><p>访问控制修饰符的作用是控制类中的成员可以在哪些范围内被访问到</p><h2 id="6-1-2访问控制修饰符"><a href="#6-1-2访问控制修饰符" class="headerlink" title="6.1.2访问控制修饰符"></a>6.1.2访问控制修饰符</h2><p>用的最多的有2个</p><blockquote><p>1    public 公共的意思, 访问范围最大, 可以任意范围内访问<br>2    private 私有的意思, 访问范围最小, 只能在本类中被访问</p></blockquote><h2 id="6-1-3-如何封装"><a href="#6-1-3-如何封装" class="headerlink" title="6.1.3 如何封装"></a>6.1.3 如何封装</h2><h3 id="6-1-3-1-成员"><a href="#6-1-3-1-成员" class="headerlink" title="6.1.3.1 成员"></a>6.1.3.1 成员</h3><p>类中的要素,<strong>属性, 方法, 构造器, 代码块, 成员内部类</strong>, 这些要素都隶属于类, 对于本类而言, 这些要素就是互为成员, 既然是互为成员, 那么它们之间的互相访问是没有任何障碍.</p><h3 id="6-1-3-2-成员私有化"><a href="#6-1-3-2-成员私有化" class="headerlink" title="6.1.3.2 成员私有化"></a>6.1.3.2 成员私有化</h3><p>只需要把类中的成员使用private修饰就是私有化了, 而一旦成员被私有化, 这个成员也称为被封装了<br><strong>注意 : 代码块不能封装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name; // 对象属性</span><br><span class="line">private int age;</span><br><span class="line">private String gender;</span><br><span class="line"></span><br><span class="line">    // 对象方法</span><br><span class="line">public void lesson() &#123;</span><br><span class="line">    System.out.println(name + “老师在上课”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void eat(String something) &#123;</span><br><span class="line">System.out.println(&quot;老师在吃&quot; + something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 描述对象的详细信息, 把所有的属性值串接成一个字符串</span><br><span class="line">public String say() &#123;</span><br><span class="line">String str = &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-1-3-3-封装的问题"><a href="#6-1-3-3-封装的问题" class="headerlink" title="6.1.3.3 封装的问题"></a>6.1.3.3 封装的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t = new Teacher(); </span><br><span class="line">        // 下面的语句都不能执行了, 因为在测试类中,不能直接跨类访问别的类中的私有成员</span><br><span class="line">        //t.name = “张三”;</span><br><span class="line">        //t.age = 30;</span><br><span class="line">        //t.gender = “男”;</span><br><span class="line">        //System.out.println(t.name); </span><br><span class="line">//System.out.println(t.age); </span><br><span class="line">//System.out.println(t.age); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-get-set方法"><a href="#1-get-set方法" class="headerlink" title="1  get/set方法"></a>1  get/set方法</h4><blockquote><p>   因为成员一旦私有化, 就不可以在其他类中直接访问了, 但是在其他类中仍然有访问的需求, 成员之间是可以互相访问的, 所以解决这个问题的方法就是在本类中添加一些公共方法, 通过方法间接访问类中的私有成员.</p></blockquote><p>public class Teacher {</p><pre><code>private String name = &quot;某老师&quot;; // 实例变量, 私有化属性, 封装private int age = 30; // 当属性被私有化时, 只能在本类中使用private String gender = &quot;男&quot;;// 用于间接设置name属性, 所以方法必须公共的public void setName(String n) {    name = n; }// 用于间接获取name属性, 所以方法必须公共的public String getName() {    return name; }public void setGender(String g) {    gender = g;}public String getGender() {    return gender;}public void setAge(int age) {     this.age = age;}// get方法有返回值, 没有参数public int getAge() {    return age;}// 实例方法public void lesson() {    System.out.println(name + &quot;老师在上课&quot;); // 成员可以互访}public void eat(String something) {    System.out.println(&quot;老师在吃&quot; + something);}// 描述对象的详细信息, 把所有的属性值串接成一个字符串public String say() {    String str = &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;    return str;}</code></pre><p>}</p><h4 id="2-间接访问属性"><a href="#2-间接访问属性" class="headerlink" title="2.间接访问属性"></a>2.间接访问属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Teacher t = new Teacher();</span><br><span class="line">t.setName(&quot;张老师&quot;);// 通过方法设置属性</span><br><span class="line">t.setAge(30); </span><br><span class="line">t.setGender(&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(t.getName());</span><br><span class="line">System.out.println(t.getAge());// 通过方法获取属性</span><br><span class="line">System.out.println(t.getGender());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-为什么要封装"><a href="#3-为什么要封装" class="headerlink" title="3. 为什么要封装"></a>3. 为什么要封装</h4><p>如果不使用封装而直接访问对象的属性, 就可以给属性赋上一些不合理的数据值, 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.age = 50000; // 显然这个操作是应该失败的, 因为年龄不合理</span><br></pre></td></tr></table></figure><p>但是如果通过方法来赋值, 就可以把这种错误拦截住<br>相同的道理, 如果要获取某个属性, 但是需要在内部再处理一下, 也可以通过方法来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 保护数据</span><br><span class="line">public void setAge(int a) &#123; </span><br><span class="line">if (a &gt; 120 || a &lt; 0) &#123; // 当参数中传入的数据不合理时, 方法直接返回, 不给对象的属性赋值</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-2-构造器"><a href="#6-2-构造器" class="headerlink" title="6.2 构造器"></a>6.2 构造器</h1><h2 id="6-2-1-什么是构造器"><a href="#6-2-1-什么是构造器" class="headerlink" title="6.2.1 什么是构造器"></a>6.2.1 什么是构造器</h2><h3 id="1-什么是初始化"><a href="#1-什么是初始化" class="headerlink" title="1. 什么是初始化"></a>1. 什么是初始化</h3><pre><code>对象在刚创建时进行的工作就称为初始化, 初始化的主要工作是针对对象的属性的.</code></pre><h3 id="2-构造器概念"><a href="#2-构造器概念" class="headerlink" title="2.构造器概念"></a>2.构造器概念</h3><p>   当对象创建时, 希望对象的属性值被正确赋值, 此时就需要用到了构造器, 构造器也称为构造方法, 本质上构造器就是一个方法, 是一个特殊的方法.</p><h3 id="3-如何定义构造器"><a href="#3-如何定义构造器" class="headerlink" title="3. 如何定义构造器"></a>3. 如何定义构造器</h3><p>  构造器(构造方法)的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名(参数类型1 形参1, 参数类型2 形参2….) &#123;</span><br><span class="line">代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">public Teacher() &#123; // 无参构造器</span><br><span class="line">name = &quot;张三&quot;;</span><br><span class="line">age = 35;</span><br><span class="line">gender = &quot;男&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getGender() &#123;</span><br><span class="line">return gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 : 类中如果没有提供任何的构造器, 编译器也会自动添加一个缺省的构造器<br>缺省的构造器就是 修饰符和类一致, 无参, 并且方法体中没有代码.</p><h2 id="6-2-2-构造器的特点"><a href="#6-2-2-构造器的特点" class="headerlink" title="6.2.2 构造器的特点"></a>6.2.2 构造器的特点</h2><ul><li>特点1：<br>构造器没有返回值, 也不可以声明void</li><li>特点2：构造器名称必须和类名一致</li><li>特点3：构造器不可以被final, static, abstract等修饰</li><li>特点4：<br>构造器不像普通方法可以随意调用, 只能在创建对象时调用一次<h2 id="6-2-3-构造器调用"><a href="#6-2-3-构造器调用" class="headerlink" title="6.2.3 构造器调用"></a>6.2.3 构造器调用</h2><h3 id="1-如何调用构造器"><a href="#1-如何调用构造器" class="headerlink" title="1.如何调用构造器"></a>1.如何调用构造器</h3>使用new关键字在创建对象时就会自动调用了构造器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Teacher t = new Teacher(); // 调用无参构造方法</span><br><span class="line">System.out.println(t.say()); // 输出”姓名:张三,年龄:35,性别:男”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-4-构造器重载"><a href="#6-2-4-构造器重载" class="headerlink" title="6.2.4 构造器重载"></a>6.2.4 构造器重载</h2><h3 id="1-什么是构造器重载"><a href="#1-什么是构造器重载" class="headerlink" title="1.什么是构造器重载"></a>1.什么是构造器重载</h3><p>当一个类中有多个构造器, 并且参数不同就形成构造器重载<br>构造器重载的目的是可以使用多种方式创建不同的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">public Teacher() &#123; // 无参构造器</span><br><span class="line">name = &quot;佟刚&quot;;</span><br><span class="line">age = 35;</span><br><span class="line">gender = &quot;女&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 有参构造器</span><br><span class="line">public Teacher(String n, int a) &#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">gender = &quot;女&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 有参构造器</span><br><span class="line">public Teacher(String n, int a, String g) &#123; </span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">gender = g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Teacher t1 = new Teacher(); // 调用无参构造方法</span><br><span class="line">System.out.println(t1.say());</span><br><span class="line"></span><br><span class="line">Teacher t2 = new Teacher(“李四”, 40); // 调用有参构造方法</span><br><span class="line">System.out.println(t2.say());</span><br><span class="line"></span><br><span class="line">Teacher t3 = new Teacher(“王五”, 50, “男”); // 调用有参构造方法</span><br><span class="line">System.out.println(t3.say());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-this-调用"><a href="#2-this-调用" class="headerlink" title="2. this()调用"></a>2. this()调用</h3><p>  在无参构造器中, 给对象的3个属性分别完成赋值, 而这个操作可以通过调用另外一个构造器来完成,调用的语法this(实参列表);<br>  注意 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this(…) 调用必须放在构造器的第一行!</span><br><span class="line">this(…) 调用时,必须保证有一个构造器是没有this(…)的, 否则会形成构造器递归调用.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">public Teacher() &#123; // 无参构造器</span><br><span class="line">// 注释不算行</span><br><span class="line">this(&quot;张三&quot;, 35, &quot;男&quot;); // 通过调用第3个构造器完成属性赋值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 有参构造器</span><br><span class="line">public Teacher(String n, int a) &#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">gender = &quot;女&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Teacher(String n, int a, String g) &#123; </span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">gender = g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-3-this关键字和对象关系"><a href="#6-3-this关键字和对象关系" class="headerlink" title="6.3 this关键字和对象关系"></a>6.3 this关键字和对象关系</h1><h2 id="6-3-1-this关键字含义"><a href="#6-3-1-this关键字含义" class="headerlink" title="6.3.1 this关键字含义"></a>6.3.1 this关键字含义</h2><h3 id="1-this代表什么"><a href="#1-this代表什么" class="headerlink" title="1. this代表什么"></a>1. this代表什么</h3><pre><code>this代表对象, 代表的是当前对象, this里保存的是对象的地址.</code></pre><p>谁是当前对象? 比如方法调用<br><code>t1.say()</code>在这个方法执行时<br>执行以下代码 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">&#125;</span><br><span class="line">这段代码可以写成</span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是一样的, 当前对象是哪个对象呢? 就是调用这个方法的对象, <code>t1.say()</code>中的t1就是当前对象,显然这个当前对象在变化, 因为<code>t2.say()</code>调用时,this就是指的是t2了.</p><h3 id="2-为什么使用this"><a href="#2-为什么使用this" class="headerlink" title="2.为什么使用this"></a>2.为什么使用this</h3><p>this强调了使用当前对象, 有的时候属性如果和方法中的局部变量重名时, 为了区别必须使用this,在构造器重载时, 调用别的构造器也需要使用this. 两者的语法不一样.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">public Teacher() &#123; // 无参构造器</span><br><span class="line">this(&quot;佟刚&quot;, 35, &quot;女&quot;); // 调用其他构造器 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Teacher(String name, int age, String gender) &#123; </span><br><span class="line">this.name = name; // this表示对象, 右侧的name是形参, 是局部变量</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return this.name; // 加上this也可以, 但是没有必须, 它暗含了this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getGender() &#123;</span><br><span class="line">return gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用this的优点"><a href="#3-使用this的优点" class="headerlink" title="3.使用this的优点"></a>3.使用this的优点</h3><blockquote><ol><li>使用this可以提高代码的可读性, 强调要使用的是当前对象.</li><li>在方法中, 如果局部变量和属性重名, 必须使用this, 用以区分属性和局部变量, 并且这样局部变量的含义也更清晰.</li><li>this(…)调用可以简化构造器调用, 并有利于维护. 如果有修改的需要, 只要修改被调用的构造器就可以了.</li></ol></blockquote><h2 id="6-3-2-对象的传递"><a href="#6-3-2-对象的传递" class="headerlink" title="6.3.2 对象的传递"></a>6.3.2 对象的传递</h2><h3 id="1-为什么要传递对象"><a href="#1-为什么要传递对象" class="headerlink" title="1. 为什么要传递对象"></a>1. 为什么要传递对象</h3><p>在有些方法中, 功能的完成除了需要一些基本数据外, 还需要复杂类型, 比如在Teacher类中方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lesson() &#123;</span><br><span class="line">    // 老师上课的代码, 老师上课时, 需要一台电脑, 这时就可以通过参数传递一个电脑对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void lesson(Computer computer) &#123;</span><br><span class="line">// 老师上课的代码, 老师上课时, 需要一台电脑, 这时就可以通过参数传递一个电脑对象</span><br><span class="line">// 这样在老师上课的代码中, 就可以直接使用传入的Computer对象.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.对象如何传递<br>在方法调用时, 由调用者传实参时,负责把对象传给方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">private double cpu;</span><br><span class="line">private int memory;</span><br><span class="line"></span><br><span class="line">public Computer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public Computer(double cpu, int memory) &#123;</span><br><span class="line">this.cpu = cpu;</span><br><span class="line">this.memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setCpu(double cpu) &#123;</span><br><span class="line">this.cpu = cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getCpu() &#123;</span><br><span class="line">return cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMemory(int memory) &#123;</span><br><span class="line">this.memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMemory() &#123;</span><br><span class="line">return memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;CPU:&quot; + cpu + &quot;GHz, 内存:&quot; + memory + &quot;G&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">public Teacher() &#123; // 无参构造器</span><br><span class="line">this(&quot;佟刚&quot;, 35, &quot;女&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Teacher(String name, int age, String gender) &#123; </span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getGender() &#123;</span><br><span class="line">return gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lesson(Computer com) &#123; // 这个方法应该需要一台电脑才能上课</span><br><span class="line">System.out.println(&quot;[&quot; + this.name + &quot;] 老师使用电脑[&quot; + com.say() + &quot;]在上课&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Teacher t = new Teacher(&quot;李四&quot;, 25, &quot;女&quot;);</span><br><span class="line">Computer com = new Computer(3.5, 4); // 要传递的对象先创建好</span><br><span class="line">t.lesson(com); // 通过实参传递对象</span><br><span class="line">        // 以上代码打印输出为”[李四] 老师使用电脑[CPU:3.5GHz,内存:4G]在上课&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-传递的是什么"><a href="#3-传递的是什么" class="headerlink" title="3.传递的是什么"></a>3.传递的是什么</h3><blockquote><p>在方法调用中的实参com是在main方法中声明的引用变量, 但是这个引用指向了在main中创建的新的Computer对象, 所以在lesson方法执行时, 接收到的是对象的引用, 通过引用使用了对象.</p></blockquote><h3 id="4-对象传递的优点"><a href="#4-对象传递的优点" class="headerlink" title="4.对象传递的优点"></a>4.对象传递的优点</h3><p>即使对象很大, 属性很多, 在对象传递时, 并不是把对象本身复制了一份, 而是只把对象的引用传递了, 优点就是速度快.</p><h3 id="5-对象传递的危险性"><a href="#5-对象传递的危险性" class="headerlink" title="5.对象传递的危险性"></a>5.对象传递的危险性</h3><p>危险性就在于因为传递了对象的引用, 这样通过引用一方面可以读取对象的属性或调用对象的方法, 同时如果通过引用直接修改对象的属性, 也会导致对象属性的变化, 所以当把对象传递给方法时, 如果在方法内部有对于对象的修改操作, 对于调用者来说, 这个修改也是同步的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public void lesson(Computer com) &#123; // 这个方法应该需要一台电脑才能上课</span><br><span class="line">System.out.println(&quot;[&quot; + this.name + &quot;] 老师使用电脑[&quot; + com.say() + &quot;]在上课&quot;); </span><br><span class="line">        com.setMemory(8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Teacher t = new Teacher();</span><br><span class="line">Computer com = new Computer(3.5, 4); // 要传递的对象先创建好</span><br><span class="line">t.lesson(com); // 通过实参传递对象</span><br><span class="line">        </span><br><span class="line">        System.out.println(com.getMemory()); // 输出的不是原来的4而是在方法中被修改后的8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-3-对象关联"><a href="#6-3-3-对象关联" class="headerlink" title="6.3.3 对象关联"></a>6.3.3 对象关联</h2><h3 id="1-什么是对象关联"><a href="#1-什么是对象关联" class="headerlink" title="1. 什么是对象关联"></a>1. 什么是对象关联</h3><p>   对象关联就是一个对象关联了另外一个对象, 前者拥有了后者, 是一种包含关系.</p><h3 id="2-为什么要关联对象"><a href="#2-为什么要关联对象" class="headerlink" title="2. 为什么要关联对象"></a>2. 为什么要关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lesson(Computer com) &#123; // 这个方法应该需要一台电脑才能上课</span><br><span class="line">System.out.println(&quot;[&quot; + this.name + &quot;] 老师使用电脑[&quot; + com.say() + &quot;]在上课&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中老师对象要想上课, 需要通过参数传入一个对象. 方法结束后, 这个对象对于老师对象来说就会消失, 显然老师对象最好是应该完全拥有一个电脑对象, 这样再执行上课方法时,就不需要再传入对象, 而是使用自己拥有的对象, 甚至还可以再添加一些别的方法使用此对象.</p><h3 id="3-如何关联对象"><a href="#3-如何关联对象" class="headerlink" title="3. 如何关联对象"></a>3. 如何关联对象</h3><p>  在当前类中把要关联的对象作为属性即可.<br>  也可以在构造器中添加参数为关联的对象赋值, 也可以添加对应的get/set方法,用以处理这个关联的对象</p><p>先写被关联的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">private double cpu;</span><br><span class="line">private int memory;</span><br><span class="line"></span><br><span class="line">public Computer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public Computer(double cpu, int memory) &#123;</span><br><span class="line">this.cpu = cpu;</span><br><span class="line">this.memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setCpu(double cpu) &#123;</span><br><span class="line">this.cpu = cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getCpu() &#123;</span><br><span class="line">return cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMemory(int memory) &#123;</span><br><span class="line">this.memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMemory() &#123;</span><br><span class="line">return memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;CPU:&quot; + cpu + &quot;GHz, 内存:&quot; + memory + &quot;G&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Teacher类中关联Computer类的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line">    // 对象关联, 把被关联的对象声明成属性</span><br><span class="line">    private Computer computer;</span><br><span class="line"></span><br><span class="line">    // 可以通过构造器完成对关联对象的初始化</span><br><span class="line">public Teacher(String name, int age, String gender, Computer computer) &#123; </span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">        this.computer = computer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同时应该再提供相应的get/set方法</span><br><span class="line">public void setComputer(Computer computer) &#123;</span><br><span class="line">    this.computer = computer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Computer getComputer() &#123;</span><br><span class="line">    return computer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getGender() &#123;</span><br><span class="line">return gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 在上课方法中, 不必再在每次调用时传参了.</span><br><span class="line">public void lesson() &#123; </span><br><span class="line">System.out.println(&quot;[&quot; + this.name + &quot;] 老师使用电脑[&quot; + computer.say() + &quot;]在上课&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Computer com = new Computer(3.5, 4); // 要关联的对象先创建好</span><br><span class="line">Teacher t = new Teacher(&quot;李四&quot;, 25, &quot;女&quot;, com); // 通过构造器完成对象关联</span><br><span class="line">t.lesson(); // 通过实参传递对象</span><br><span class="line">        // 以上代码打印输出为”[李四] 老师使用电脑[CPU:3.5GHz,内存:4G]在上课&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-对象关联的作用"><a href="#4-对象关联的作用" class="headerlink" title="4. 对象关联的作用"></a>4. 对象关联的作用</h3><p>   对象关联的作用非常广泛, 当一个类完成某种功能时, 有的时候如果有现成的其他对象可以直接使用, 并且在本类中要多次多方法中使用同一个功能时, 对象关联更显得必要. 这样使得对象之间的关系更加紧密.</p><h2 id="6-3-4-javabean"><a href="#6-3-4-javabean" class="headerlink" title="6.3.4 javabean"></a>6.3.4 javabean</h2><ul><li>JavaBean是一种Java语言写成的可重用组件。</li><li>所谓javaBean，是指符合如下标准的Java类：</li></ul><blockquote><ul><li>类是公共的</li><li>有一个无参的公共的构造器</li><li>有属性，且有对应的get、set方法</li><li>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestJavaBean&#123;</span><br><span class="line">private String name;  //属性一般定义为private</span><br><span class="line">private int age;</span><br><span class="line">public  TestJavaBean()&#123;&#125;</span><br><span class="line">public int getAge()&#123;</span><br><span class="line">     return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age)&#123;</span><br><span class="line">     this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()&#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-4-包"><a href="#6-4-包" class="headerlink" title="6.4 包"></a>6.4 包</h1><h2 id="6-4-1-package语句"><a href="#6-4-1-package语句" class="headerlink" title="6.4.1 package语句"></a>6.4.1 package语句</h2><h3 id="1-为什么要使用包"><a href="#1-为什么要使用包" class="headerlink" title="1  为什么要使用包"></a>1  为什么要使用包</h3><ul><li>当程序中涉及的类越来越多时, 类的功能含义以及如果有同名类该如何处理的问题就出现了. </li><li>我们希望把功能类似的一组类放在一起, 有利于管理和维护, 在java中使用了”包”的概念来分类管理</li><li>包和目录非常接近, 但是虽然文件系统中是以目录的形式出现的, 但是在程序中包不是目录,目录也不是包.</li></ul><p>###2  如何使用包<br>   在程序的第一行添加语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名.子包名.子子包名……;</span><br></pre></td></tr></table></figure><ul><li>包目录深度没有限制, 但也不宜太深</li><li><p>package的作用就是让编译器编译代码时, 把生成的class文件放置到指定的包目录中, 并在类中记录包信息.</p></li><li><p>包名及子包结构通常符合下列规范,由四个部分组成：</p></li><li>机构类型名称.机构名称.项目名称.模块名称</li></ul><h3 id="3-使用包带来的问题"><a href="#3-使用包带来的问题" class="headerlink" title="3  使用包带来的问题"></a>3  使用包带来的问题</h3><p>一旦源文件中使用了package语句, 那么这个源文件中的所有类都会被放置到指定的包中,<br>带来2个问题</p><blockquote><p>1)    包中的所有的类如果被别的包中的类访问时, 不能再使用简单类名(simple name), 必须使用全限定名称(qualified name), 全限定类名 就是所有的包名.类名.<br>2)    如果类是主类, 那么在执行主类时, 必须使用全限定类名.<br>3)    编译源文件时必须加上选项-d 生成的包目录及其中的类文件的目标目录, 通过这个目录是当前目录, 在eclipse中这个目录是bin</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.javase.javabean; </span><br><span class="line"></span><br><span class="line">public class Teacher &#123; // Teacher类在其他包的类中使用时,必须使用全限定名称</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age = 30;</span><br><span class="line">private String gender = &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">    // 可以通过构造器完成对关联对象的初始化</span><br><span class="line">public Teacher(String name, int age, String gender) &#123; </span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getGender() &#123;</span><br><span class="line">return gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.gender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.javase.test;</span><br><span class="line"></span><br><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//Teacher t = new Teacher(&quot;李四&quot;, 25, &quot;女&quot;); // 编译时这行语句就会报错!!!</span><br><span class="line">        com.atguigu.javase.javabean.Teacher t = new com.atguigu.javase.javabean.Teacher(“李四”,25,”女”);</span><br><span class="line">        System.out.println(t.say());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在命令行中执行此主类时必须使用全限定类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com.javase.test.TeacherTest</span><br></pre></td></tr></table></figure><h2 id="6-4-2-import语句"><a href="#6-4-2-import语句" class="headerlink" title="6.4.2 import语句"></a>6.4.2 import语句</h2><h3 id="1-import作用是什么"><a href="#1-import作用是什么" class="headerlink" title="1. import作用是什么"></a>1. import作用是什么</h3><blockquote><p>跨包使用类时, 必须使用全限定类名, 所以当一个类中使用别的包的类太多时, 或者一个类的包名特别冗长时, 使用全限定名称代价就会非常高, 即使是一个类已经使用过了全限定, 下次再使用时,仍然还得使用全限定类名. 为了解决这个问题, 使用import导入语句, 把本类中要使用的其他包中的类导入进来, 这样, 在本类中再使用别的包的类就不必再使用全限定类名了, 可以直接使用简单类名, 这样就可以简化开发.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.javase.test;</span><br><span class="line"></span><br><span class="line">import com.atguigu.javase.javabean.Teacher;</span><br><span class="line"></span><br><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Teacher t = new Teacher(&quot;李四&quot;, 25, &quot;女&quot;); // 虽然Teacher类不在本包, 因为已经导入可以使用</span><br><span class="line">        System.out.println(t.say());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-import注意事项"><a href="#2-import注意事项" class="headerlink" title="2. import注意事项"></a>2. import注意事项</h3><blockquote><p>①    import 也可以一次性导入某个包的所有类, 使用.*通配符即可<br>②    import导入时,必须要保证要导入的类确实存在</p></blockquote><h1 id="6-5-eclipse的使用"><a href="#6-5-eclipse的使用" class="headerlink" title="6.5 eclipse的使用"></a>6.5 eclipse的使用</h1><h2 id="6-5-1-安装"><a href="#6-5-1-安装" class="headerlink" title="6.5.1 安装"></a>6.5.1 安装</h2><h3 id="1-版本选择"><a href="#1-版本选择" class="headerlink" title="1  版本选择"></a>1  版本选择</h3><p>  在命令行执行语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java –version</span><br></pre></td></tr></table></figure><p>   最后一行如果显示以下内容, 表明JDK版本是64位的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>  最后一行如果显示以下内容,表明JDK版本是32位的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) Client VM (build 24.80-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>  Eclipse的位数必须和JDK位数一致, 否则无法运行.</p><h3 id="2-工作空间"><a href="#2-工作空间" class="headerlink" title="2  工作空间"></a>2  工作空间</h3><p>  在硬盘上创建一个目录, 记下它的位置, 作用就是eclipse使用这个目录保存一些常用的设置和项目配置信   息, 称之为工作空间.</p><h2 id="6-5-2-运行"><a href="#6-5-2-运行" class="headerlink" title="6.5.2 运行"></a>6.5.2 运行</h2><h3 id="1-启动eclipse"><a href="#1-启动eclipse" class="headerlink" title="1 启动eclipse"></a>1 启动eclipse</h3><p>  解压好eclipse以后, 进入目录, 双击eclipse.exe运行</p><h3 id="2-透视图和窗口布局"><a href="#2-透视图和窗口布局" class="headerlink" title="2 透视图和窗口布局"></a>2 透视图和窗口布局</h3><p><img src="https://i.loli.net/2019/05/29/5cee0fffb507366942.jpg" alt></p><h3 id="3-一些常用设置"><a href="#3-一些常用设置" class="headerlink" title="3. 一些常用设置"></a>3. 一些常用设置</h3><p>1） 设置字体</p><p> <img src="https://i.loli.net/2019/05/29/5cee0fffd085f68947.jpg" alt></p><p><img src="https://i.loli.net/2019/05/29/5cee1007096ab39316.jpg" alt></p><p>2）设置快捷操作</p><p><img src="https://i.loli.net/2019/05/29/5cee100733a5d78165.jpg" alt></p><h2 id="6-5-3-使用常用功能"><a href="#6-5-3-使用常用功能" class="headerlink" title="6.5.3 使用常用功能"></a>6.5.3 使用常用功能</h2><ol><li>创建项目</li></ol><p><img src="https://i.loli.net/2019/05/29/5cee100730e5654509.jpg" alt></p><ol start="2"><li>创建包</li></ol><p><img src="https://i.loli.net/2019/05/29/5cee0ffff1bdc69394.jpg" alt></p><ol start="3"><li>创建类</li></ol><p><img src="https://i.loli.net/2019/05/29/5cee100736b6425011.jpg" alt></p><ol start="4"><li>编辑代码<br>自动生成构造器</li></ol><p><img src="https://i.loli.net/2019/05/29/5cee10000077c17027.jpg" alt></p><p>自动生成get/set方法</p><p><img src="https://i.loli.net/2019/05/29/5cee100729b1214440.jpg" alt></p><p>添加say()方法</p><p>创建测试类并运行结果</p><p><img src="https://i.loli.net/2019/05/29/5cee0fffe555236372.jpg" alt></p><p></p><ol start="5"><li>一些常用快捷键</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + 1 快速修正错误</span><br><span class="line">Ctrl + d 快速删除当前行</span><br><span class="line">Ctrl + Alt + 下方向 快速在下方复制当前行</span><br><span class="line">Alt + / 自动完成提醒功能</span><br><span class="line">Ctrl + shift + f 格式化代码</span><br><span class="line">Ctrl + shift + o 整理导入</span><br><span class="line">按住ctrl移动鼠标, 可以查看指定位置的元素的声明.</span><br><span class="line"></span><br><span class="line">Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) </span><br><span class="line">Alt+↑ 当前行和上面一行交互位置(同上) </span><br><span class="line">Alt+← 前一个编辑的页面 </span><br><span class="line">Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) </span><br><span class="line"></span><br><span class="line">Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 </span><br><span class="line"></span><br><span class="line">Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) </span><br><span class="line">Shift+Ctrl+Enter 在当前行插入空行(原理同上条) </span><br><span class="line"></span><br><span class="line">Ctrl+Q 定位到最后编辑的地方 </span><br><span class="line">Ctrl+L 定位在某行 (对于程序超过100的人就有福音了) </span><br><span class="line">Ctrl+M 最大化当前的Edit或View (再按则反之) </span><br><span class="line">Ctrl+/ 注释当前行,再按则取消注释 </span><br><span class="line">Ctrl+O 快速显示 OutLine </span><br><span class="line">Ctrl+T 快速显示当前类的继承结构 </span><br><span class="line">Ctrl+W 关闭当前Editer </span><br><span class="line">Ctrl+K 参照选中的Word快速定位到下一个 </span><br><span class="line">Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) </span><br><span class="line"></span><br><span class="line">Ctrl+/(小键盘) 折叠当前类中的所有代码 </span><br><span class="line"></span><br><span class="line">Ctrl+×(小键盘) 展开当前类中的所有代码 </span><br><span class="line"></span><br><span class="line">Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) </span><br><span class="line"></span><br><span class="line">Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+F4 关闭所有打开的Editer </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+X 把当前选中的文本全部变为小写 </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Y 把当前选中的文本全部变为小写 </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+F 格式化当前代码 </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+P 定位到对于的匹配符(譬如&#123;&#125;) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) </span><br><span class="line"></span><br><span class="line">下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了) </span><br><span class="line"></span><br><span class="line">Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) </span><br><span class="line"></span><br><span class="line">Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) </span><br><span class="line"></span><br><span class="line">Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) </span><br><span class="line"></span><br><span class="line">Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) </span><br><span class="line"></span><br><span class="line">Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) </span><br><span class="line"></span><br><span class="line">Alt+Shift+I 合并变量(可能这样说有点不妥Inline) </span><br><span class="line">Alt+Shift+V 移动函数和变量(不怎么常用) </span><br><span class="line">Alt+Shift+Z 重构的后悔药(Undo)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">序号           功能                                      快捷键</span><br><span class="line">1       为用户提供内容的辅助                      〔Alt＋/〕</span><br><span class="line">2       显示类中方法和属性的大纲，快速定位        〔Ctrl＋O〕</span><br><span class="line">3       光标所在行或选定行快速添加注释或取消注释  〔Ctrl＋/〕</span><br><span class="line">4       窗口的最大化和还原                        〔Ctrl＋M〕</span><br><span class="line">5       快速修正                                  〔Ctrl＋1〕</span><br><span class="line">-----------------------------------------------------------------------------------------------------------</span><br><span class="line">6            快速向下和向上查找                        〔Ctrl＋K〕、〔Ctrl＋Shift＋K〕</span><br><span class="line">7            查找构建路径中的可找到类                  〔Ctrl+Shift＋T〕</span><br><span class="line">8            查找构建路径重点的所有文件                〔Ctrl＋Shift＋R〕</span><br><span class="line">9            查找类、方法和属性的引用                  〔Ctrl＋Shift＋G〕</span><br><span class="line">10          快速生成import                            〔Ctrl＋Shift＋O〕</span><br><span class="line">11          格式化代码                                〔Ctrl＋Shift＋F〕</span><br><span class="line">12        查找当前文件所在项目中的路径              〔Alt＋Shift＋W〕</span><br><span class="line">13        定位到当前编辑器的某一行                  〔Ctrl＋L〕</span><br><span class="line">14        后退历史记录和前进历史记录                〔Alt＋&lt;-〕、〔Alt＋-&gt;〕</span><br><span class="line">15        快速定位光标位置的某个类、方法和属性        〔F3〕</span><br><span class="line">16        显示类的继承关系                            〔F4〕</span><br></pre></td></tr></table></figure><p></p><ol start="6"><li>导入项目</li></ol><p><img src="https://i.loli.net/2019/05/29/5cee10070616510190.jpg" alt></p><p><img src="https://i.loli.net/2019/05/29/5cee100005fa972786.jpg" alt></p><h1 id="6-6-基本特征二-继承"><a href="#6-6-基本特征二-继承" class="headerlink" title="6.6 基本特征二 继承"></a>6.6 基本特征二 继承</h1><h2 id="6-6-1-继承"><a href="#6-6-1-继承" class="headerlink" title="6.6.1 继承"></a>6.6.1 继承</h2><h3 id="1-继承的概念"><a href="#1-继承的概念" class="headerlink" title="1 继承的概念"></a>1 继承的概念</h3><p>一个类从另外一个类继承所有成员, 包括属性和方法, 但是不包括构造器和语句块<br>从现有类创建子类, 现有类就称为<code>父类, 基类, 超类.</code></p><p><img src="https://i.loli.net/2019/05/29/5cee0fffec1e076794.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">      public String name;</span><br><span class="line">      public int age;</span><br><span class="line">      public Date birthDate;</span><br><span class="line">      public String getInfo()   </span><br><span class="line">     &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/29/5cee0fffef15372674.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">      public String name;</span><br><span class="line">      public int age;</span><br><span class="line">      public Date birthDate;</span><br><span class="line">      public String school;</span><br><span class="line">      public String getInfo()  </span><br><span class="line">     &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/29/5cee10072df5363871.jpg" alt></p><p><img src="https://i.loli.net/2019/05/29/5cee10073975322106.jpg" alt></p><h3 id="2-为什么要继承"><a href="#2-为什么要继承" class="headerlink" title="2 为什么要继承"></a>2 为什么要继承</h3><ul><li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li><li>此处的多个类称为子类，单独的这个类称为父类（基类或超类）。可以理解为:“子类 is a 父类”</li></ul><blockquote><p>当一个类和另外一个类的属性和方法完全相同, 并且同时又比另一个类多一些特有的属性和方法时, 前者就可以作成后者的子类, 子类继承父类的所有成员, 这样, 在子类中就可以省略从父类继承的成员, 便于代码的复用, 以及更统一的类型管理.</p></blockquote><h3 id="3-继承语法"><a href="#3-继承语法" class="headerlink" title="3 继承语法"></a>3 继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类 &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从语法意思来看, 子类是扩展自父类, 也可以理解为子类是在以父类为基础的前提下, 进一步扩展一些属性和方法, 所以子类大于父类, 或者也可以说, 子类包含父类.</p></blockquote><p><img src="https://i.loli.net/2019/05/29/5cee10000331989402.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">      public String name;</span><br><span class="line">      public int age;</span><br><span class="line">      public Date birthDate;</span><br><span class="line">      public String getInfo() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student extends Person&#123;</span><br><span class="line">      public String school;</span><br><span class="line">&#125;</span><br><span class="line">//Student类继承了父类Person的所有属性和方法，并增加了一个属性school。</span><br><span class="line">//Person中的属性和方法,Student都可以使用。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/29/5cee0fffe959515357.jpg" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529125920.png" alt></p><h3 id="4-继承的特点"><a href="#4-继承的特点" class="headerlink" title="4 继承的特点"></a>4 继承的特点</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529125953.png" alt></p><p>①子类继承父类的所有成员(构造器除外), 就意味着父类的私有成员也会被子类继承, 但是因为私有成员只能被本类访问, 所以即使是在子类中也不能直接访问从父类继承的私有成员, 可以通过从父类继承的公共的get/set方法间接访问.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">      private String name;</span><br><span class="line">      private int age;</span><br><span class="line">      private Date birthDate;</span><br><span class="line">      </span><br><span class="line">      public void setName(String name) &#123;</span><br><span class="line">          this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      public String getInfo() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student extends Person&#123;</span><br><span class="line">      public String school;</span><br><span class="line">      public void test() &#123;</span><br><span class="line">          //name = “小明”; // 不可以, 因为是私有的</span><br><span class="line">          setName(“小明”);// 可以, 通过公共方法间接访问</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②单继承</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529130433.png" alt></p><blockquote><p>在继承关系中, 一个类Person可以被另外的类Soldier和Student和Officer继承, 然后Student又被Graduate类继承, 这是允许的, 在这样的体系中, Graduate类也称为Person类的子类, Person类也称为Graduate类的父类, 这样的继承我们称之为多层继承. 在这样的体系中, Student类称为Graduate类的直接父类, 显然地, Person类称为Graduate类的间接父类, 在java中, 多层继承是被允许的.<br>Java中不允许的多继承是指多重继承, 也就是说一个类不允许有多个直接父类, 间接父类并没有个数限制. 称之为单继承.</p></blockquote><h2 id="6-6-2方法覆盖-override"><a href="#6-6-2方法覆盖-override" class="headerlink" title="6.6.2方法覆盖(override)"></a>6.6.2方法覆盖(override)</h2><h3 id="1-什么是方法覆盖"><a href="#1-什么是方法覆盖" class="headerlink" title="1. 什么是方法覆盖"></a>1. 什么是方法覆盖</h3><p>定义：</p><ul><li>在子类中可以根据需要对从父类中继承来的方法进行改造，</li><li><p>也称方法的重写、重置。在程序执行时，子类的方法将覆盖父类的方法。<br>要求：</p></li><li><p>覆盖方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。</p></li><li>覆盖方法不能使用比被重写方法更严格的访问权限。</li><li>覆盖和被覆盖的方法必须同时为非static的。</li><li>子类方法抛出的异常不能大于父类被重写方法的异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">public String name;</span><br><span class="line">public int age;</span><br><span class="line">public String getInfo() &#123;</span><br><span class="line">return &quot;Name: &quot;+ name + &quot;\n&quot; +&quot;age: &quot;+ age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123;</span><br><span class="line"></span><br><span class="line">public String school;</span><br><span class="line">int age;</span><br><span class="line"></span><br><span class="line">public String getInfo() &#123;       //重写方法</span><br><span class="line">return  &quot;Name: &quot;+ name + &quot;\nage: &quot;+ age + &quot;\nschool: &quot;+ school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Student s1=new Student();</span><br><span class="line">s1.name=&quot;Bob&quot;;</span><br><span class="line">s1.age=20;</span><br><span class="line">s1.school=&quot;school2&quot;;</span><br><span class="line">System.out.println(s1.getInfo());   //Name:Bob  age:20  school:school2 执行的是子类重写过的方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-为什么要方法覆盖"><a href="#2-为什么要方法覆盖" class="headerlink" title="2.为什么要方法覆盖"></a>2.为什么要方法覆盖</h3><blockquote><p>有的时候子类继承的父类方法并不能满足子类的需要, 而方法名称又要保持一致, 此时用到方法覆盖.</p></blockquote><h3 id="3-方法覆盖的特殊性"><a href="#3-方法覆盖的特殊性" class="headerlink" title="3. 方法覆盖的特殊性"></a>3. 方法覆盖的特殊性</h3><blockquote><p>子类一旦把父类的方法覆盖, 那么在测试类中再无法通过子类对象调用父类的被覆盖方法了, 因为子类已经把父类的方法重写了, 如果有调用父类方法的需求, 只能通过再创建一个父类对象来调用.</p></blockquote><h3 id="4-Override注解的使用"><a href="#4-Override注解的使用" class="headerlink" title="4. @Override注解的使用"></a>4. @Override注解的使用</h3><blockquote><p>有的时候, 在子类中写重写方法时, 容易出现一些低级的拼写错误, 或其他错误, 导致方法不能正确覆盖时, 程序的运行就会出乎意外, 所以为了防止这种现象, 在子类的覆盖方法上添加修饰符@Override注解.</p><ul><li>注解 : 本质上一种类, 也是一种特殊的注释, 所以一般情况下,  程序不执行注解, 但是会被编译器, 运行时所识别和处理(通过反射的方式).注解也有很多.</li><li>@Override注解的作用是告诉编译器, 在编译程序时, 必须先检查此方法是否满足方法覆盖的条件, 如果不满足, 则编译出错, 这样强制程序员通过排查, 提前检查方法覆盖的问题.</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123;</span><br><span class="line"></span><br><span class="line">public String school;</span><br><span class="line">int age;</span><br><span class="line"></span><br><span class="line">    @Override // 加上注解, 也能提高代码可读性</span><br><span class="line">public String getInfo() &#123;       //重写方法</span><br><span class="line">return  &quot;Name: &quot;+ name + &quot;\nage: &quot;+ age + &quot;\nschool: &quot;+ school;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-3-四种访问权限"><a href="#6-6-3-四种访问权限" class="headerlink" title="6.6.3 四种访问权限"></a>6.6.3 四种访问权限</h2><h3 id="1-为什么需要访问权限"><a href="#1-为什么需要访问权限" class="headerlink" title="1  为什么需要访问权限"></a>1  为什么需要访问权限</h3><p>有的时候, 类中的一些成员需要控制可以被哪些范围的其他类所访问, 就可以使用访问控制修饰符来控制.</p><h3 id="2-访问权限"><a href="#2-访问权限" class="headerlink" title="2  访问权限"></a>2  访问权限</h3><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529130828.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529130846.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529130939.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">        private int f1 = 1;</span><br><span class="line">        int f2 = 2;</span><br><span class="line">        protected  int f3 = 3;</span><br><span class="line">        public  int f4 = 4;</span><br><span class="line">        private  void  fm1() &#123;System.out.println(&quot;in fm1() f1=&quot; + f1);&#125;</span><br><span class="line">        void fm2() &#123;System.out.println(&quot;in fm2() f2=&quot; + f2);&#125;</span><br><span class="line">        protected  void  fm3() &#123;System.out.println(&quot;in fm3() f3=&quot; + f3);&#125;</span><br><span class="line">        public void fm4() &#123;System.out.println(&quot;in fm4() f4=&quot; + f4);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;               //设父类和子类在同一个包内</span><br><span class="line">private int c1 = 21;</span><br><span class="line">public  int c2 = 22; </span><br><span class="line">private void cm1()&#123;System.out.println(&quot;in cm1() c1=&quot; + c1);&#125;</span><br><span class="line">public  void cm2()&#123;System.out.println(&quot;in cm2() c2=&quot; + c2);&#125;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int i; </span><br><span class="line">Parent  p = new Parent();</span><br><span class="line">// i = p1.f1; // 不可以访问其他类的私有成员</span><br><span class="line">i = p.f2;//i = p.f3;i = p.f4;p.fm2();//p.fm3();p.fm4();</span><br><span class="line">Child  c = new Child();</span><br><span class="line">i = c.f2;        //i = c.f3;i = c.f4;</span><br><span class="line">i = c.c1;        //i = c.c2;</span><br><span class="line">//c.fm1(); // 不能访问</span><br><span class="line">c.cm1();        // c.cm2(); c.fm2(); c.fm3(); c.fm4() 都能访问</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-访问权限的使用注意"><a href="#3-访问权限的使用注意" class="headerlink" title="3. 访问权限的使用注意"></a>3. 访问权限的使用注意</h3><p>protected是被保护的, 容易从字面意思理解成它的范围会比较小, 但是其实被protected修饰的成员的访问范围是仅次于public的, 所以要小心.</p><h1 id="6-7-super关键字"><a href="#6-7-super关键字" class="headerlink" title="6.7 super关键字"></a>6.7 super关键字</h1><h2 id="6-7-1-super关键字含义"><a href="#6-7-1-super关键字含义" class="headerlink" title="6.7.1 super关键字含义"></a>6.7.1 super关键字含义</h2><h3 id="1-super关键字"><a href="#1-super关键字" class="headerlink" title="1. super关键字"></a>1. super关键字</h3><p>作用：</p><ul><li>在Java类中使用super来调用父类中的指定操作：</li><li>super可用于访问父类中定义的属性</li><li>super可用于调用父类中定义的成员方法</li><li><p>super可用于在子类构造方法中调用父类的构造器<br>注意：</p></li><li><p>尤其当子父类出现同名成员时，可以用super进行区分</p></li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li><li>super关键字表示在当前类中特别指定要使用父类的成员时使用super限定.</li><li>这里的父类不仅包括直接父类, 也包括间接父类.</li></ul><h2 id="6-7-2-super使用场景"><a href="#6-7-2-super使用场景" class="headerlink" title="6.7.2 super使用场景"></a>6.7.2 super使用场景</h2><h3 id="1-方法中使用"><a href="#1-方法中使用" class="headerlink" title="1. 方法中使用"></a>1. 方法中使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">protected String name=&quot;张三&quot;;</span><br><span class="line">protected int age;</span><br><span class="line"></span><br><span class="line">public String getInfo() &#123;</span><br><span class="line">         return “Name: ” + name + “\nage: ” + age; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line"></span><br><span class="line">    protected String name = &quot;李四&quot;;</span><br><span class="line">private String school = &quot;New Oriental&quot;;</span><br><span class="line"></span><br><span class="line">public String getSchool()&#123; </span><br><span class="line">return school; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">public String getInfo() &#123;</span><br><span class="line">        return super.getInfo() +&quot;\nschool: &quot; +school; </span><br><span class="line">// 在方法中使用super可以调用父类中的被覆盖方法</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">public class TestStudent&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Student st = new Student();</span><br><span class="line">System.out.println(st.getInfo());</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-构造器中使用"><a href="#2-构造器中使用" class="headerlink" title="2. 构造器中使用"></a>2. 构造器中使用</h3><p>①    子类中所有的构造器默认都会访问父类中空参数的构造器<br>②    当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行<br>③    如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">private Date birthDate;</span><br><span class="line"></span><br><span class="line">public Person(String name, int age, Date d) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.birthDate = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person(String name, int age) &#123;</span><br><span class="line">this(name, age, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person(String name, Date d) &#123;</span><br><span class="line">this(name, 30, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person(String name) &#123;</span><br><span class="line">this(name, 30);</span><br><span class="line">&#125;</span><br><span class="line">// ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123;</span><br><span class="line">private String school;</span><br><span class="line"></span><br><span class="line">public Student(String name, int age, String s) &#123;</span><br><span class="line">super(name, age); // 直接显式调用父类有参构造器</span><br><span class="line">school = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(String name, String s) &#123;</span><br><span class="line">super(name); // 直接显式调用父类有参构造器</span><br><span class="line">school = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(String s) &#123; // 直接隐式调用父类无参构造器</span><br><span class="line">school = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-3子类对象实例化过程"><a href="#6-7-3子类对象实例化过程" class="headerlink" title="6.7.3子类对象实例化过程"></a>6.7.3子类对象实例化过程</h2><ol><li>执行顺序</li></ol><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529131237.png" alt></p><h2 id="6-7-4-super和this的区别"><a href="#6-7-4-super和this的区别" class="headerlink" title="6.7.4 super和this的区别"></a>6.7.4 super和this的区别</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529141052.png" alt></p><h1 id="6-8-基本特征三-多态"><a href="#6-8-基本特征三-多态" class="headerlink" title="6.8 基本特征三 多态"></a>6.8 基本特征三 多态</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190529141154.png" alt></p><h2 id="6-8-1-什么是多态"><a href="#6-8-1-什么是多态" class="headerlink" title="6.8.1 什么是多态"></a>6.8.1 什么是多态</h2><h3 id="1-本态"><a href="#1-本态" class="headerlink" title="1. 本态"></a>1. 本态</h3><p>一个对象的本类形态就是本态.</p><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h3><p>一个对象的多种父类形态就是多态</p><h2 id="6-8-2多态的使用"><a href="#6-8-2多态的使用" class="headerlink" title="6.8.2多态的使用"></a>6.8.2多态的使用</h2><h3 id="1-多态引用"><a href="#1-多态引用" class="headerlink" title="1. 多态引用"></a>1. 多态引用</h3><p>  将子类对象赋值于父类类型的引用变量就是多态引用, 在这里对象其实还是子类对象, 只不过是被看作是一个父类类型的对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Student();</span><br></pre></td></tr></table></figure><ul><li>多态性，是面向对象中最重要的概念，在java中有两种体现：<ol><li>方法的重载(overload)和重写(overwrite)。</li><li>对象的多态性   ——可以直接应用在抽象类和接口上。</li></ol></li><li><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。</p></li><li><p>注意：若编译时类型和运行时类型不一致，就出现多态（Polymorphism）</p></li></ul><h3 id="2-多态带来的问题"><a href="#2-多态带来的问题" class="headerlink" title="2 多态带来的问题"></a>2 多态带来的问题</h3><ul><li>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student m = new Student();</span><br><span class="line">m.school = “pku”; //合法,Student类有school成员变量</span><br><span class="line">Person e = new Student(); </span><br><span class="line">e.school = “pku”;//非法,Person类没有school成员变量</span><br></pre></td></tr></table></figure><pre><code>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，</code></pre><p>因而编译错误。</p><h2 id="6-8-3虚拟方法调用-Virtual-Method-Invocation"><a href="#6-8-3虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="6.8.3虚拟方法调用(Virtual Method Invocation)"></a>6.8.3虚拟方法调用(Virtual Method Invocation)</h2><h3 id="1-什么是虚拟方法"><a href="#1-什么是虚拟方法" class="headerlink" title="1. 什么是虚拟方法"></a>1. 什么是虚拟方法</h3><p>  正常的方法调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Person e = new Person();</span><br><span class="line">e.getInfo();</span><br><span class="line">Student e = new Student();</span><br><span class="line"> e.getInfo();</span><br><span class="line">虚拟方法调用(多态情况下)：</span><br><span class="line">Person e = new Student();</span><br><span class="line">  e.getInfo();//调用Student类的getInfo()方法</span><br></pre></td></tr></table></figure><p>  编译时类型和运行时类型：</p><p>  编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。<br>  ——动态绑定</p><h3 id="2-多态小结"><a href="#2-多态小结" class="headerlink" title="2. 多态小结"></a>2. 多态小结</h3><pre><code>前提：  需要存在继承或者实现关系要有覆盖操作  成员方法：编译时：要查看引用变量所属的类中是否有所调用的方法。(编译时检查父类类型)运行时：调用实际对象所属的类中的重写方法。(运行时执行子类类型)成员变量：不具备多态性，只看引用变量所属的类。</code></pre><h2 id="6-8-4多态的应用场景"><a href="#6-8-4多态的应用场景" class="headerlink" title="6.8.4多态的应用场景"></a>6.8.4多态的应用场景</h2><h3 id="1-多态数组"><a href="#1-多态数组" class="headerlink" title="1. 多态数组"></a>1. 多态数组</h3><p>   当创建多个不同的子类对象, 而又想统一处理这批对象时, 就可以使用多态数组.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] arr = &#123;new Student(), new Teacher()&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;  </span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">private String gender;</span><br><span class="line"></span><br><span class="line">public Person(String name, int age, String gender) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getGender() &#123;</span><br><span class="line">return gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String say() &#123;</span><br><span class="line">return &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sayHello() &#123;</span><br><span class="line">System.out.println(&quot;打个招呼&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese extends Person &#123;</span><br><span class="line"></span><br><span class="line">private String shuxiang;</span><br><span class="line"></span><br><span class="line">public Chinese(String name, int age, String gender, String shuxiang) &#123;</span><br><span class="line">super(name, age, gender); </span><br><span class="line">this.shuxiang = shuxiang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setShuxiang(String shuxiang) &#123;</span><br><span class="line">this.shuxiang = shuxiang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getShuxiang() &#123;</span><br><span class="line">return shuxiang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void spring() &#123;</span><br><span class="line">System.out.println(&quot;过大年&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String say() &#123;</span><br><span class="line">return super.say() + &quot;,属相:&quot; + shuxiang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sayHello() &#123;</span><br><span class="line">System.out.println(&quot;吃了吗?&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class American extends Person &#123;</span><br><span class="line"></span><br><span class="line">private boolean hasGun;</span><br><span class="line"></span><br><span class="line">public American() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public American(String name, int age, String gender, boolean hasGun) &#123;</span><br><span class="line">super(name, age, gender);</span><br><span class="line">this.hasGun = hasGun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHasGun(boolean hasGun) &#123;</span><br><span class="line">this.hasGun = hasGun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isHasGun() &#123;</span><br><span class="line">return hasGun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void christmas() &#123;</span><br><span class="line">System.out.println(&quot;Merry Christmas!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sayHello() &#123;</span><br><span class="line">System.out.println(&quot;How are you?&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person[] ps = new Person[5]; // 多态数组, 可以保存任意类型的子类对象</span><br><span class="line">ps[0] = new Chinese(&quot;张三&quot;, 30, &quot;男&quot;, &quot;牛&quot;);</span><br><span class="line">ps[1] = new American(&quot;Jack&quot;, 25, &quot;male&quot;, true);</span><br><span class="line">ps[2] = new Person(&quot;某人&quot;, 15, &quot;未知&quot;);</span><br><span class="line">ps[3] = new American(&quot;Rose&quot;, 32, &quot;female&quot;, false);</span><br><span class="line">ps[4] = new Chinese(&quot;李四&quot;, 40, &quot;女&quot;, &quot;羊&quot;);</span><br><span class="line"></span><br><span class="line">for (Person p : ps) &#123;</span><br><span class="line">System.out.println(p.say());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        // 因为在同一个数组中, 并且所有对象都有age属性, 所以就可以对所有元素进行冒泡排序</span><br><span class="line">for (int i = 0; i &lt; ps.length - 1; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; ps.length - 1 - i; j++) &#123;</span><br><span class="line">if (ps[j].getAge() &gt; ps[j + 1].getAge()) &#123;</span><br><span class="line">Person tmp = ps[j];</span><br><span class="line">ps[j] = ps[j + 1];</span><br><span class="line">ps[j + 1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Person p : ps) &#123;</span><br><span class="line">System.out.println(p.say());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多态参数"><a href="#2-多态参数" class="headerlink" title="2. 多态参数"></a>2. 多态参数</h3><blockquote><p>在设计方法时, 有的方法内部需要用到另外的类的对象, 但是在设计方法时, 又不需要关心究竟是哪个对象, 只关心这些实参对象都是某个类型的, 此时, 方法的参数的类型就可以写成父类类型的参数,这样的方法的参数就是多态参数.</p></blockquote><figure class="highlight plain"><figcaption><span>p) &#123;</span><a href="//">这个方法的参数p的具体类型未知</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    System.out.println(p.say());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">test(new Chinese()); // 在实际调用多态参数方法时, 可以传入任意本类或子类类型的对象</span><br><span class="line">test(new American());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>x instanceof A：检验x是否为类A的对象，返回值为boolean型。</strong></p><ul><li>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。</li><li>如果x属于类A的子类B，x instanceof  A值也为true。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person extends Object &#123;…&#125;</span><br><span class="line">public class Student extends Person &#123;…&#125;</span><br><span class="line">public class Graduate extends Person &#123;…&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">public void method1(Person e) &#123;</span><br><span class="line">if (e instanceof Person) </span><br><span class="line">// 处理Person类及其子类对象</span><br><span class="line">if (e instanceof Student) </span><br><span class="line">//处理Student类及其子类对象</span><br><span class="line">if (e instanceof Graduate)</span><br><span class="line">//处理Graduate类及其子类对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-对象类型转换-Casting"><a href="#3-对象类型转换-Casting" class="headerlink" title="3 对象类型转换(Casting)"></a>3 对象类型转换(Casting)</h3><ul><li><p>基本数据类型的Casting：</p><ul><li>自动类型转换：小的数据类型可以自动转换成大的数据类型<br><code>如long g=20;   double d=12.0f</code></li><li>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型<pre><code>` 如 float f=(float)12.0;   int a=(int)1200L</code></pre></li></ul></li><li><p>对Java对象的强制类型转换称为造型</p></li></ul><ul><li>从子类到父类的类型可以自动进行</li><li>从父类到子类的类型转换必须通过造型(强制类型转换)实现</li><li>无继承关系的引用类型间的转换是非法的</li><li>在造型前可以使用instanceof操作符测试一个对象的类型</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190530094040.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class PersonTest5 &#123;</span><br><span class="line"></span><br><span class="line">public static void test(Person p) &#123; // 多态参数, 提高了兼容性!!</span><br><span class="line">p.sayHello(); //方法中父类中定义,所以直接调用,</span><br><span class="line">//p.spring(); // 多态副作用, 子类特有成员不能访问</span><br><span class="line">// 必须对对象的真实身份进行检测 </span><br><span class="line">if (p instanceof Chinese) &#123; // 造型有风险, 使用须谨慎!!!</span><br><span class="line">Chinese ch = (Chinese)p; // 造型: 对象是什么类型还原成什么类型</span><br><span class="line">ch.spring(); // 子类特有的成员的访问,必须要经过造型.</span><br><span class="line">&#125; else if (p instanceof American) &#123;</span><br><span class="line">((American)p).christmas();</span><br><span class="line">&#125; else if (p instanceof Person)&#123;</span><br><span class="line">System.out.println(&quot;普通人一枚&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person[] ps = new Person[5]; // 多态数组, 可以保存任意类型的子类对象</span><br><span class="line">Chinese c1 = new Chinese(&quot;张三&quot;, 30, &quot;男&quot;, &quot;牛&quot;);</span><br><span class="line">American a1  = new American(&quot;Jack&quot;, 25, &quot;male&quot;, true);</span><br><span class="line">Person p1 = new Person(&quot;某人&quot;, 15, &quot;未知&quot;);</span><br><span class="line">American a2 = new American(&quot;Rose&quot;, 32, &quot;female&quot;, false);</span><br><span class="line">Chinese c2 = new Chinese(&quot;李四&quot;, 40, &quot;女&quot;, &quot;羊&quot;);</span><br><span class="line">ps[0] = c1;</span><br><span class="line">ps[1] = a1;</span><br><span class="line">ps[2] = p1;</span><br><span class="line">ps[3] = a2;</span><br><span class="line">ps[4] = c2;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">for (Person p : ps) &#123;</span><br><span class="line">test(p); // 不同的子类对象作为实参调用方法, 方法的执行也不一样.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-1-基本特征一-封装&quot;&gt;&lt;a href=&quot;#6-1-基本特征一-封装&quot; class=&quot;headerlink&quot; title=&quot;6.1 基本特征一 封装&quot;&gt;&lt;/a&gt;6.1 基本特征一 封装&lt;/h1&gt;&lt;h2 id=&quot;6-1-1访问控制修饰符作用&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>5. JavaSE-面向对象基础</title>
    <link href="http://yoursite.com/2016/09/06/5.%20JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2016/09/06/5. JavaSE-面向对象基础/</id>
    <published>2016-09-05T16:00:00.000Z</published>
    <updated>2019-06-04T01:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-1-类与对象"><a href="#5-1-类与对象" class="headerlink" title="5.1 类与对象"></a>5.1 类与对象</h1><h2 id="5-1-1面向对象与面向过程"><a href="#5-1-1面向对象与面向过程" class="headerlink" title="5.1.1面向对象与面向过程"></a>5.1.1面向对象与面向过程</h2><p>1.学习面向对象内容的三条主线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.java类及类的成员</span><br><span class="line">2.面向对象的三大特征</span><br><span class="line">3.其它关键字</span><br></pre></td></tr></table></figure></p><p>2.面向对象(OOP) 与面向过程(POP)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面向对象 OOP :</span><br><span class="line">     Object Oriented Programming  </span><br><span class="line">面向过程 POP ：</span><br><span class="line">     Procedure Oriented Programming</span><br></pre></td></tr></table></figure></p><p>二者都是一种思想，面向对象是相对于面向过程而言的。<br>面向过程，强调的是功能行为。<br>面向对象，将功能封装进对象，强调具备了功能的对象。</p><p><img src="https://i.loli.net/2019/05/27/5cebb35d928b945184.jpg" alt></p><p>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，<br>如<strong>抽象、分类、继承、聚合、多态</strong>等。</p><h2 id="5-1-2类与类之间的关系"><a href="#5-1-2类与类之间的关系" class="headerlink" title="5.1.2类与类之间的关系"></a>5.1.2类与类之间的关系</h2><p>###1.关联关系</p><p>学院包含教授和研究生, 体现类包含另外的一些类</p><p><img src="https://i.loli.net/2019/05/27/5cebb35d2d65890533.jpg" alt></p><h3 id="2-继承关系"><a href="#2-继承关系" class="headerlink" title="2.继承关系"></a>2.继承关系</h3><pre><code>游泳运动员是运动员的一种, 排球运行员又是球类运动员的一种,体现的是类型的一脉相承</code></pre><p><img src="https://i.loli.net/2019/05/27/5cebb35d5795112211.jpg" alt></p><h3 id="3-聚合关系"><a href="#3-聚合关系" class="headerlink" title="3.聚合关系"></a>3.聚合关系</h3><p>球队中包含队长以及多个队员,体现的是包含</p><p><img src="https://i.loli.net/2019/05/27/5cebb35c3c02929986.jpg" alt></p><h2 id="5-1-3面向对象的三大特征"><a href="#5-1-3面向对象的三大特征" class="headerlink" title="5.1.3面向对象的三大特征"></a>5.1.3面向对象的三大特征</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装  (Encapsulation)</span><br><span class="line">继承  (Inheritance)</span><br><span class="line">多态  (Polymorphism)</span><br></pre></td></tr></table></figure><h2 id="5-1-4面向对象的思想概述"><a href="#5-1-4面向对象的思想概述" class="headerlink" title="5.1.4面向对象的思想概述"></a>5.1.4面向对象的思想概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① 程序员从执行者转化成了指挥者。</span><br><span class="line">② 完成需求时：</span><br><span class="line">    1.先去找具有所需功能的对象来用。</span><br><span class="line">    2.如果该对象不存在，那么创建一个具有所需功能的对象。</span><br><span class="line">    3.这样简化开发并提高复用。</span><br><span class="line">③ 类(class)和对象(object)是面向对象的核心概念。</span><br><span class="line">④ 类是对一类事物描述，是抽象的、概念上的定义</span><br><span class="line">⑤ 对象是实际存在的该类事物的每个个体，因而也称实例(instance)。</span><br><span class="line">⑥ “万事万物皆对象” – 在java中一切皆对象</span><br></pre></td></tr></table></figure><h1 id="5-2-类与对象"><a href="#5-2-类与对象" class="headerlink" title="5.2 类与对象"></a>5.2 类与对象</h1><h2 id="5-2-1-类的概念"><a href="#5-2-1-类的概念" class="headerlink" title="5.2.1 类的概念"></a>5.2.1 类的概念</h2><h3 id="1-java类及类的成员"><a href="#1-java类及类的成员" class="headerlink" title="1. java类及类的成员"></a>1. java类及类的成员</h3><ul><li>现实世界万事万物是由分子、原子构成的。同理，Java代码世界是由诸多个不同功能的类构成的。</li><li>现实世界中的分子、原子又是由什么构成的呢？原子核、电子！那么，Java中用类class来描述事物也是如此</li><li>事物有大小,颜色,好坏,高低, 胖瘦,等等特征, 而这些特征又可以用数据描述,在程序中保存数据的就是变量</li><li>事物也有行为动作, 比如吃, 跑, 跳, 移动等等, 而这些行为的描述又比变量稍复杂一点, 用方法来描述事物的行为. 所以类中最常见的两种成员就是:</li></ul><blockquote><ul><li>属 性：对应类中的成员变量(描述事物的特征)<br>行 为：对应类中的成员方法(描述事物的行为)</li></ul></blockquote><h3 id="2-面向对象的思想概述"><a href="#2-面向对象的思想概述" class="headerlink" title="2. 面向对象的思想概述"></a>2. 面向对象的思想概述</h3><p><img src="https://i.loli.net/2019/05/27/5cebb35d4f37177423.jpg" alt></p><blockquote><ul><li>可以理解为：类 = 汽车设计图；对象 = 实实在在的汽车</li><li>面向对象程序设计的重点是类的设计</li><li>定义类其实是定义类中的成员(成员变量和成员方法)</li></ul></blockquote><p>所以类就是对现实世界事物的抽象定义, 这个抽象定义就可以基本把某事物描述清楚. 要想描述清楚事物, 必须要知道事物有哪些特征(数据, 用变量保存), 有哪些行为(用方法描述), 当某事物的特征和行为都描述清楚后, 我们就认为对这个事物有一个大概的把握.</p><h2 id="5-2-2-对象的概念"><a href="#5-2-2-对象的概念" class="headerlink" title="5.2.2 对象的概念"></a>5.2.2 对象的概念</h2><ul><li>对象就是一个类的实实在在的实体, 也称为实例, 所以对象(object)也称为实例(instance), 实例就是对象, 对象就是实例.</li></ul><pre><code>比如 “学生” 可以是一个类, 因为它描述了学生这一群体事物, 而具体的”3年级的小明” 就是一个对象, 相同的 “4年级的小花” 也是一个学生对象. </code></pre><h2 id="5-2-3-类和对象的关系"><a href="#5-2-3-类和对象的关系" class="headerlink" title="5.2.3 类和对象的关系"></a>5.2.3 类和对象的关系</h2><blockquote><p>   类是描述事物的, 一旦描述清楚, 就可以代表一类事物了, 但是类只是概念, 要想使用实体, 必须要有对象, 但是从时间的先后顺序来讲, 是先有类, 才有的对象, 因为类就像是一个模板, 而对象就像是用这个模板制造出来的产品, 如前面图示所描述的, 汽车设计图是一个模板, 一旦有了这个模板, 就可以使用设计图, 无限制地制造汽车了.<br>    在这个过程中, 类的设计是更重要的, 就像现实中也是汽车设计师的工资通常比实施工人要高.</p></blockquote><pre><code>![](https://i.loli.net/2019/05/27/5cebb35d6dbec82796.jpg)</code></pre><h2 id="5-2-4-类的语法格式"><a href="#5-2-4-类的语法格式" class="headerlink" title="5.2.4 类的语法格式"></a>5.2.4 类的语法格式</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603234818.png" alt></p><p>示例代码 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">String name;// 在类中声明的变量 name, 此时就是属性, 也称为成员变量, 描述人有名字</span><br><span class="line">int age ;            // 在类中声明的变量 age, 此时就是属性, 也称为成员变量, 描述人有年龄</span><br><span class="line"></span><br><span class="line">    public void play() &#123;    // 声明方法play(), 也称为成员方法, 表示人会玩</span><br><span class="line">age = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-3-属性"><a href="#5-3-属性" class="headerlink" title="5.3 属性"></a>5.3 属性</h1><h2 id="5-3-1语法格式："><a href="#5-3-1语法格式：" class="headerlink" title="5.3.1语法格式："></a>5.3.1语法格式：</h2><p>修饰符  类型  属性名 = 初值 ; </p><ul><li>说明:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符private : 该属性只能由该类的方法访问。</span><br><span class="line">        修饰符public : 该属性可以被该类以外的方法访问。    </span><br><span class="line">            类型：任何基本类型，如int、boolean或任何引用类型。</span><br></pre></td></tr></table></figure><h2 id="5-3-2举例："><a href="#5-3-2举例：" class="headerlink" title="5.3.2举例："></a>5.3.2举例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private int age;                  // 声明private变量 age</span><br><span class="line">public String name = “Lila”;    // 声明public变量 name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.属性的使用：<br>属性通常是要隶属于某个对象来使用的, 也就是说要想使用属性, 必须要先创建对象, 创建对象的语法很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 引用变量名 = new 类名();</span><br></pre></td></tr></table></figure><p>对象创建好以后, 就可以通过引用变量名来使用对象了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用变量名.name = “Jack”;</span><br><span class="line">System.out.println(引用变量名.name);</span><br></pre></td></tr></table></figure><p>属性的使用和普通变量没有区别, 唯一的区别就在于属性是隶属于某个对象了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">String name; // 实例变量</span><br><span class="line">int age;</span><br><span class="line">String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t = new Teacher();</span><br><span class="line">t.name = &quot;李二狗&quot;; // 把”李二狗”值赋给t对象的属性name</span><br><span class="line">System.out.println(t.name); // 打印t对象的name属性值, 输出就是”李二狗”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-4-方法"><a href="#5-4-方法" class="headerlink" title="5.4 方法"></a>5.4 方法</h1><h2 id="5-4-1-方法的概念"><a href="#5-4-1-方法的概念" class="headerlink" title="5.4.1 方法的概念"></a>5.4.1 方法的概念</h2><p>1  什么是方法</p><ul><li>方法是类或对象行为特征的抽象，也称为函数。 </li><li>Java里的方法不能独立存在，所有的方法必须定义在类里。<br>方法也可以描述为是某个功能的执行体, 一个方法通常对应一个功能.</li></ul><p>2 为什么使用方法</p><blockquote><p>比如要想完成某种功能, 需要执行10行代码, 我们在程序中需要这个功能时,就把这10行代码写出来就可以了, 但是如果要多次使用这个功能, 虽然可以通过复制这10行代码的方式来完成功能, 但是效率低, 并且不利于维护. 所以我们通常把具有特定独立功能的一些代码封装到一个方法中, 这样, 只需要简单地调用这个方法就可以自动完成功能了.</p></blockquote><p>3  方法和属性的关系</p><blockquote><p>Java里的方法不能独立存在，所有的方法必须定义在类里, 而属性也是定义在类里的, 所以方法和属性都是隶属于类的, 方法和属性是平等的关系.</p><ul><li>属性用于描述事物的特征数据.</li><li>方法用于描述事物的功能行为.</li></ul></blockquote><h2 id="5-4-2-方法的声明与调用"><a href="#5-4-2-方法的声明与调用" class="headerlink" title="5.4.2 方法的声明与调用"></a>5.4.2 方法的声明与调用</h2><ol><li>方法的声明语法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参1，参数类型 形参2，….）｛</span><br><span class="line">  程序代码</span><br><span class="line">  return 返回值;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>其中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">形式参数：在方法被调用时用于接收外部传入的数据的变量。</span><br><span class="line">参数类型：就是该形式参数的数据类型。</span><br><span class="line">返回值：方法在执行完毕后返还给调用它的程序的数据。</span><br><span class="line">返回值类型：方法要返回的结果的数据类型。</span><br><span class="line">实际参数：调用方法时实际传给函数形式参数的数据。</span><br></pre></td></tr></table></figure></p><p>注意 : </p><blockquote><ul><li>一个类中可以有多个方法。</li><li>方法中只能调用方法，不可以在方法内部定义方法。</li><li>方法声明不是方法调用</li></ul></blockquote><ul><li>如果某个方法只是单纯的执行一些代码, 并没有计算结果返回, 那么返回值类型就是void</li><li>表示方法没有返回值, 此时方法中的return可以省略, 或者也可以仅使用return; 表示方法结束.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    System.out.println(“test()”);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2  方法的声明的构成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法声明的构成包括 方法签名 + 方法体</span><br></pre></td></tr></table></figure></p><p>3  方法签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法签名包括 返回值类型 方法名(形参类型1 形参1, 形参类型2 形参2…)</span><br><span class="line">方法名作用是用于定位方法是哪一个, 因为在一个类中可以有多个方法.</span><br><span class="line">参数列表表示方法在执行时需要的数据, 参数列表也可以为空, 表示方法执行时不需要数据.</span><br></pre></td></tr></table></figure></p><p>如上例中的<code>int add(int a, int b)</code><br>4  方法体<br>方法体就是方法签名后面的{}以及其中的所有内容, 方法体才是方法在调用时实际执行的代码<br>那么方法签名的作用是什么呢? 签名是一个方法调用的参考, 方法在调用时应该严格按照方法签名来调用, 以防止出错.</p><p>如上面例子中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5  方法的调用<br>方法可以任何可以有语句的位置调用, 比如另一个方法中, 或另一个类的某方法中<br>调用语法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象引用.方法名(实参值1, 实参值2…);</span><br></pre></td></tr></table></figure></p><p>对象引用是方法所在的类的对象, 实参值1, 2 是根据方法签名中要求的数据类型而实际传递给方法的值. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    System.out.println(“a + b”);</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    System.out.println(“test()”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Person t = new Person();</span><br><span class="line">t.test(); // 当执行程序时, 打印输出”test()”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 方法的返回值<br>有的方法会返回一个结果值, 如上面的方法int add(int a, int b)<br>如果直接调用这个方法, 而不接收其返回值, 这个方法会执行并返回结果, 但是在main方法中没有保存, 返回值结果被丢弃了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Person t = new Person();</span><br><span class="line">t.add(100, 200); // 如果这样调用, 只会打印输出”a + b”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的返回值就是方法调用本身, 如上例中方法调用整体t.add(100,200) 就可以看作是300这个值了, 当然, 前提是方法必须先都执行完才能返回300, 所以我们可以选择接收返回值.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Person t = new Person();</span><br><span class="line">int n = t.add(100, 200); //这样调用, 会打印输出”a + b” 并把300保存在n中</span><br><span class="line">        System.out.println(n); //输出300</span><br><span class="line">        System.out.println(t.add(30, 50)); // 输出80</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-4-3-重载"><a href="#5-4-3-重载" class="headerlink" title="5.4.3 重载"></a>5.4.3 重载</h2><h3 id="1-重载的概念"><a href="#1-重载的概念" class="headerlink" title="1  重载的概念"></a>1  重载的概念</h3><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数不同即可。</p><p>参数不同的含义是仅参数个数不同 或者 类型不同 或者 顺序不同.</p><p>注意 :<br>    参数不同不包含参数名的不同.</p><h3 id="2-如何重载"><a href="#2-如何重载" class="headerlink" title="2  如何重载"></a>2  如何重载</h3><p>在同一个类中写同名方法, 保证参数不同即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">    // 这个方法就可以和下面2个方法形成重载</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    System.out.println(“a + b”);</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double add(int a, double b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double add(double a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    System.out.println(“test()”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-重载的方法的调用"><a href="#3-重载的方法的调用" class="headerlink" title="3  重载的方法的调用"></a>3  重载的方法的调用</h3><p>调用重载方法取决于实参列表, 和形参列表要匹配才可以, 或者也可以是被形参列表兼容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Person t = new Person();</span><br><span class="line">        System.out.println(t.add(30, 50)); // 调用 int add(int a, int b)</span><br><span class="line">System.out.println(t.add(209, 0.502)); // 调用 double add(int a, double b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-重载的作用"><a href="#4-重载的作用" class="headerlink" title="4  重载的作用"></a>4  重载的作用</h3><p>在调用同名方法时, 只需要实参不同即可, 调用者调用这个方法就变得简单, 也不用再记忆多个不同的方法名. 前提是这些重载的方法有类似的功能.</p><h3 id="5-重载的练习"><a href="#5-重载的练习" class="headerlink" title="5  重载的练习"></a>5  重载的练习</h3><p>1.判 断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">与void show(int a,char b,double c)&#123;&#125;构成重载的有：</span><br><span class="line">a)void show(int x,char y,double z)&#123;&#125;   </span><br><span class="line">b)int show(int a,double c,char b)&#123;&#125;   </span><br><span class="line">c)  void show(int a,double c,char b)&#123;&#125;  </span><br><span class="line">d)  boolean show(int c,char b)&#123;&#125;  </span><br><span class="line">e)  void show(double c)&#123;&#125;  </span><br><span class="line">f)  double show(int x,char y,double z)&#123;&#125;  </span><br><span class="line">g)  void shows(double c)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-4-参数传递机制"><a href="#5-4-4-参数传递机制" class="headerlink" title="5.4.4 参数传递机制"></a>5.4.4 参数传递机制</h2><h3 id="1-为什么要传参"><a href="#1-为什么要传参" class="headerlink" title="1  为什么要传参"></a>1  为什么要传参</h3><p>有的方法在执行时, 需要用到一些值, 这些值在执行时必须要由调用者传递(告诉)给方法, 方法才可以正确执行</p><h3 id="2-传参的本质是什么"><a href="#2-传参的本质是什么" class="headerlink" title="2  传参的本质是什么"></a>2  传参的本质是什么</h3><p>传参的本质是方法在调用时, 把实参的值赋值给形参(形参是局部变量), 也称为传值调用</p><h3 id="3-方法调用的内存结构"><a href="#3-方法调用的内存结构" class="headerlink" title="3  方法调用的内存结构"></a>3  方法调用的内存结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">public void test2(int a) &#123;</span><br><span class="line">    System.out.println(“test2 a:” + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    System.out.println(“a + b”);</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PersonTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Person t = new Person();</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 20;</span><br><span class="line">        int c = t.add(a, b); // 通过值传递把a的值赋值给方法中的形参a</span><br><span class="line">System.out.println(c); // 方法调用返回值也是赋值给c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/27/5cebb35dd6b9396075.jpg" alt></p><p>注意 : 方法返回值30保存在一个临时空间中, 方法调用结束后返回给调用者后就消失.</p><h2 id="5-4-5-可变参数"><a href="#5-4-5-可变参数" class="headerlink" title="5.4.5 可变参数"></a>5.4.5 可变参数</h2><h3 id="1-什么是可变参数"><a href="#1-什么是可变参数" class="headerlink" title="1  什么是可变参数"></a>1  什么是可变参数</h3><blockquote><p>当一个方法中的参数类型都相同, 但是个数不确定的情况下.</p></blockquote><h3 id="2-如何声明可变参数"><a href="#2-如何声明可变参数" class="headerlink" title="2 如何声明可变参数"></a>2 如何声明可变参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//下面采用数组形参来定义方法</span><br><span class="line">public void test(int a ,String[] books);</span><br><span class="line">//以可变个数形参来定义方法</span><br><span class="line">public void test(int a ,String…books);</span><br></pre></td></tr></table></figure><p>注意 : 以上两个方法不可以共存.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class VarArgs &#123;</span><br><span class="line"></span><br><span class="line">/*类中的方法的功能类似, 但是参数个数不确定</span><br><span class="line">public int avg(int a, int b) &#123;</span><br><span class="line">return (a + b) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int avg(int a, int b, int c) &#123;</span><br><span class="line">return (a + b + c) / 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int avg(int a, int b, int c, int d) &#123;</span><br><span class="line">return (a + b + c + d) / 4;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">// 可变参数, 参数的个数可以是任意个, 只能放在参数列表的最后</span><br><span class="line">public int avg(String a, int... values) &#123; // int...是数组, 同时又能兼容任意个数参数</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">sum += values[i];</span><br><span class="line">&#125;</span><br><span class="line">return sum / values.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-可变参数的本质是什么"><a href="#3-可变参数的本质是什么" class="headerlink" title="3 可变参数的本质是什么"></a>3 可变参数的本质是什么</h3><blockquote><p>可变参数的本质上是方法在调用时, 实际传递的是数组.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class VarArgsTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String... args) &#123; </span><br><span class="line">VarArg va = new VarArg();</span><br><span class="line"></span><br><span class="line">System.out.println(va.avg(2)); // 一个参数可以</span><br><span class="line">System.out.println(va.avg()); // 不传参数也可以</span><br><span class="line">System.out.println(va.avg(null)); // 传null也可以</span><br><span class="line">System.out.println(va.avg(10, 20, 40, 50)); // 任意多个也可以</span><br><span class="line">System.out.println(va.avg(10, 20, 40, 50,70, 80, 100, 5, 2, 3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int[] arr = new int[]&#123;2, 3, 4, 5&#125;;</span><br><span class="line">System.out.println(va.avg(arr)); // 直接传数组也可以</span><br><span class="line">System.out.println(va.avg(new int[]&#123;10, 20&#125;)); // 编译器会自动做这件事,也可以手工创建数组</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-5-对象的使用"><a href="#5-5-对象的使用" class="headerlink" title="5.5 对象的使用"></a>5.5 对象的使用</h1><h2 id="5-5-1-创建对象"><a href="#5-5-1-创建对象" class="headerlink" title="5.5.1 创建对象"></a>5.5.1 创建对象</h2><h3 id="1-关键字new"><a href="#1-关键字new" class="headerlink" title="1 关键字new"></a>1 关键字new</h3><p>类一旦写好了, 就可以使用关键字new创建对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line">String name; // 对象属性</span><br><span class="line">int age;</span><br><span class="line">String gender;</span><br><span class="line"></span><br><span class="line">    // 对象方法</span><br><span class="line">public void lesson() &#123;</span><br><span class="line">    System.out.println(name + “老师在上课”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public void eat(String something) &#123;</span><br><span class="line">System.out.println(&quot;老师在吃&quot; + something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 描述对象的详细信息, 把所有的属性值串接成一个字符串</span><br><span class="line">public String say() &#123;</span><br><span class="line">String str = &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t = new Teacher(); // 对象创建</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对象创建在哪里了"><a href="#2-对象创建在哪里了" class="headerlink" title="2  对象创建在哪里了"></a>2  对象创建在哪里了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher t = new Teacher();</span><br></pre></td></tr></table></figure><p>在这里t是什么呢? 是不是对象呢? 答案是否定的, t仅仅是一个引用变量, 什么是引用变量? 就是保存地址的一个特殊变量, 同时它也有类型, 表明它指向的对象的类型是Teacher类型的. 但是上面的对象的使用全是通过t来完成的, 原因就在于通过t可以定位对象的实体, 对象的实体是保存在堆内存中.</p><h3 id="3-对象包含哪些内容"><a href="#3-对象包含哪些内容" class="headerlink" title="3  对象包含哪些内容"></a>3  对象包含哪些内容</h3><p>当一个对象被创建时, 这个对象就会包含类中所有的属性值, 如上面的例子, Teacher属性中有String name, 和 int age属性, 所以对象中包含了两个数据: 一个是name, 一个是age</p><h2 id="5-5-2-使用对象"><a href="#5-5-2-使用对象" class="headerlink" title="5.5.2 使用对象"></a>5.5.2 使用对象</h2><h3 id="1-使用属性"><a href="#1-使用属性" class="headerlink" title="1  使用属性"></a>1  使用属性</h3><p>通过引用修改对象的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">String name; // 对象属性</span><br><span class="line">int age;</span><br><span class="line">String gender;</span><br><span class="line"></span><br><span class="line">    // 对象方法</span><br><span class="line">public void lesson() &#123;</span><br><span class="line">    System.out.println(name + “老师在上课”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void eat(String something) &#123;</span><br><span class="line">System.out.println(&quot;老师在吃&quot; + something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 描述对象的详细信息, 把所有的属性值串接成一个字符串</span><br><span class="line">public String say() &#123;</span><br><span class="line">String str = &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t = new Teacher(); </span><br><span class="line">        t.name = “张三”;</span><br><span class="line">        t.age = 30;</span><br><span class="line">        System.out.println(t.name); // 输出”张三”</span><br><span class="line">System.out.println(t.age); // 输出30</span><br><span class="line"></span><br><span class="line">t.name = “张四”;</span><br><span class="line">        System.out.println(t.name); // 输出”张四”</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2  调用方法"></a>2  调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">String name; // 对象属性</span><br><span class="line">int age;</span><br><span class="line">String gender;</span><br><span class="line"></span><br><span class="line">    // 对象方法</span><br><span class="line">public void lesson() &#123;</span><br><span class="line">    System.out.println(name + “老师在上课”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void eat(String something) &#123;</span><br><span class="line">System.out.println(&quot;老师在吃&quot; + something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 描述对象的详细信息, 把所有的属性值串接成一个字符串</span><br><span class="line">public String say() &#123;</span><br><span class="line">String str = &quot;姓名:&quot; + name + &quot;,年龄:&quot; + age + &quot;,性别:&quot; + gender;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t = new Teacher(); </span><br><span class="line">        t.name = “张三”;</span><br><span class="line">        t.age = 30;</span><br><span class="line">        t.gender = “男”;</span><br><span class="line">        System.out.println(t.name); // 输出”张三”</span><br><span class="line">System.out.println(t.age); // 输出30</span><br><span class="line"></span><br><span class="line">t.name = “李三”;</span><br><span class="line">        System.out.println(t.name); // 输出”李三”</span><br><span class="line"></span><br><span class="line">        t.lesson(); // 输出 李三老师在上课 // 思考, 为什么不是输出张三老师在上课?</span><br><span class="line">        t.eat(“鱼香肉丝”); // 输出 &quot;老师在吃鱼香肉丝&quot;</span><br><span class="line">System.out.println(t.say()); // 输出 “姓名: 李三,年龄:30,性别:男”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-3-对象的独立性"><a href="#5-5-3-对象的独立性" class="headerlink" title="5.5.3 对象的独立性"></a>5.5.3 对象的独立性</h2><h3 id="1-同一个类创建多个对象"><a href="#1-同一个类创建多个对象" class="headerlink" title="1  同一个类创建多个对象"></a>1  同一个类创建多个对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t1 = new Teacher(); </span><br><span class="line">        t1.name = “张三”;</span><br><span class="line">        t1.age = 30;</span><br><span class="line">        t1.gender = “男”;</span><br><span class="line">        System.out.println(t1.name); // 输出”张三”</span><br><span class="line">System.out.println(t1.age); // 输出30</span><br><span class="line">System.out.println(t1.gender); // 输出”男”</span><br><span class="line"></span><br><span class="line">Teacher t2 = new Teacher(); </span><br><span class="line">        t2.name = “李四”;</span><br><span class="line">        t2.age = 40;</span><br><span class="line">        t2.gender = “女”;</span><br><span class="line">        System.out.println(t2.name); // 输出”李四”</span><br><span class="line">System.out.println(t2.age); // 输出40</span><br><span class="line">System.out.println(t2.gender); // 输出”女”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅可以创建两个对象, 可以创建任意多个对象, 前提是内存有空间.</p><h3 id="2-对象之间的关系"><a href="#2-对象之间的关系" class="headerlink" title="2  对象之间的关系"></a>2  对象之间的关系</h3><ul><li>对象之间是独立的, 如上例子中, t1是一个独立的对象, t2也是一个独立的对象, 两者互不干扰.</li><li>但是两个对象都是Teacher类型的, 所以它们的共同点是隶属于同一个类, 拥有类似的属性</li><li>同一个类的不同对象虽然是独立的, 但是它们所占用的内存空间大小是一样的.</li></ul><h3 id="3-对象交换"><a href="#3-对象交换" class="headerlink" title="3 对象交换"></a>3 对象交换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Teacher t1 = new Teacher(); </span><br><span class="line">        t1.name = “张三”;</span><br><span class="line">        t1.age = 30;</span><br><span class="line">        System.out.println(t1.name); // 输出”张三”</span><br><span class="line"></span><br><span class="line">Teacher t2 = new Teacher(); </span><br><span class="line">        t2.name = “李四”;</span><br><span class="line">        t2.age = 40;</span><br><span class="line">        System.out.println(t2.name); // 输出”李四”    </span><br><span class="line">     // 对象的交换和普通变量的交换类似</span><br><span class="line">     // 需要声明一个临时变量</span><br><span class="line">        Teacher tmp = t1;</span><br><span class="line">        t1 = t2;</span><br><span class="line">        t2 = tmp;</span><br><span class="line">      System.out.println(t1.name); // 输出”李四” 思考 如果输出t1的年龄,是多少?</span><br><span class="line">System.out.println(t2.name); // 输出”张三”</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##5.5.4 匿名对象</p><h3 id="1-什么是匿名对象"><a href="#1-什么是匿名对象" class="headerlink" title="1  什么是匿名对象"></a>1  什么是匿名对象</h3><p>在创建对象后并不把对象的地址保存在引用变量中, 而是直接使用创建好的对象的引用访问成员.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TeacherTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">new Teacher().eat(“宫暴鸡丁”);  // 后面不能再使用这个对象了</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-匿名对象特点"><a href="#2-匿名对象特点" class="headerlink" title="2  匿名对象特点"></a>2  匿名对象特点</h3><p>因为对象没有使用引用变量保存, 所以对象访问完成后, 就无法再次访问了</p><h3 id="3-匿名对象作用"><a href="#3-匿名对象作用" class="headerlink" title="3  匿名对象作用"></a>3  匿名对象作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a)适用于对象的一次性使用场景中</span><br><span class="line">b)适用于方法调用时传递对象</span><br><span class="line">c)适用于对象的传递(对象作为参数传递)</span><br></pre></td></tr></table></figure><h1 id="5-6-Java内存管理"><a href="#5-6-Java内存管理" class="headerlink" title="5.6 Java内存管理"></a>5.6 Java内存管理</h1><h2 id="5-6-1-内存分类"><a href="#5-6-1-内存分类" class="headerlink" title="5.6.1 内存分类"></a>5.6.1 内存分类</h2><ol><li>栈和堆</li></ol><ul><li>Java中的内存管理分为两部分, 一部分是栈, 另外一部分是堆.</li><li>栈(stack)是后进先出的内存结构, 主要作用是方法调用时使用, 在内存中占用的空间比较小</li><li>堆(heap)是内存的绝大部分空间, 没有特定的结构, 堆内存的特点是大.</li><li>堆内存分为两部分, 一部分是方法区, 另外一部分称为GC区</li></ul><h1 id="5-6-2-垃圾回收"><a href="#5-6-2-垃圾回收" class="headerlink" title="5.6.2 垃圾回收"></a>5.6.2 垃圾回收</h1><ul><li>什么是垃圾<blockquote><p>主要是指在堆内存中的GC区中, 由于对象不再使用后, 对象所占用的空间应该被释放, 这个空间就称为垃圾, 这个对象就称为垃圾对象</p></blockquote></li><li>垃圾如何回收<blockquote><p>垃圾的回收是由GC(垃圾回收器)在后台处理, 在程序中,当某个对象不再有引用指向时, 这个对象就变为垃圾对象, 对象占用的空间就会由GC标记为可用状态, 这样,再次创建新对象时, 就可以使用这个可用空间, 从而可以实现自动的内存清理.</p></blockquote></li></ul><h2 id="5-6-3-对象创建"><a href="#5-6-3-对象创建" class="headerlink" title="5.6.3 对象创建"></a>5.6.3 对象创建</h2><ul><li>1对象创建在哪里<br>对象创建在GC区中</li><li>2对象创建过程<br>1) 在方法区中加载类模板<br>2) 依据类模板中属性的定义, 在GC区中开辟空间<br>3) 把这个空间的地址返回给对象的创建者中的引用变量</li><li>3对象销毁<br>当一个对象被认定是垃圾后, 由GC在后台负责销毁此对象, 并释放内存空间.</li></ul><h1 id="5-7-对象数组"><a href="#5-7-对象数组" class="headerlink" title="5.7 对象数组"></a>5.7 对象数组</h1><h2 id="5-7-1-对象数组的声明和创建"><a href="#5-7-1-对象数组的声明和创建" class="headerlink" title="5.7.1 对象数组的声明和创建"></a>5.7.1 对象数组的声明和创建</h2><h3 id="1-动态方式"><a href="#1-动态方式" class="headerlink" title="1  动态方式"></a>1  动态方式</h3><p>创建方式和基本数据类型的是类似的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用类型名称[] 数组名 = new 引用类型名称[数组长度];</span><br></pre></td></tr></table></figure></p><p>注意 : 此时创建出来的数组对象中的元素都为null</p><p>对象数组也称为引用数组.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Teacher[] arr = new Teacher [4]; // 共4个元素, 但是每个元素都是null</span><br><span class="line">//arr[0].lesson(); 会出现空指针异常</span><br></pre></td></tr></table></figure><p>###2  静态方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">① 引用类型名称[] 数组名 = new 引用类型名称[]&#123;引用1, 引用2, 引用3…&#125;;</span><br><span class="line">注意 : 右面的[]内不允许出现数组的长度</span><br><span class="line">Teacher t1 = new Teacher();</span><br><span class="line">Teacher t2 = new Teacher();</span><br><span class="line">Teacher t3 = new Teacher();</span><br><span class="line">t1.name = “张一”;</span><br><span class="line">t2.name = “张二”;</span><br><span class="line">t3.name = “张三”;</span><br><span class="line"></span><br><span class="line">Teacher [] arr = new Teacher [] &#123;t1, t2, t3&#125;;</span><br><span class="line">arr[0].lesson(); // 不会出现问题</span><br><span class="line">② 引用类型名称[] 数组名 = &#123;引用1, 引用2, 引用3…&#125;;</span><br><span class="line">注意 : 此方式虽然简单, 但是它只能用于声明和创建必须在同一行语句中的情况.</span><br><span class="line">Teacher t1 = new Teacher();</span><br><span class="line">Teacher t2 = new Teacher();</span><br><span class="line">Teacher t3 = new Teacher();</span><br><span class="line">t1.name = “张一”;</span><br><span class="line">t2.name = “张二”;</span><br><span class="line">t3.name = “张三”;</span><br><span class="line"></span><br><span class="line">Teacher [] arr = &#123;t1, t2, t3&#125;;</span><br><span class="line">// arr = &#123;t2, t3&#125;; // 这样不可以</span><br><span class="line">arr[0].lesson(); // 不会出现问题</span><br></pre></td></tr></table></figure><h2 id="5-7-2-对象数组的使用"><a href="#5-7-2-对象数组的使用" class="headerlink" title="5.7.2 对象数组的使用"></a>5.7.2 对象数组的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Teacher[] arr = new Teacher [3]; // 共3个元素, 但是每个元素都是null</span><br><span class="line"></span><br><span class="line">arr[0] = new Teacher();</span><br><span class="line">arr[1] = new Teacher();</span><br><span class="line">arr[2] = new Teacher();</span><br><span class="line">arr[0].name = “张一”;</span><br><span class="line">arr[1].name = “张二”;</span><br><span class="line">arr[2].name = “张三”;</span><br><span class="line"></span><br><span class="line">for (Teacher t : arr) &#123;</span><br><span class="line">    System.out.println(t.name); // 访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5-1-类与对象&quot;&gt;&lt;a href=&quot;#5-1-类与对象&quot; class=&quot;headerlink&quot; title=&quot;5.1 类与对象&quot;&gt;&lt;/a&gt;5.1 类与对象&lt;/h1&gt;&lt;h2 id=&quot;5-1-1面向对象与面向过程&quot;&gt;&lt;a href=&quot;#5-1-1面向对象与面向过程&quot;
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>4. JavaSE-数组</title>
    <link href="http://yoursite.com/2016/08/25/4.%20JavaSE-%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2016/08/25/4. JavaSE-数组/</id>
    <published>2016-08-24T16:00:00.000Z</published>
    <updated>2019-06-04T01:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-1-数组的特点和好处"><a href="#4-1-数组的特点和好处" class="headerlink" title="4.1 数组的特点和好处"></a>4.1 数组的特点和好处</h1><h2 id="4-1-1-数组的特点"><a href="#4-1-1-数组的特点" class="headerlink" title="4.1.1 数组的特点"></a>4.1.1 数组的特点</h2><p>1、数组存储的是相同类型的一组元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] arr = &#123;1.6,2.3,1,2,&apos;a&apos;&#125;;</span><br></pre></td></tr></table></figure><p>2、数组的定义类型可以是任意类型，包含基本类型或引用类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;&quot;john&quot;,&quot;lucy&quot;&#125;;</span><br><span class="line">Person[] arr;</span><br><span class="line">int[][] arr;</span><br><span class="line">Person[][] arr;</span><br></pre></td></tr></table></figure></p><p>3、数组属于引用类型，引用存储在栈中，值存储在堆中，又称为对象。</p><p><img src="https://i.loli.net/2019/05/27/5ceba4934773730896.jpg" alt></p><p>4、数组的成员如果不赋值，有默认值。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte/short/int/long——&gt;0</span><br><span class="line">    float/double——&gt;0.0</span><br><span class="line">    char——&gt;\u0000</span><br><span class="line">    boolean——&gt;false</span><br><span class="line">    String——&gt;null</span><br></pre></td></tr></table></figure><p>5、数组的四要素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型、标识符、元素、下标（0——数组名.length-1）</span><br></pre></td></tr></table></figure></p><h2 id="4-1-2-数组的好处"><a href="#4-1-2-数组的好处" class="headerlink" title="4.1.2 数组的好处"></a>4.1.2 数组的好处</h2><p>说明：相当于用于保存一组元素的容器<br>好处：<br>1、提高代码的简洁性和扩展性，且同时开辟多个空间，提高了效率<br>2、分类存储，且空间是连续的，容易查找</p><h1 id="4-2-数组的语法和使用步骤"><a href="#4-2-数组的语法和使用步骤" class="headerlink" title="4.2 数组的语法和使用步骤"></a>4.2 数组的语法和使用步骤</h1><h2 id="4-2-1-动态初始化"><a href="#4-2-1-动态初始化" class="headerlink" title="4.2.1 动态初始化"></a>4.2.1 动态初始化</h2><p>针对题型：声明时不确定值是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">步骤1、声明</span><br><span class="line">数据类型[] 数组名;或</span><br><span class="line">数据类型 数组名[];</span><br><span class="line"></span><br><span class="line">步骤2、开辟空间</span><br><span class="line">数组名 = new 数据类型[长度];//长度不能省略</span><br><span class="line"></span><br><span class="line">步骤3、赋值</span><br><span class="line">方式一：一个个赋值</span><br><span class="line">数组名[下标] = 值;</span><br><span class="line">方式二：循环赋值</span><br><span class="line">for(int i=0;i&lt;数组名.length;i++)&#123;</span><br><span class="line">数组名[i] = 值;</span><br><span class="line">&#125;</span><br><span class="line">步骤4、使用</span><br><span class="line">System.out.println(数组名[下标]);</span><br></pre></td></tr></table></figure></p><h2 id="4-2-2-静态初始化"><a href="#4-2-2-静态初始化" class="headerlink" title="4.2.2 静态初始化"></a>4.2.2 静态初始化</h2><p>针对题型：声明时就知道值是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">步骤1、声明并初始化</span><br><span class="line">数据类型 数组名[] = new 数据类型[]&#123;值，值，值&#125;;或</span><br><span class="line">数据类型[] 数组名 = &#123;值，值，值&#125;;</span><br><span class="line">步骤2、使用</span><br></pre></td></tr></table></figure></p><h2 id="4-2-3-使用注意事项"><a href="#4-2-3-使用注意事项" class="headerlink" title="4.2.3 使用注意事项"></a>4.2.3 使用注意事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①数组的下标：0——arr.length-1,如果超出范围，</span><br><span class="line">则报ArrayIndexOutOfBoundsException</span><br><span class="line">②数组的成员如果不手动赋值，也有默认值</span><br><span class="line">int——0</span><br><span class="line">double——0.0</span><br><span class="line">char——\u0000</span><br><span class="line">boolean——false</span><br><span class="line">引用类型——null</span><br></pre></td></tr></table></figure><h1 id="4-3-数组的使用"><a href="#4-3-数组的使用" class="headerlink" title="4.3 数组的使用"></a>4.3 数组的使用</h1><h2 id="4-3-1-正序打印"><a href="#4-3-1-正序打印" class="headerlink" title="4.3.1 正序打印"></a>4.3.1 正序打印</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">   System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-2-逆序打印"><a href="#4-3-2-逆序打印" class="headerlink" title="4.3.2 逆序打印"></a>4.3.2 逆序打印</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=arr.length-1;i&gt;=0;i--)&#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-3-求和、平均值"><a href="#4-3-3-求和、平均值" class="headerlink" title="4.3.3 求和、平均值"></a>4.3.3 求和、平均值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">  sum+=arr[i];</span><br><span class="line">&#125;</span><br><span class="line">sum:和  aum/arr.length平均值</span><br></pre></td></tr></table></figure><h2 id="4-3-4-求最值"><a href="#4-3-4-求最值" class="headerlink" title="4.3.4 求最值"></a>4.3.4 求最值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int max = arr[0];</span><br><span class="line">int indexMax = 0;</span><br><span class="line">int min = arr[0];</span><br><span class="line">int indexMin = 0;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">   if(arr[i]&gt;max)&#123;</span><br><span class="line">     max = arr[i];</span><br><span class="line">     indexMax = i;</span><br><span class="line">   &#125;</span><br><span class="line">   if(arr[i]&lt;min)&#123;</span><br><span class="line">     min = arr[i];</span><br><span class="line">     indexMin = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>max:最大值<br>min：最小值</p><h2 id="4-3-5-查找"><a href="#4-3-5-查找" class="headerlink" title="4.3.5 查找"></a>4.3.5 查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int index=-1;</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">  if(arr[i]==带查找的元素)&#123;</span><br><span class="line">       index = i;</span><br><span class="line">       break;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(index==-1)&#123;//没找到&#125;else&#123;找到了&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-6-排序"><a href="#4-3-6-排序" class="headerlink" title="4.3.6 排序"></a>4.3.6 排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">  for(int j=0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line"></span><br><span class="line">     if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">       int t = arr[j];</span><br><span class="line">       arr[j] = arr[j+1];</span><br><span class="line">       arr[j+1]=t;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-7赋值"><a href="#4-3-7赋值" class="headerlink" title="4.3.7赋值"></a>4.3.7赋值</h2><p>特点：</p><ul><li>基本类型变量的赋值：赋的是值，其中一个更改不影响另外一个</li><li>引用类型变量的赋值：赋的是地址，二者共同引用一个空间，其中一个更改影响另外一个</li></ul><blockquote><p>如果希望赋的是值（内容），则可以采用循环赋值</p><ul><li>方式一：传统的使用 = 赋值<br><code>newArr = arr;</code></li><li>方式二：循环赋值<br>`①创建新数组，长度=旧数组.length<br>int[] newArr = new int[arr.length];<br>②循环将旧数组的元素依次赋值给新数组的每个成员<br>for(int i=0;i&lt;newArr.length;i++){<br>  newArr[i] = arr[i];<br>}</li></ul></blockquote><p> `</p><h1 id="4-4二维数组"><a href="#4-4二维数组" class="headerlink" title="4.4二维数组"></a>4.4二维数组</h1><h2 id="4-4-1-特点"><a href="#4-4-1-特点" class="headerlink" title="4.4.1 特点"></a>4.4.1 特点</h2><ul><li>二维数组本身属于也能用类型，保存的也是地址号</li><li>二维数组相当于多个一维数组的组合，也就是二维数组中的每个元素又是一个一维数组</li></ul><h2 id="4-4-2-使用步骤"><a href="#4-4-2-使用步骤" class="headerlink" title="4.4.2 使用步骤"></a>4.4.2 使用步骤</h2><ul><li>1、动态初始化</li></ul><p>步骤1 :声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">格式1：数据类型[][] 数组名;</span><br><span class="line">格式2：数据类型[] 数组名[];</span><br><span class="line">格式3:数据类型 数组名[][];</span><br></pre></td></tr></table></figure></p><p>步骤2:开辟空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式1：固定列数</span><br><span class="line">数组名 = new 数据类型[行数][列数];</span><br><span class="line">//行数相当于二维数组的长度或一维数组的个数，列数相当于每个一维数组中的成员个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式2：不固定列数</span><br><span class="line">数组名 = new 数据类型[行数][];</span><br><span class="line">前两步可以合二为一</span><br><span class="line">语法示例：</span><br><span class="line">int[][] arr = new int[5][];</span><br></pre></td></tr></table></figure></p><p>步骤3:赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">格式1：固定列数</span><br><span class="line">for(int i=0;i&lt;数组名.length;i++)&#123;</span><br><span class="line">   for(int j=0;j&lt;数组名[i].length;j++)&#123;</span><br><span class="line">     数组名[i][j] = 值;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">格式2：不固定列数</span><br><span class="line">for(int i=0;i&lt;数组名.length;i++)&#123;</span><br><span class="line">   数组名[i]=new 数据类型[长度];//长度不能省略！</span><br><span class="line">   for(int j=0;j&lt;数组名[i].length;j++)&#123;</span><br><span class="line">     数组名[i][j] = 值;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤4、使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;数组名.length;i++)&#123;</span><br><span class="line">   for(int j=0;j&lt;数组名[i].length;j++)&#123;</span><br><span class="line">     System.out.println(数组名[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>2、静态初始化</li></ul><p>步骤1、声明并初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名 =&#123;&#123;值，值&#125;,&#123;值，值，值&#125;&#125;;或</span><br><span class="line">数据类型[][] 数组名 =new 数据类型[][]&#123;&#123;值，值&#125;,&#123;值，值，值&#125;&#125;;</span><br></pre></td></tr></table></figure></p><p>步骤2、使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;数组名.length;i++)&#123;</span><br><span class="line">   for(int j=0;j&lt;数组名[i].length;j++)&#123;</span><br><span class="line">     System.out.println(数组名[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;4-1-数组的特点和好处&quot;&gt;&lt;a href=&quot;#4-1-数组的特点和好处&quot; class=&quot;headerlink&quot; title=&quot;4.1 数组的特点和好处&quot;&gt;&lt;/a&gt;4.1 数组的特点和好处&lt;/h1&gt;&lt;h2 id=&quot;4-1-1-数组的特点&quot;&gt;&lt;a href=&quot;#4-
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>3. JavaSE-流程控制结构</title>
    <link href="http://yoursite.com/2016/08/12/3.%20JavaSE-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2016/08/12/3. JavaSE-流程控制结构/</id>
    <published>2016-08-11T16:00:00.000Z</published>
    <updated>2019-06-04T01:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-1顺序结构"><a href="#3-1顺序结构" class="headerlink" title="3.1顺序结构"></a>3.1顺序结构</h1><p>说明：程序从上往下执行<br>Java中定义成员变量时采用合法的前向引用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">        int num1 = 12;</span><br><span class="line">        int num2 = num1 + 2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">       int num2 = num1 + 2； </span><br><span class="line">       int num1 = 12; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-2分支结构"><a href="#3-2分支结构" class="headerlink" title="3.2分支结构"></a>3.2分支结构</h1><h2 id="3-2-1-if结构"><a href="#3-2-1-if结构" class="headerlink" title="3.2.1  if结构"></a>3.2.1  if结构</h2><p>1、单分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">if(条件表达式)&#123; </span><br><span class="line">执行代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构图：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603234239.png" alt></p><p>2、双分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">if(条件表达式)&#123;</span><br><span class="line">执行代码块1; </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">执行代码块2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构图：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603234539.png" alt></p><p>3、多重分支<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式1)&#123; </span><br><span class="line">执行代码块1; </span><br><span class="line">      &#125;</span><br><span class="line">      else if (条件表达式2)&#123; </span><br><span class="line">执行代码块2; </span><br><span class="line">      &#125;</span><br><span class="line">       ……</span><br><span class="line">       else&#123;</span><br><span class="line">执行代码块n; </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>结构图：</p><p><img src="https://i.loli.net/2019/05/27/5ceb7e25ee3eb98283.jpg" alt="结构图"></p><h2 id="3-2-2-switch结构"><a href="#3-2-2-switch结构" class="headerlink" title="3.2.2  switch结构"></a>3.2.2  switch结构</h2><p>1、语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句1;</span><br><span class="line">break;</span><br><span class="line">case 常量2:</span><br><span class="line">语句2;</span><br><span class="line">break;</span><br><span class="line">… …</span><br><span class="line">case 常量N:</span><br><span class="line">语句N;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">语句;</span><br><span class="line">break;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>2、规则</p><blockquote><p>①变量的类型 只能是int、byte、short、char、String（jdk1.7）、枚举（jdk1.5）<br>②case后的常量值不能重复<br>③case后不可以是变量<br>④break可以省略，但可能影响效果<br>⑤default可以省略，位置也可以提前，但可能影响效果</p></blockquote><p>3、执行顺序</p><blockquote><p>先得出switch括号中变量的值，然后依次判断各个case，如果有匹配的，则执行对应的代码块，直到遇见break为止；如果都不匹配，则执行default中的代码块n，直到遇见break为止</p></blockquote><h1 id="3-3-循环结构"><a href="#3-3-循环结构" class="headerlink" title="3.3 循环结构"></a>3.3 循环结构</h1><h2 id="3-3-1-说明"><a href="#3-3-1-说明" class="headerlink" title="3.3.1  说明"></a>3.3.1  说明</h2><p><strong>在满足某个特定条件的基础上，反复执行某段代码的结构</strong></p><h2 id="3-3-2-四要素"><a href="#3-3-2-四要素" class="headerlink" title="3.3.2 四要素"></a>3.3.2 四要素</h2><pre><code>1、循环变量初始化2、循环条件3、循环操作4、循环变量更新</code></pre><h2 id="3-3-3-好处"><a href="#3-3-3-好处" class="headerlink" title="3.3.3 好处"></a>3.3.3 好处</h2><pre><code>1、提高代码的简洁性2、提高代码的维护性和扩展性</code></pre><h2 id="3-3-4-分类"><a href="#3-3-4-分类" class="headerlink" title="3.3.4 分类"></a>3.3.4 分类</h2><pre><code>whiledo whileforjdk5.0之后，多了增强for循环（foreach）</code></pre><h2 id="3-3-5-落地步骤"><a href="#3-3-5-落地步骤" class="headerlink" title="3.3.5 落地步骤"></a>3.3.5 落地步骤</h2><ul><li>题型一：知道次数</li></ul><p>优先考虑用for<br>1、先搭框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=次数;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、分析循环操作<br>3、检测循环是否具备四要素</p><ul><li>题型二：不知道次数</li></ul><p>1、先搭框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、分析循环操作和循环条件<br>3、检测循环是否具备四要素</p><h2 id="3-3-6三种循环结构的详细介绍"><a href="#3-3-6三种循环结构的详细介绍" class="headerlink" title="3.3.6三种循环结构的详细介绍"></a>3.3.6三种循环结构的详细介绍</h2><p>1、while<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化 ①</span><br><span class="line"></span><br><span class="line">while(循环条件)&#123; ②</span><br><span class="line"></span><br><span class="line">循环操作 ③</span><br><span class="line">循环变量更新 ④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行顺序：①②③④②③④….直到②不成立为止</p><p>2、do while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化 ①</span><br><span class="line">do&#123;</span><br><span class="line">循环操作 ③</span><br><span class="line">循环变量更新 ④</span><br><span class="line">&#125;while(循环条件); ②</span><br></pre></td></tr></table></figure><p>执行顺序：①③④②③④②③④…直到②不成立为止</p><p>3、for<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①          ②④</span><br><span class="line">for(循环变量初始化;循环条件;循环变量更新)&#123;</span><br><span class="line"></span><br><span class="line">循环操作③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行顺序：①②③④②③④….直到②不成立为止</p><h2 id="3-3-7-三种循环结构大pk"><a href="#3-3-7-三种循环结构大pk" class="headerlink" title="3.3.7 三种循环结构大pk"></a>3.3.7 三种循环结构大pk</h2><ul><li><p>相同点：<br>  1、都能解决任何类型的循环题目<br>  2、都具备循环四要素</p></li><li><p>不同点：</p><p>  1、语法不同<br>  2、执行顺序不同    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while和for 先判断后执行</span><br><span class="line">do while   先执行后判断</span><br></pre></td></tr></table></figure><p>  3、执行效果不同<br>  如果第一次条件成立，<code>while、do while、for</code> 执行效果相同<br>  如果第一次条件不成立，<code>while、for</code> 执行0次；<code>do while</code>执行至少一次！<br>  4、执行效率不同<br>  <code>do while</code> 效率最高<br>  5、应用场景不同<br>  知道次数，优先考虑用for<br>  不知道次数，</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先判断：while</span><br><span class="line">先执行：do while</span><br></pre></td></tr></table></figure><h2 id="3-3-8-嵌套循环"><a href="#3-3-8-嵌套循环" class="headerlink" title="3.3.8 嵌套循环"></a>3.3.8 嵌套循环</h2><p>说明：一个循环结构中又嵌套了另一个完整的循环结构<br>注意：如外层循环，执行m次；内层循环，执行n次。 内层循环的循环体最终执行 m*n次<br>经典案例：九九乘法表</p><p><img src="https://i.loli.net/2019/05/27/5ceb7e260b1a827777.jpg" alt></p><h1 id="3-4-跳转结构"><a href="#3-4-跳转结构" class="headerlink" title="3.4 跳转结构"></a>3.4 跳转结构</h1><h2 id="3-4-1-break"><a href="#3-4-1-break" class="headerlink" title="3.4.1 break"></a>3.4.1 break</h2><p>说明：一般用在switch或循环中，跳出所在的switch或循环结构。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(循环条件)&#123;</span><br><span class="line">   if(条件)&#123;</span><br><span class="line">     break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特点：<br><strong>只能跳出所在的switch或一层循环，如果想跳出外层循环，需要添加label标签使用。</strong></p><h2 id="3-4-2-continue"><a href="#3-4-2-continue" class="headerlink" title="3.4.2 continue"></a>3.4.2 continue</h2><p>说明：只能用于循环中，结束本次循环，继续下一次循环<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(循环条件)&#123;</span><br><span class="line">if(条件)&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特点：<br><strong>continue如果不搭配标签，默认起作用的就是所在的一层循环。如果搭配标签，则可以跳出标签指定的循环</strong></p><h2 id="3-4-1-return"><a href="#3-4-1-return" class="headerlink" title="3.4.1 return"></a>3.4.1 return</h2><p>说明：跳出所在的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-1顺序结构&quot;&gt;&lt;a href=&quot;#3-1顺序结构&quot; class=&quot;headerlink&quot; title=&quot;3.1顺序结构&quot;&gt;&lt;/a&gt;3.1顺序结构&lt;/h1&gt;&lt;p&gt;说明：程序从上往下执行&lt;br&gt;Java中定义成员变量时采用合法的前向引用。如：&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>2. JavaSE-变量与运算符</title>
    <link href="http://yoursite.com/2016/08/04/2.%20JavaSE-%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2016/08/04/2. JavaSE-变量与运算符/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2019-06-04T01:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重点-变量-amp-常见数据类型概览"><a href="#重点-变量-amp-常见数据类型概览" class="headerlink" title="重点:变量&amp;常见数据类型概览"></a>重点:变量&amp;常见数据类型概览</h1><p>变量的理解  </p><pre><code>概念：内存中一块数据存储空间的表示。  </code></pre><p>变量三要素</p><pre><code>数据类型变量名变量值</code></pre><p>变量使用步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式1：三步法（声明-赋值-使用）</span><br><span class="line">        //步骤1：声明变量</span><br><span class="line">        int age;//(内存帮我们开辟一个int大小的房间，房间名叫age)</span><br><span class="line">        //步骤2：为变量赋值</span><br><span class="line">        age = 18;//(将18放到名叫age的房间中)</span><br><span class="line">        //步骤3：使用变量</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        格式2：两步法（声明/赋值-使用）</span><br><span class="line">        //步骤1：声明变量并赋值</span><br><span class="line">        int age = 18;//(内存帮我们开辟一个int大小的房间，房间名叫age，并将值18放进去)</span><br><span class="line">        //步骤2：使用变量</span><br><span class="line">        System.out.println(age);</span><br></pre></td></tr></table></figure><p>变量的特点</p><pre><code>1、变量必须先声明、赋值后才能使用完全遵循：声明-赋值-使用2、同一个作用域内，变量不可以重名3、变量的值是可以变化的4、变量的值是临时存储的，遵循内存的特点：易失性</code></pre><p>常见数据类型</p><pre><code>整型：说明：用于存储整数，比如100/99    byte字节整型    short短整型    int整型    long长整型浮点型：说明：用于存储小数，比如100.9、99.0    float单精度浮点型    double双精度浮点型字符型：说明：用于存储单个字符，比如 &apos;a&apos; 、&apos;男&apos;  、&apos;1&apos;    char 字符型布尔型：说明：用于存储多个字符，比如 &quot;张三丰&quot;  、&quot;a&quot; 、&quot;&quot; 、&quot;1&quot; 基本数据类型（原始数据类型）    boolean 布尔型</code></pre><p>引用数据类型（复杂数据类型）</p><pre><code>使用class定义的类型：String使用interface定义的接口数组</code></pre><p>基本数据类型之间的转换（除了boolean类型）</p><pre><code>byte-&gt; short-&gt; int-&gt; long-&gt;float-&gt;doublechar-&gt;int自动类型转换：规则：小——&gt;大强制类型转换：规则：大——&gt;小</code></pre><p>细节：</p><pre><code>①自动提升原则：表达式的结果类型为 操作数中类型最大的②强转符号只针对于最近的变量有效③byte和short在进行运算时，当做int类型处理！④char类型的值可以是int的常量值，但不可以是int的变量值，需要强转。</code></pre><p>命名规则</p><pre><code>只能包含字母、数字、_或$符号，不能是关键字或保留字，不能以数字开头！</code></pre><p>命名规范</p><pre><code>要求见名知义，提高阅读性变量名和方法名：遵循驼峰命名法，第一个单词全小写，其他单词首字符大写，其他字符小写类名和接口名：遵循Pascal命名法，所有单词，首字符大写，其他字符小写。</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="1-1-基本算术运算符"><a href="#1-1-基本算术运算符" class="headerlink" title="1 -1 基本算术运算符"></a>1 -1 基本算术运算符</h3><pre><code>+ - * / %特点：①/左右的操作数如果都是整型，则结果取整②a%b 相当于 a-(int)a/b*b    13.5%3=13.5- 13/3*3=1.5    -13%-3= -13 - (-13)/3*3 = -1③属于二元操作符，运算顺序：从左往右 算术表达式的结果肯定是数值型</code></pre><h3 id="1-2-自增、自减算术运算符"><a href="#1-2-自增、自减算术运算符" class="headerlink" title="1-2 自增、自减算术运算符"></a>1-2 自增、自减算术运算符</h3><pre><code>++ --特点：①属于一元操作符i++;--i;++ii--;int j = i++;②既可以作为独立语句使用，又可以作为表达式使用如果作为独立语句使用，则i++;等价于++i;等价于i=i+1;如果作为表达式使用，则  ★        int j= i++; 先赋值后自增        int j= ++i; 先自增后赋值③自增、自减运算符，编译器做了内部的优化，会进行自动的类型转换，而且效率也提高了byte b = 1;b++;//不会报编译错误！</code></pre><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><h3 id="1、摘要"><a href="#1、摘要" class="headerlink" title="1、摘要"></a>1、摘要</h3><pre><code>&gt;  &lt;   &gt;= &lt;= ==  !=</code></pre><h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><pre><code>①属于二元操作符②关系表达式的结果类型肯定是 boolean类型③关系表达式一般当作条件放在if结构或循环结构中</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h3 id="1、引入"><a href="#1、引入" class="headerlink" title="1、引入"></a>1、引入</h3><pre><code>需求：如果令狐冲 java成绩&gt;90,则岳灵珊就和他在一起    if(javaScore&gt;90){    }进阶：如果令狐冲 java成绩&gt;90并且music&gt;85并且 dance==100 或 html&gt;70 则岳灵珊就和他在一起    if(java&gt;90&amp;&amp;music&gt;85&amp;&amp;dance==100||html&gt;70){}作用：为了连接多个关系表达式的，最终的结果依然是boolean类型</code></pre><h3 id="2、摘要"><a href="#2、摘要" class="headerlink" title="2、摘要"></a>2、摘要</h3><pre><code>        名称          写法              特点&amp;&amp;      短路与         条件1 &amp;&amp; 条件2      两个条件都成立，结果为true||      短路或         条件1 || 条件2      只要有一个条件成立，结果为true！       非               !条件             如果条件本身成立，结果为false&amp;       逻辑与         条件1 &amp; 条件2       两个条件都成立，结果为true|       逻辑或         条件1 | 条件2       只要有一个条件成立，结果为true&amp;&amp;和&amp;的区别：&amp;&amp;      如果第一个条件不成立，则不再判断第二个条件，直接结果为false&amp;       不管第一个条件是否成立，都要判断第二个条件||和|的区别：||      如果第一个条件成立，则不再判断第二个条件，直接结果为true|       不管第一个条件是否成立，都要判断第二个条件</code></pre><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><pre><code>语法：条件?表达式1:表达式2特点：①如果条件成立，结果为表达式1的值，否则为表达式2的值②表达式1和表达式2的类型要求一致或兼容③如果条件成立，则表达式2根本不用计算；如果条件不成立，则表达式1根本不用计算。</code></pre><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><pre><code>() 自增、自减 ！算术运算符    * / %        + -关系运算符    &gt; &lt; &gt;= &lt;=    == !=逻辑运算符    &amp;&amp;     ||三元运算符赋值运算符</code></pre><h1 id="2-1-关键字与保留字"><a href="#2-1-关键字与保留字" class="headerlink" title="2-1 关键字与保留字"></a>2-1 关键字与保留字</h1><p>关键字(keyword)的定义和特点</p><ul><li>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</li><li>特点：关键字中所有字母都为小写</li><li>官方地址：<br><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></li></ul><p><img src="https://s2.ax1x.com/2019/05/08/EcFWDg.png" alt="EcFWDg.png"></p><p><img src="https://s2.ax1x.com/2019/05/08/EckYIs.png" alt="EckYIs.png"></p><p>保留字(reserved word)</p><pre><code>ava保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 goto 、const</code></pre><h1 id="2-2-标识符-Identifier"><a href="#2-2-标识符-Identifier" class="headerlink" title="2-2 标识符(Identifier)"></a>2-2 标识符(Identifier)</h1><h2 id="标识符："><a href="#标识符：" class="headerlink" title="标识符："></a>标识符：</h2><blockquote><ul><li>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li><li>技巧：凡是自己可以起名字的地方都叫标识符。</li><li>定义合法标识符规则：<br>由26个英文字母大小写，0-9 ，_或 $ 组成 </li><li>数字不可以开头。</li><li>不可以使用关键字和保留字，但能包含关键字和保留字。</li><li>Java中严格区分大小写，长度无限制。</li><li>标识符不能包含空格。</li></ul></blockquote><h2 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h2><blockquote><ul><li>包名：多单词组成时所有字母都小写：xxxyyyzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个&gt;- 单词开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ul></blockquote><blockquote><ul><li>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</li><li>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</li></ul></blockquote><ul><li>更多细节详见《<strong>代码整洁之道.pdf</strong>》<a href="https://pan.baidu.com/s/1B_EW3BKPBA03A1fmisA9rg" target="_blank" rel="noopener">点击下载</a></li></ul><h1 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2-3 变量"></a>2-3 变量</h1><h2 id="变量的概念："><a href="#变量的概念：" class="headerlink" title="变量的概念："></a>变量的概念：</h2><blockquote><ul><li>内存中的一个存储区域</li><li>该区域的数据可以在同一类型范围内不断变化</li><li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li></ul></blockquote><h2 id="变量的作用："><a href="#变量的作用：" class="headerlink" title="变量的作用："></a>变量的作用：</h2><blockquote><ul><li>用于在内存中保存数据</li></ul></blockquote><h2 id="使用变量注意："><a href="#使用变量注意：" class="headerlink" title="使用变量注意："></a>使用变量注意：</h2><blockquote><ul><li>Java中每个变量必须先声明，后使用</li><li>使用变量名来访问这块区域的数据</li><li>变量的作用域：其定义所在的一对{ }内</li><li>变量只有在其作用域内才有效</li><li>同一个作用域内，不能定义重名的变量</li></ul></blockquote><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><blockquote><ul><li>语法：&lt;数据类型&gt;  &lt;变量名称&gt;</li><li>例如：int var;</li></ul></blockquote><h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><blockquote><ul><li>语法：&lt;变量名称&gt; =  &lt;值&gt;</li><li>例如：var = 10;</li></ul></blockquote><h2 id="声明和赋值变量"><a href="#声明和赋值变量" class="headerlink" title="声明和赋值变量"></a>声明和赋值变量</h2><blockquote><ul><li>语法： &lt;数据类型&gt;  &lt;变量名&gt;  =  &lt;初始化值&gt;</li><li>例如：int var = 10;</li></ul></blockquote><h2 id="变量的分类-按数据类型"><a href="#变量的分类-按数据类型" class="headerlink" title="变量的分类-按数据类型"></a>变量的分类-按数据类型</h2><pre><code>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。</code></pre><p><a href="https://imgchr.com/i/EcAdkd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/08/EcAdkd.md.png" alt="EcAdkd.md.png"></a></p><p>补充：变量的分类-按声明的位置的不同  </p><blockquote><p>在方法体外，类体内声明的变量称为<strong>成员变量</strong>。<br>在方法体内部声明的变量称为<strong>局部变量</strong>。</p></blockquote><p><img src="https://s2.ax1x.com/2019/05/08/EcEnjf.png" alt="EcEnjf.png"></p><ul><li><strong>注意：二者在初始化值方面的异同</strong>:<blockquote><ul><li><strong>同</strong>：都有生命周期      </li><li><strong>异</strong>：局部变量除形参外，需显式初始化。</li></ul></blockquote><h1 id="2-4-基本数据类型"><a href="#2-4-基本数据类型" class="headerlink" title="2-4 基本数据类型"></a>2-4 基本数据类型</h1><h2 id="整数类型-byte、short、int、long"><a href="#整数类型-byte、short、int、long" class="headerlink" title="整数类型:byte、short、int、long"></a>整数类型:byte、short、int、long</h2><blockquote><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。</p><ul><li><strong>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</strong></li><li><strong>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</strong></li></ul></blockquote></li></ul><p><img src="https://s2.ax1x.com/2019/05/08/EcE3Nj.png" alt="EcE3Nj.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class VariableTest &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          int number1;</span><br><span class="line">          number1 = 10;</span><br><span class="line"></span><br><span class="line">          int number2;</span><br><span class="line">          number2 = 20;</span><br><span class="line"> </span><br><span class="line">          int number3;</span><br><span class="line">        number3 = number1 + number2;</span><br><span class="line">        System.out.println(&quot;Number3 = &quot; + number3);</span><br><span class="line"></span><br><span class="line">        int number4 = 50;</span><br><span class="line">        int number5 = number4 - number3;</span><br><span class="line">        System.out.println(&quot;Number5 = &quot; + number5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="浮点类型-float、double"><a href="#浮点类型-float、double" class="headerlink" title="浮点类型:float、double"></a>浮点类型:float、double</h2><p>与整数类型类似，Java <strong>浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响</strong>。<br>浮点型常量有两种表示形式：</p><ul><li>十进制数形式：如：5.12       512.0f        .512   (必须有小数点）</li><li>科学计数法形式:如：5.12e2      512E2     100E-2<blockquote><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。<br>double:双精度，精度是float的两倍。通常采用此类型。</p></blockquote></li></ul><p><strong>Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’</strong>。</p><h2 id="字符类型：char"><a href="#字符类型：char" class="headerlink" title="字符类型：char"></a>字符类型：char</h2><blockquote><ul><li>char 型数据用来表示通常意义上“<strong>字符</strong>”(2字节)</li><li>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 </li></ul></blockquote><p>字符型变量的三种表现形式：</p><blockquote><ul><li>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 = ‘a’;   char c2 = ‘中’; char c3 =  ‘9’;</li><li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\n’;  // ‘\n’表示换行符</li><li>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。</li></ul></blockquote><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p><p><img src="https://s2.ax1x.com/2019/05/08/EcQXqI.png" alt="EcQXqI.png"></p><h1 id="了解："><a href="#了解：" class="headerlink" title="了解："></a>了解：</h1><h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><blockquote><ul><li>在计算机内部，所有数据都使用二进制表示。每一个二进制位（bit）有 0 和 1 两种状态，因此 8 个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从 0000000 到 11111111。</li><li>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</li></ul></blockquote><h3 id="ASCII码缺点："><a href="#ASCII码缺点：" class="headerlink" title="ASCII码缺点："></a>ASCII码缺点：</h3><blockquote><ul><li>不能表示所有字符。</li><li>相同的编码表示的字符不一样：比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)<br>了解： Unicode 编码<br>乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。</li></ul></blockquote><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。</p><h3 id="Unicode-的缺点："><a href="#Unicode-的缺点：" class="headerlink" title="Unicode 的缺点："></a>Unicode 的缺点：</h3><p>Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储;<br>无法区别 Unicode 和ASCII：<br>计算机无法区分三个字节表示一个符号还是分别表示三个符号。<br>另外，我们知道，英文字母只用一个字节表示就够了，<br>如果unicode统一规定，每个符号用三个或四个字节表示，<br>那么每个英文字母前都必然有二到三个字节是0，<br>这对于存储空间来说是极大的浪费。  </p><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><blockquote><ul><li>UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式。</li><li>UTF-8 是一种变长的编码方式。它可以使用 1-6 个字节表示一个符号，根据不同的符号而变化字节长度。</li></ul></blockquote><h3 id="UTF-8的编码规则："><a href="#UTF-8的编码规则：" class="headerlink" title="UTF-8的编码规则："></a>UTF-8的编码规则：</h3><ul><li>对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。</li><li>对于多字节的UTF-8编码，如果编码包含 n 个字节，那么第一个字节的前 n 位为1，第一个字节的第 n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。 </li></ul><h1 id="布尔类型：boolean"><a href="#布尔类型：boolean" class="headerlink" title="布尔类型：boolean"></a>布尔类型：boolean</h1><p>boolean 类型用来判断逻辑条件，一般用于程序流程控制：</p><ul><li>if条件控制语句；                 </li><li>while循环控制语句；</li><li>do-while循环控制语句；     </li><li>for循环控制语句； </li></ul><p>boolean类型数据只允许取值true和false，无null。</p><ul><li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li><li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范 8版》<h1 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h1>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<br><img src="https://s2.ax1x.com/2019/05/08/Ec34Zn.png" alt="Ec34Zn.png"><br>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li><li>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</li><li>boolean类型不能与其它数据类型运算。<br>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。<br>字符串类型：String<br>String不是基本数据类型，属于引用数据类型<br>使用方式与基本数据类型一致。例如：String str = “abcd”;<br>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = str + “xyz” ;</span><br><span class="line">int n = 100;</span><br><span class="line">str = str + n;</span><br></pre></td></tr></table></figure><h1 id="示-例—StringTest类"><a href="#示-例—StringTest类" class="headerlink" title="示 例—StringTest类"></a>示 例—StringTest类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          int no = 10;</span><br><span class="line">          String str = &quot;abcdef&quot;;</span><br><span class="line">          String str1 = str + “xyz” + no;</span><br><span class="line"></span><br><span class="line">          str1 = str1 + &quot;123&quot;;</span><br><span class="line">          char c = &apos;国&apos;;</span><br><span class="line"> </span><br><span class="line">         double pi = 3.1416;</span><br><span class="line">         str1 = str1 + pi;</span><br><span class="line">         boolean b = false;</span><br><span class="line">         str1 = str1 + b;</span><br><span class="line">         str1 = str1 + c;</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;str1 = &quot; + str1);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>练习1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = 4;        //判断对错：no</span><br><span class="line">String str2 = 3.5f + “”;             //判断str2对错：yes</span><br><span class="line">System.out.println(str2);        //输出：”3.5”</span><br><span class="line">System.out .println(3+4+“Hello!”);     //输出：7Hello!</span><br><span class="line">System.out.println(“Hello!”+3+4);      //输出：Hello!34</span><br><span class="line">System.out.println(‘a’+1+“Hello!”);    //输出：98Hello!</span><br><span class="line">System.out.println(“Hello”+‘a’+1);     //输出：Helloa1</span><br></pre></td></tr></table></figure><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><ul><li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li><li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。<br>如： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = “43”; int i = Integer.parseInt(a);</span><br></pre></td></tr></table></figure><ul><li>boolean类型不可以转换为其它的数据类型。<br>练习2<br>判断是否能通过编译</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）short  s = 5;</span><br><span class="line">      s = s-2;                       //判断：no</span><br><span class="line">2） byte b = 3;</span><br><span class="line">       b = b + 4;                  //判断：no</span><br><span class="line">       b = (byte)(b+4);        //判断：yes</span><br><span class="line">3）char c = ‘a’;</span><br><span class="line">      int  i = 5;</span><br><span class="line">      float d = .314F;</span><br><span class="line">      double result = c+i+d;     //判断：yes</span><br><span class="line">4） byte b = 5;</span><br><span class="line">       short s = 3;</span><br><span class="line">       short t = s + b;          //判断：no</span><br></pre></td></tr></table></figure><h1 id="进-制"><a href="#进-制" class="headerlink" title="进  制"></a>进  制</h1><p>==世界上有10种人 ，认识和不认识二进制的。==</p><h2 id="关于进制"><a href="#关于进制" class="headerlink" title="关于进制"></a>关于进制</h2><ul><li>所有数字在计算机底层都以二进制形式存在。<br>对于整数，有四种表示方式：<blockquote><ul><li>二进制(binary)：0,1 ，满2进1.以0b或0B开头。</li><li>十进制(decimal)：0-9 ，满10进1。</li><li>八进制(octal)：0-7 ，满8进1. 以数字0开头表示。</li><li>十六进制(hex)：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。<br>如：0x21AF +1= 0X21B0</li></ul></blockquote></li></ul><p><a href="https://imgchr.com/i/Ec6GgH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/Ec6GgH.png" alt="Ec6GgH.png"></a></p><p><img src="https://s2.ax1x.com/2019/05/09/Ec6Ubt.png" alt="Ec6Ubt.png"></p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p><strong>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</strong></p><h2 id="二进制的整数有如下三种形式："><a href="#二进制的整数有如下三种形式：" class="headerlink" title="二进制的整数有如下三种形式："></a>二进制的整数有如下三种形式：</h2><ul><li>原码：直接将一个数值换成二进制数。最高位是符号位</li><li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li><li>负数的补码：其反码加1。</li></ul><h2 id="计算机以二进制补码的形式保存所有的整数。"><a href="#计算机以二进制补码的形式保存所有的整数。" class="headerlink" title="计算机以二进制补码的形式保存所有的整数。"></a>计算机以二进制补码的形式保存所有的整数。</h2><ul><li>正数的原码、反码、补码都相同</li><li>负数的补码是其反码+1</li></ul><p>使用原码、反码、补码表示形式的原因</p><blockquote><p>计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。</p></blockquote><p><a href="https://imgchr.com/i/Ec6xPO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/Ec6xPO.md.png" alt="Ec6xPO.md.png"></a></p><h2 id="二进制-gt-十进制"><a href="#二进制-gt-十进制" class="headerlink" title="二进制-&gt;十进制"></a>二进制-&gt;十进制</h2><p><a href="https://imgchr.com/i/EccPsA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/EccPsA.md.png" alt="EccPsA.md.png"></a><br>在计算机底层，都是以补码的方式存储数值的。<br><strong>对于正数来说：原码、反码、补码是相同的，三码合一</strong></p><p><a href="https://imgchr.com/i/EccKMj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/EccKMj.md.png" alt="EccKMj.md.png"></a></p><p><a href="https://imgchr.com/i/EcczT0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/EcczT0.md.png" alt="EcczT0.md.png"></a></p><h2 id="进制间转化"><a href="#进制间转化" class="headerlink" title="进制间转化"></a>进制间转化</h2><ul><li>十进制  二进制互转</li></ul><blockquote><p>   二进制转成十进制  乘以2的幂数<br>   十进制转成二进制  除以2取余数</p></blockquote><ul><li>二进制  八进制互转</li><li>二进制   十六进制互转</li><li>十进制 八进制互转</li><li>十进制 十六进制互转</li></ul><p><img src="https://s2.ax1x.com/2019/05/09/EcgeTx.png" alt="EcgeTx.png"></p><p><a href="https://imgchr.com/i/Ecgl1e" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/Ecgl1e.md.png" alt="Ecgl1e.md.png"></a></p><p><img src="https://s2.ax1x.com/2019/05/09/EcgJ0I.png" alt="EcgJ0I.png"></p><h1 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2-4 运算符"></a>2-4 运算符</h1><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><h2 id="算术运算符-1"><a href="#算术运算符-1" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://s2.ax1x.com/2019/05/09/EcgTBR.png" alt="EcgTBR.png"><br><strong>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。</strong><br>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000;  x的结果是？<br>“+”除字符串相加功能外，还能把非字符串转换成字符串.例如：System.out.println(“5+5=”+5+5); //打印结果是？ 5+5=55 ? </p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>符号：=</strong></p><ul><li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li><li>支持连续赋值。</li></ul><p>扩展赋值运算符： +=, -=, *=, /=, %=</p><h2 id="比较运算符（关系运算符）"><a href="#比较运算符（关系运算符）" class="headerlink" title="比较运算符（关系运算符）"></a>比较运算符（关系运算符）</h2><p><img src="https://s2.ax1x.com/2019/05/09/Ec288U.png" alt="Ec288U.png"></p><ul><li>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</li><li>比较运算符“==”不能误写成“=” 。<h2 id="逻辑运算符-1"><a href="#逻辑运算符-1" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2>&amp;—逻辑与  　　　 | —逻辑或 　　　 ！—逻辑非<br>&amp;&amp; —短路与　　　 || —短路或 　　 ^ —逻辑异或<br><img src="https://s2.ax1x.com/2019/05/09/EcRkZR.png" alt="EcRkZR.png"><br>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class  Test  &#123;</span><br><span class="line">        public static void main (String []  args)  &#123;</span><br><span class="line">           boolean x=true;</span><br><span class="line">           boolean y=false;</span><br><span class="line">           short z=42;</span><br><span class="line">      //if(y == true)</span><br><span class="line">             if((z++==42)&amp;&amp;(y=true))z++;</span><br><span class="line">             if((x=false) || (++z==45))  z++;</span><br><span class="line"></span><br><span class="line">           System. out.println(“z=”+z);</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        //结果: z=46</span><br></pre></td></tr></table></figure><h3 id="“-amp-”和“-amp-amp-”的区别："><a href="#“-amp-”和“-amp-amp-”的区别：" class="headerlink" title="“&amp;”和“&amp;&amp;”的区别："></a>“&amp;”和“&amp;&amp;”的区别：</h3><ul><li>单&amp;时，左边无论真假，右边都进行运算；</li><li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li></ul><blockquote><p>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</p></blockquote><blockquote><p>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。<br>      理解：<strong>异或，追求的是“异”!</strong></p></blockquote><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="https://s2.ax1x.com/2019/05/09/EcRmRO.png" alt="EcRmRO.png"><br><strong>位运算是直接对整数的二进制进行的运算</strong><br><img src="https://s2.ax1x.com/2019/05/09/EcRaQg.png" alt="EcRaQg.png"></p><h2 id="三元运算符-1"><a href="#三元运算符-1" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>格式:</p><ul><li>(条件表达式)?表达式1：表达式2；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(条件表达式)为true，运算后的结果是表达式1；</span><br><span class="line">(条件表达式)为false，运算后的结果是表达式2；</span><br></pre></td></tr></table></figure><ul><li>表达式1和表达式2为同种类型</li><li>三元运算符与if-else的联系与区别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）三元运算符可简化if-else语句</span><br><span class="line">2）三元运算符要求必须返回一个结果。</span><br><span class="line">3）if后的代码块可有多个语句</span><br></pre></td></tr></table></figure><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><h3 id="变量与运算符"><a href="#变量与运算符" class="headerlink" title="变量与运算符"></a>变量与运算符</h3><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。<br>如下表，上一行运算符总优先于下一行。<br>只有单目运算符、三元运算符、赋值运算符是从右向左运算的。</p><p><img src="https://s2.ax1x.com/2019/05/09/EcW1cF.png" alt="EcW1cF.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重点-变量-amp-常见数据类型概览&quot;&gt;&lt;a href=&quot;#重点-变量-amp-常见数据类型概览&quot; class=&quot;headerlink&quot; title=&quot;重点:变量&amp;amp;常见数据类型概览&quot;&gt;&lt;/a&gt;重点:变量&amp;amp;常见数据类型概览&lt;/h1&gt;&lt;p&gt;变量的理解 
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>1. JavaSE-语言概述</title>
    <link href="http://yoursite.com/2016/07/25/1.%20JavaSE-%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2016/07/25/1. JavaSE-语言概述/</id>
    <published>2016-07-24T16:00:00.000Z</published>
    <updated>2019-06-04T01:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-软件开发介绍"><a href="#1-1-软件开发介绍" class="headerlink" title="1.1 软件开发介绍"></a>1.1 软件开发介绍</h1><h2 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h2><p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。  </p><h2 id="人机交互方式"><a href="#人机交互方式" class="headerlink" title="人机交互方式"></a>人机交互方式</h2><p>图形化界面(Graphical User Interface GUI)这种方式简单直观，使用者易于接受，容易上手操作。<br>命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。<br>==Pascal之父Nicklaus Wirth： “Algorithms+Data Structures=Programs”==</p><h2 id="常用的DOS命令"><a href="#常用的DOS命令" class="headerlink" title="常用的DOS命令"></a>常用的DOS命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dir :    列出当前目录下的文件以及文件夹</span><br><span class="line">md :   创建目录</span><br><span class="line">rd :     删除目录</span><br><span class="line">cd :    进入指定目录</span><br><span class="line">cd.. :  退回到上一级目录</span><br><span class="line">cd\:    退回到根目录</span><br><span class="line">del :    删除文件</span><br><span class="line">exit :   退出 dos 命令行</span><br><span class="line">补充：echo javase&gt;1.doc</span><br><span class="line">常用快捷键</span><br><span class="line">←   →：移动光标</span><br><span class="line">↑   ↓：调阅历史操作命令</span><br><span class="line">Delete和Backspace：删除字符</span><br></pre></td></tr></table></figure><h1 id="1-2-计算机编程语言介绍"><a href="#1-2-计算机编程语言介绍" class="headerlink" title="1-2 计算机编程语言介绍"></a>1-2 计算机编程语言介绍</h1><h2 id="什么是计算机语言"><a href="#什么是计算机语言" class="headerlink" title="什么是计算机语言"></a>什么是计算机语言</h2><ul><li>语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，就要学习英语。</li><li><p>计算机语言：人与计算机交流的方式。<br>   如果人要与计算机交流，那么就要学习计算机语言。<br>   计算机语言有很多种。如：C ,C++ ,Java ,PHP ,  Kotlin，Python，Scala等。  </p></li><li><p>第一代语言<br>机器语言。指令以二进制代码形式存在。</p></li><li>第二代语言<br>汇编语言。使用助记符表示一条机器指令。</li></ul><p><img src="https://s2.ax1x.com/2019/05/06/EDJj1J.png" alt="EDJj1J.png"></p><ul><li>第三代语言：高级语言</li></ul><blockquote><p>C、Pascal、Fortran面向过程的语言<br>C++面向过程/面向对象<br>Java跨平台的纯面向对象的语言<br>.NET跨语言的平台<br>Python、Scala…  </p></blockquote><h2 id="1-3-Java语言概述"><a href="#1-3-Java语言概述" class="headerlink" title="1-3 Java语言概述"></a>1-3 Java语言概述</h2><ul><li>是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。</li><li>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中。</li><li>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言<br>   <strong>后台开发：Java、PHP、Python、Go、Node.js</strong><h3 id="Java语言概述-Java简史"><a href="#Java语言概述-Java简史" class="headerlink" title="Java语言概述:Java简史"></a>Java语言概述:Java简史</h3><blockquote><p>1991年 Green项目，开发语言最初命名为Oak (橡树)<br>1994年，开发组意识到Oak 非常适合于互联网<br>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作<br>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最<br>1998年，发布JDK 1.2，同年发布企业平台J2EE<br>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生<br>2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0<br>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME<br>2009年，Oracle公司收购SUN，交易价格74亿美元<br>2011年，发布JDK 7.0<br>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本<br>2017年，发布JDK 9.0，最大限度实现模块化<br>2018年3月，发布JDK 10.0，版本号也称为18.3<br>2018年9月，发布JDK 11.0，版本号也称为18.9     </p></blockquote></li></ul><h3 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h3><p><img src="https://s2.ax1x.com/2019/05/06/EDYdEV.png" alt="EDYdEV.png"></p><h1 id="1-3-Java在各领域的应用"><a href="#1-3-Java在各领域的应用" class="headerlink" title="1-3 Java在各领域的应用"></a>1-3 Java在各领域的应用</h1><p>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面：</p><ul><li>企业级应用：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li><li>Android平台应用：Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。</li><li>大数据平台开发：各类框架有Hadoop，spark，storm，flink等，就这类技术生态圈来讲，还有各种中间件如flume，kafka，sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java，scala，Python，R等各种语言API供编程。</li><li>移动领域应用：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。<h3 id="Java语言的诞生"><a href="#Java语言的诞生" class="headerlink" title="Java语言的诞生"></a>Java语言的诞生</h3>java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。<br><img src="https://s2.ax1x.com/2019/05/06/EDaaM4.png" alt="EDaaM4.png"><br>Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java舍弃了C语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承（以接口取代）等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。<br>JDK1.5又引入了泛型编程（Generic Programming）、类型安全的枚举、不定长参数和自动装/拆箱<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2></li><li>Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。</li><li>Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。</li><li>Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</li><li>Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。</li><li>Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。</li><li>Java语言是体系结构中立的。Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。</li><li>Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。</li><li>Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li><li>Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。<h1 id="1-4-Java程序运行机制及运行过程"><a href="#1-4-Java程序运行机制及运行过程" class="headerlink" title="1-4 Java程序运行机制及运行过程"></a>1-4 Java程序运行机制及运行过程</h1><h2 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h2></li><li>特点一：面向对象<br>两个基本概念：类、对象<br>三大特性：封装、继承、多态  </li><li>特点二：健壮性<br>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</li><li>特点三：跨平台性<br>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”<br>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。</li></ul><p><a href="https://imgchr.com/i/EDaHW8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/06/EDaHW8.md.png" alt="EDaHW8.md.png"></a></p><h2 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h2><ul><li>Java虚拟机  (Java Virtal Machine)<br>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。<br>对于不同的平台，有不同的虚拟机。<br>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行<br>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”  </li></ul><p><img src="https://s2.ax1x.com/2019/05/06/EDaves.png" alt="EDaves.png"></p><p><img src="https://s2.ax1x.com/2019/05/06/EDdpF0.png" alt="EDdpF0.png"></p><ul><li>垃圾收集机制  (Garbage Collection)<br>不再使用的内存空间应回收—— 垃圾回收。</li></ul><blockquote><ul><li>在C/C++等语言中，由程序员负责回收无用内存。</li><li>Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。<br>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</li></ul></blockquote><p><strong>Java程序还会出现内存泄漏和内存溢出问题吗？</strong>==Yes!==</p><h1 id="1-5-Java语言的环境搭建"><a href="#1-5-Java语言的环境搭建" class="headerlink" title="1-5 Java语言的环境搭建"></a>1-5 Java语言的环境搭建</h1><h2 id="明确什么是JDK-JRE"><a href="#明确什么是JDK-JRE" class="headerlink" title="明确什么是JDK, JRE"></a>明确什么是JDK, JRE</h2><p><img src="https://s2.ax1x.com/2019/05/06/EDdVm9.png" alt="EDdVm9.png"></p><p><img src="https://s2.ax1x.com/2019/05/06/EDdnFx.png" alt="EDdnFx.png"></p><p>==简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。==</p><p><img src="https://s2.ax1x.com/2019/05/06/EDd16e.png" alt="EDd16e.png"></p><ul><li>JDK = JRE + 开发工具集（例如Javac编译工具等）</li><li>JRE = JVM + Java SE标准类库<h2 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h2>官方网址：</li><li><a href="http://www.oracle.com" target="_blank" rel="noopener">http://www.oracle.com</a></li><li><a href="http://java.sun.com" target="_blank" rel="noopener">http://java.sun.com</a></li></ul><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><ul><li>傻瓜式安装，下一步即可。</li><li>建议：安装路径不要有中文或者空格等特殊符号。</li><li>如果操作系统是64位的，软件尽量选择支持64位的（除非软件本身不区分）。</li><li>当提示安装 JRE 时，正常在JDK安装时已经装过了，但是为了后续使用Eclipse等开发工具不报错，建议也根据提示安装JRE。</li><li>安装 JDK</li></ul><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>在dos命令行中敲入javac，出现错误提示：</p><p><img src="https://s2.ax1x.com/2019/05/06/EDdaff.png" alt="EDdaff.png"></p><p>错误原因：当前执行的程序在当前目录下如果不存在，windows系统会在系统中已有的一个名为path的环境变量指定的目录中查找。如果仍未找到，会出现以上的错误提示。所以进入到  jdk安装路径\bin目录下，执行javac，会看到javac参数提示信息。</p><p><img src="https://s2.ax1x.com/2019/05/06/EDdqtx.png" alt="EDdqtx.png"></p><h2 id="配置环境变量-path"><a href="#配置环境变量-path" class="headerlink" title="配置环境变量 path"></a>配置环境变量 path</h2><ul><li>path：windows系统执行命令时要搜寻的路径。<br>每次执行 java 的工具都要进入到bin目录下，是非常麻烦的。可不可以在任何目录下都可以执行java的工具呢？<br>根据windows系统在查找可执行程序的原理，可以将java工具所在路径定义到 path 环境变量中，让系统帮我们去找运行执行的程序。<br><strong>配置方法</strong>：</li><li>我的电脑–属性–高级系统设置–环境变量</li><li>编辑 path 环境变量，在变量值开始处加上java工具所在目录，后面用 “ ; ”和其他值分隔开即可。</li><li>打开DOS命令行，任意目录下敲入javac。如果出现javac 的参数信息，配置成功。</li></ul><p>注：  具体操作流程，参看JDK8下载_安装_配置(点击跳转)</p><p><a href="https://imgchr.com/i/EDwOVs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/06/EDwOVs.md.png" alt="EDwOVs.md.png"></a></p><p>验证是否成功：javac   java</p><p><img src="https://s2.ax1x.com/2019/05/06/ED0S2T.png" alt="ED0S2T.png"></p><p><img src="https://s2.ax1x.com/2019/05/06/ED0CMF.png" alt="ED0CMF.png"></p><p>#1-6 开发体验— HelloWorld</p><ul><li>步骤：<br>1.将 Java 代码编写到扩展名为 .java 的文件中。<br>2.通过 javac 命令对该 java 文件进行编译。<br>通过 java 命令对生成的 class 文件进行运行  </li></ul><p><img src="https://s2.ax1x.com/2019/05/06/ED0Dds.png" alt="ED0Dds.png"></p><ul><li>步骤一：编写<br>选择最简单的编辑器：记事本。<br>敲入代码    class Test{  }<br>将文件保存成Test.java，这个文件是存放java代码的文件，称为源文件。</li></ul><p><img src="https://s2.ax1x.com/2019/05/06/ED06J0.png" alt="ED06J0.png"></p><h3 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">             System.out.println(“Hello World!”);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二：编译"><a href="#步骤二：编译" class="headerlink" title="步骤二：编译"></a>步骤二：编译</h3><p><img src="https://s2.ax1x.com/2019/05/06/ED0fL4.png" alt="ED0fL4.png"></p><ul><li>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。</li><li>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。</li><li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文件，也是可以执行的java的程序。<h3 id="步骤三：运行"><a href="#步骤三：运行" class="headerlink" title="步骤三：运行"></a>步骤三：运行</h3></li><li>有了可执行的java程序(Test.class字节码文件)</li><li>通过运行工具java.exe对字节码文件进行执行。</li><li>出现提示：缺少一个名称为main的方法。</li></ul><p><img src="https://s2.ax1x.com/2019/05/06/ED0LQO.png" alt="ED0LQO.png"></p><ul><li>因为一个程序的执行需要一个起始点或者入口，所以在Test类中的加入public static void main(String[] args){  }</li><li>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。</li><li>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具体执行的语句。</li><li>想要和JVM来个互动，只要在main方法中加入一句System.out.println(“Hello World”);因为程序进行改动，所以再重新编译，运行即可。<h1 id="1-7-常见问题及解决方法"><a href="#1-7-常见问题及解决方法" class="headerlink" title="1-7 常见问题及解决方法"></a>1-7 常见问题及解决方法</h1></li></ul><p><img src="https://s2.ax1x.com/2019/05/06/EDBuYq.png" alt="EDBuYq.png"></p><p>Ø源文件名不存在或者写错<br>Ø当前路径错误<br>Ø后缀名隐藏问题</p><p><img src="https://s2.ax1x.com/2019/05/06/EDBJ0J.png" alt="EDBJ0J.png"></p><p>Ø类文件名写错，尤其文件名与类名不一致时，要小心<br>Ø类文件不在当前路径下，或者不在classpath指定路径下</p><p><img src="https://s2.ax1x.com/2019/05/06/EDBgAA.png" alt="EDBgAA.png"></p><p>Ø声明为public的类应与文件名一致，否知编译失败</p><p><img src="https://s2.ax1x.com/2019/05/06/EDBh1f.png" alt="EDBh1f.png"></p><p>Ø编译失败，注意错误出现的行数，再到源代码中指定位置改错</p><h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><p>学习编程最容易犯的错是语法错误。Java要求你必须按照语法规则编写代码。如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号，或者拼错了单词，java编译器都会报语法错误。尝试着去看懂编译器会报告的错误信息。</p><h1 id="1-8-注释-Comment"><a href="#1-8-注释-Comment" class="headerlink" title="1-8 注释(Comment)"></a>1-8 注释(Comment)</h1><p>用于注解说明解释程序的文字就是注释。<br>Java中的注释类型：</p><ul><li>单行注释    格式： //注释文字</li><li>多行注释    格式：   /<em>  注释文字 </em>/</li><li><p>文档注释 (java特有)</p></li><li><p>对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。</p></li><li>多行注释里面不允许有多行注释嵌套。</li><li>格式：/**  <pre><code>@author  指定java程序的作者  @version  指定源文件的版本                        */</code></pre></li></ul><p>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。<br>提高了代码的阅读性；调试程序的重要方法。<br>注释是一个程序员必须要具有的良好编程习惯。<br>将自己的思想通过注释先整理出来，再用代码去体现</p><p><img src="https://s2.ax1x.com/2019/05/06/EDDnDe.png" alt="EDDnDe.png"></p><h2 id="小结第一个程序"><a href="#小结第一个程序" class="headerlink" title="小结第一个程序"></a>小结第一个程序</h2><ul><li>Java源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本例中的HelloWorld类。</li><li>Java应用程序的执行入口是main()方法。它有固定的书写格式：<br> public static void main(String[] args)  {…}</li><li>Java语言严格区分大小写。</li><li>Java方法由一条条语句构成，每个语句以“;”结束。</li><li>大括号都是成对出现的，缺一不可。</li><li>一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。<h1 id="1-9-Java-API文档"><a href="#1-9-Java-API文档" class="headerlink" title="1-9 Java API文档"></a>1-9 Java API文档</h1>API （Application Programming Interface,应用程序编程接口）是 Java 提供的基本编程接口。<br>Java语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。<br>下载API：<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>Additional Resources-Java SE 8 Documentation下载。  <h1 id="1-10-良好的编程风格"><a href="#1-10-良好的编程风格" class="headerlink" title="1.10 良好的编程风格"></a>1.10 良好的编程风格</h1><h2 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h2></li><li>使用文档注释来注释整个类或整个方法。</li><li>如果注释方法中的某一个步骤，使用单行或多行注释。<br>正确的缩进和空白</li><li>使用一次tab操作，实现缩进</li><li>运算符两边习惯性各加一个空格。比如：2 + 4 * 5。<br>块的风格</li><li>Java API 源代码选择了行尾风格</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">行尾风格</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Block Style!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">次行风格</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Block Style!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择合适的文本编辑器或-IDE-开发"><a href="#选择合适的文本编辑器或-IDE-开发" class="headerlink" title="选择合适的文本编辑器或 IDE 开发"></a>选择合适的文本编辑器或 IDE 开发</h1><h2 id="JBuilder"><a href="#JBuilder" class="headerlink" title="JBuilder"></a>JBuilder</h2><p>JBuilder是Borland公司开发的针对java的开发工具，使用JBuilder将可以快速，有效的开发各类java应用。 Jbuilder支持各种应用服务器。Jbuilder与Inprise Application Server紧密集成，同时支持WebLogic Server，支持EJB 1.1和EJB 2.0，可以快速开发J2EE的电子商务应用。支持远程调试和多线程调试，调试器支持各种JDK版本<br><a href="https://edn.embarcadero.com/cn/jbuilder" target="_blank" rel="noopener">https://edn.embarcadero.com/cn/jbuilder</a></p><p><img src="https://s2.ax1x.com/2019/05/06/EDDDCq.png" alt="EDDDCq.png"></p><h2 id="NetBeans"><a href="#NetBeans" class="headerlink" title="NetBeans"></a>NetBeans</h2><p>NetBeans是一款用Java编写的开源IDE。既可用于Java开发，也支持其他语言，特别是PHP、C/C ++，和HTML5。NetBeans开发环境提供了丰富的产品文档和培训资源以及大量的第三方插件。<br><a href="https://netbeans.org/features/index.html" target="_blank" rel="noopener">https://netbeans.org/features/index.html</a></p><p><img src="https://s2.ax1x.com/2019/05/06/EDDqqe.png" alt="EDDqqe.png"></p><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>Eclipse应该是大多数Java程序员使用的第一个IDE。众所周知的、最流行、也最受欢迎的Java开发工具。优点很多：免费、更新快、代码智能化、ANT构建等，拥有众多插件，完全免费、有中文版、上手比较快。缺点也非常明显，安装插件麻烦、插件对版本要求比较严格。</p><p><a href="https://eclipse.org/" target="_blank" rel="noopener">https://eclipse.org/</a></p><p><img src="https://s2.ax1x.com/2019/05/06/EDDxPI.png" alt="EDDxPI.png"></p><h2 id="MyEclipse"><a href="#MyEclipse" class="headerlink" title="MyEclipse"></a>MyEclipse</h2><p>MyEclipse也是一款功能强大的J2EE集成开发环境，由Genuitec公司发布，提供免费版和收费版。但免费版，只能满足基本开发需求<br><a href="https://www.myeclipsecn.com/" target="_blank" rel="noopener">https://www.myeclipsecn.com/</a></p><p><img src="https://s2.ax1x.com/2019/05/06/EDrPsS.png" alt="EDrPsS.png"></p><p>ØIntelliJ IDEA<br>IntelliJ IDEA被认为是目前Java开发效率最快的IDE工具。是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格。它整合了开发过程中实用的众多功能，智能提示错误，强大的调试工具，Ant，JavaEE支持，CVS整合，最大程度的加快开发的速度。简单而又功能强大。与其他的一些繁冗而复杂的IDE工具有鲜明的对比。<br><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">https://www.jetbrains.com/idea/</a></p><p><img src="https://s2.ax1x.com/2019/05/06/EDrAaj.png" alt="EDrAaj.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-1-软件开发介绍&quot;&gt;&lt;a href=&quot;#1-1-软件开发介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件开发介绍&quot;&gt;&lt;/a&gt;1.1 软件开发介绍&lt;/h1&gt;&lt;h2 id=&quot;软件开发&quot;&gt;&lt;a href=&quot;#软件开发&quot; class=&quot;head
      
    
    </summary>
    
      <category term="JavaSE基础笔记" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>微笑面对</title>
    <link href="http://yoursite.com/2016/05/06/%E5%BE%AE%E7%AC%91%E9%9D%A2%E5%AF%B9/"/>
    <id>http://yoursite.com/2016/05/06/微笑面对/</id>
    <published>2016-05-05T16:00:00.000Z</published>
    <updated>2019-06-04T07:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活中难免遇到许多我们无法预测的事<br>有的人选择逃避<br>有的人选择面对<br>二种选择都充满苦涩<br>请把苦涩与泪水留给夜里的自己<br>他催促我们成长</p><hr><p>第一篇博客不谈工作</p><p>date: 2016-05-06 21:32:20</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生活中难免遇到许多我们无法预测的事&lt;br&gt;有的人选择逃避&lt;br&gt;有的人选择面对&lt;br&gt;二种选择都充满苦涩&lt;br&gt;请把苦涩与泪水留给夜里的自己&lt;br&gt;他催促我们成长&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第一篇博客不谈工作&lt;/p&gt;
&lt;p&gt;date: 2016-05-06 21:32:20&lt;
      
    
    </summary>
    
      <category term="心情瞬间" scheme="http://yoursite.com/categories/%E5%BF%83%E6%83%85%E7%9E%AC%E9%97%B4/"/>
    
    
      <category term="人生感悟" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SomnambulistOfChina</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-06T15:09:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SomnambulistOfChina</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>13 web-Listener(监听器)</title>
    <link href="http://yoursite.com/2017/12/01/32%20web-Listener(%E7%9B%91%E5%90%AC%E5%99%A8)/"/>
    <id>http://yoursite.com/2017/12/01/32 web-Listener(监听器)/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2019-06-06T15:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Listener用于监听JavaWeb程序中的事件。</li><li>例如：ServletContext、HttpSession、ServletRequest的创建、修改和删除。</li><li>Listener和我们之前学习的JS中的事件处理机制类似。在JS中，当我们触发某个事件后（例如：点击一个按钮）程序会调用一个响应函数来处理事件。同样的，在JavaWeb中，我们可以为某些事件来设置监听器，当事件被触发时，监听器中的指定方法将会被调用。</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><ul><li>Listener的原理是基于观察者模式的，所谓观察者模式简单来说，就是当被观察者的特定事件被触发（一般这某些方法被调用）后，会通知观察者（调用观察者的方法），观察者可以在自己的方法中来对事件做一些处理。</li><li>在我们的JavaWeb中，观察者就是Listener，而被观察者可能有三个ServletContext、HttpSession、ServletRequest。而事件指的就是这些对象的创建、修改和删除等。</li></ul><h1 id="监听器的分类"><a href="#监听器的分类" class="headerlink" title="监听器的分类"></a>监听器的分类</h1><h2 id="1-监听对象的创建与销毁"><a href="#1-监听对象的创建与销毁" class="headerlink" title="1.    监听对象的创建与销毁"></a>1.    监听对象的创建与销毁</h2><h3 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：监听ServletContext对象的创建与销毁</span><br><span class="line">方法：</span><br><span class="line">public void contextInitialized ( ServletContextEvent sce );</span><br><span class="line">    ServletContext创建时调用</span><br><span class="line">public void contextDestroyed ( ServletContextEvent sce );</span><br><span class="line">    ServletContext销毁时调用</span><br><span class="line">ServletContextEvent对象</span><br><span class="line">    作用：public ServletContext getServletContext ()</span><br><span class="line">    获取ServletContext对象</span><br></pre></td></tr></table></figure><h3 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：监听HttpSession对象的创建与销毁</span><br><span class="line">方法：</span><br><span class="line">public void sessionCreated ( HttpSessionEvent se );</span><br><span class="line">    HttpSession对象创建时调用</span><br><span class="line">public void sessionDestroyed ( HttpSessionEvent se );</span><br><span class="line">    HttpSession对象销毁时调用</span><br><span class="line">HttpSessionEvent对象</span><br><span class="line">作用：public HttpSession getSession ()</span><br><span class="line">获取当前HttpSession对象</span><br></pre></td></tr></table></figure><h3 id="ServletRequestListener"><a href="#ServletRequestListener" class="headerlink" title="ServletRequestListener"></a>ServletRequestListener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">作用：监听ServletRequest对象的创建与销毁</span><br><span class="line">方法：</span><br><span class="line">public void requestInitialized ( ServletRequestEvent sre );</span><br><span class="line">    ServletRequest对象创建时调用</span><br><span class="line">public void requestDestroyed ( ServletRequestEvent sre );</span><br><span class="line">    ServletRequest对象销毁时调用</span><br><span class="line">ServletRequestEvent对象</span><br><span class="line">作用：</span><br><span class="line">    public ServletRequest getServletRequest ();</span><br><span class="line">        获取当前的ServletRequest对象。</span><br><span class="line">    public ServletContext getServletContext ();</span><br><span class="line">        获取当前项目的ServletContext对象。</span><br></pre></td></tr></table></figure><h4 id="创建与销毁监听器的使用："><a href="#创建与销毁监听器的使用：" class="headerlink" title="创建与销毁监听器的使用："></a>创建与销毁监听器的使用：</h4><ul><li>三种创建与销毁的监听器使用起来基本一致。</li><li>下边来编写一个ServletContext的监听器：<blockquote><ul><li>步骤：</li><li>创建一个类实现ServletContextListener</li></ul></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyServletContextListener implements ServletContextListener &#123;</span><br><span class="line">@Override</span><br><span class="line">public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">System.out.println(&quot;哈哈，我是ServletContext，我出生了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">System.out.println(&quot;~~~~(&gt;_&lt;)~~~~，我是ServletContext，我要死了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>在web.xml文件中注册监听器</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;com.atguigu.web.listener.MyServletContextListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><ul><li>由于ServletContext对象在服务器启动时创建，停止时销毁。所以启动服务器时我们会发现contextInitialized()方法被调用，服务器停止时contextDestroyed()方法被调用。<br>ν    其他两个监听器和该监听器使用方法一样，不再多说。</li></ul><h2 id="2-监听对象的属性变化"><a href="#2-监听对象的属性变化" class="headerlink" title="2. 监听对象的属性变化"></a>2. 监听对象的属性变化</h2><h4 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">作用：监听ServletContext中属性的创建、修改和销毁</span><br><span class="line">方法：</span><br><span class="line">public void attributeAdded(ServletContextAttributeEvent scab);</span><br><span class="line">    向ServletContext中添加属性时调用</span><br><span class="line">public void attributeRemoved(ServletContextAttributeEvent scab);</span><br><span class="line">    从ServletContext中移除属性时调用</span><br><span class="line">public void attributeReplaced(ServletContextAttributeEvent scab);</span><br><span class="line">    当ServletContext中的属性被修改时调用</span><br><span class="line"></span><br><span class="line">ServletContextAttributeEvent对象</span><br><span class="line">    作用：</span><br><span class="line">    public String getName() </span><br><span class="line">         获取修改或添加的属性名</span><br><span class="line">    public Object getValue()</span><br><span class="line">        获取被修改或添加的属性值</span><br><span class="line">    public ServletContext getServletContext ()</span><br><span class="line">        获取当前WEB应用的ServletContext对象</span><br></pre></td></tr></table></figure><h4 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">作用：监听HttpSession中属性的创建、修改和销毁</span><br><span class="line">方法：</span><br><span class="line">public void attributeAdded ( HttpSessionBindingEvent se );</span><br><span class="line">    向HttpSession中添加属性时调用</span><br><span class="line">public void attributeRemoved(HttpSessionBindingEvent se);</span><br><span class="line">    从HttpSession中移除属性时调用</span><br><span class="line">public void attributeReplaced(HttpSessionBindingEvent se);</span><br><span class="line">    当HttpSession中的属性被修改时调用</span><br><span class="line">    </span><br><span class="line">    HttpSessionBindingEvent对象</span><br><span class="line">        作用：</span><br><span class="line">        public String getName() </span><br><span class="line">            获取修改或添加的属性名</span><br><span class="line">        public Object getValue()</span><br><span class="line">            获取被修改或添加的属性值</span><br><span class="line">        public HttpSession getSession ()</span><br><span class="line">            获取当前的HttpSession对象</span><br></pre></td></tr></table></figure><h4 id="ServletRequestAttributeListener"><a href="#ServletRequestAttributeListener" class="headerlink" title="ServletRequestAttributeListener"></a>ServletRequestAttributeListener</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">作用：监听ServletRequest中属性的创建、修改和销毁</span><br><span class="line">方法：</span><br><span class="line">public void attributeAdded (ServletRequestAttributeEvent srae );</span><br><span class="line">    向ServletRequest中添加属性时调用</span><br><span class="line">public void attributeRemoved(ServletRequestAttributeEvent srae);</span><br><span class="line">    从ServletRequest中移除属性时调用</span><br><span class="line">public void attributeReplaced(ServletRequestAttributeEvent srae);</span><br><span class="line">    当ServletRequest中的属性被修改时调用</span><br><span class="line"></span><br><span class="line">ServletRequestAttributeEvent对象</span><br><span class="line">作用：</span><br><span class="line">    public String getName() </span><br><span class="line">        获取修改或添加的属性名</span><br><span class="line">    public Object getValue()</span><br><span class="line">        获取被修改或添加的属性值</span><br><span class="line">    public ServletRequest getServletRequest () </span><br><span class="line">        获取当前的ServletRequest对象</span><br></pre></td></tr></table></figure><h3 id="对象属性变化监听器的使用："><a href="#对象属性变化监听器的使用：" class="headerlink" title="对象属性变化监听器的使用："></a>对象属性变化监听器的使用：</h3><ul><li>同样三种对象属性变化监听器使用方式类似，下边以request属性监听器为例。<ul><li>创建一个类实现ServletRequestAttributeListener接口</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ReqAttrListener implements ServletRequestAttributeListener &#123;</span><br><span class="line">@Override</span><br><span class="line">public void attributeAdded(ServletRequestAttributeEvent srae) &#123;</span><br><span class="line">System.out.println(&quot;request域中添加一个属性&quot;+srae.getName()+&quot;=&quot;+srae.getValue());</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void attributeRemoved(ServletRequestAttributeEvent srae) &#123;</span><br><span class="line">System.out.println(&quot;request域中移除一个属性&quot;+srae.getName()+&quot;=&quot;+srae.getValue());</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void attributeReplaced(ServletRequestAttributeEvent srae) &#123;</span><br><span class="line">System.out.println(&quot;request域中一个属性被修改了&quot;+srae.getName()+&quot;=&quot;+srae.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在web.xml文件中注册监听器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;com.atguigu.web.listener.ReqAttrListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><ul><li>如此当我们操作request域中的属性时，对应方法将会被调用。</li></ul><h2 id="3-监听Session内的对象"><a href="#3-监听Session内的对象" class="headerlink" title="3. 监听Session内的对象"></a>3. 监听Session内的对象</h2><h3 id="HttpSessionBindingListener"><a href="#HttpSessionBindingListener" class="headerlink" title="HttpSessionBindingListener"></a>HttpSessionBindingListener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">作用：监听某个对象在session域中的创建与移除。</span><br><span class="line">方法：</span><br><span class="line">public void valueBound(HttpSessionBindingEvent event)</span><br><span class="line">    该类的实例被放到Session域中时调用</span><br><span class="line">public void valueUnbound(HttpSessionBindingEvent event)</span><br><span class="line">    该类的实例从Session中移除时调用</span><br><span class="line">HttpSessionBindingEvent对象</span><br><span class="line">作用：</span><br><span class="line">public HttpSession getSession ()</span><br><span class="line">    获取HttpSession对象</span><br><span class="line">public String getName()</span><br><span class="line">    获取操作的属性名</span><br><span class="line">public Object getValue()</span><br><span class="line">    获取操作的属性值</span><br></pre></td></tr></table></figure><ul><li>使用：要监听哪一个类，直接使该类实现HttpSessionB</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indingListener接口即可。</span><br><span class="line">public class Student implements HttpSessionBindingListener &#123;</span><br><span class="line">@Override</span><br><span class="line">public void valueBound(HttpSessionBindingEvent event) &#123;</span><br><span class="line">//doSomeThing</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void valueUnbound(HttpSessionBindingEvent event) &#123;</span><br><span class="line">//doSomeThing</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a>HttpSessionActivationListener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作用：监听某个对象在session中的序列化与反序列化。</span><br><span class="line">方法：</span><br><span class="line">public void sessionWillPassivate(HttpSessionEvent se)</span><br><span class="line">    该类实例和Session一起钝化到硬盘时调用</span><br><span class="line">public void sessionDidActivate(HttpSessionEvent se)</span><br><span class="line">    该类实例和Session一起活化到内存时调用</span><br><span class="line">HttpSessionEvent对象</span><br><span class="line">作用：</span><br><span class="line">public HttpSession getSession ()</span><br><span class="line">    获取HttpSession对象</span><br></pre></td></tr></table></figure><ul><li>使用：要监听哪一个类，直接使该类实现HttpSessionActivationListener接口即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements HttpSessionActivationListener , Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">@Override</span><br><span class="line">public void sessionWillPassivate(HttpSessionEvent se) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void sessionDidActivate(HttpSessionEvent se) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：这里为了是Student对象可以正常序列化到硬盘上，还需要让类实现java.io.Serializable接口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Listener用于监听JavaWeb程序中的事件。&lt;/li&gt;
&lt;li&gt;例如：ServletContext、HttpSessio
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>12 web-Filter(过滤器)</title>
    <link href="http://yoursite.com/2017/11/28/31%20web-Filter(%E8%BF%87%E6%BB%A4%E5%99%A8)/"/>
    <id>http://yoursite.com/2017/11/28/31 web-Filter(过滤器)/</id>
    <published>2017-11-27T16:00:00.000Z</published>
    <updated>2019-06-06T15:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Filter简介"><a href="#Filter简介" class="headerlink" title="Filter简介"></a>Filter简介</h1><ul><li>Filter中文意思为过滤器。顾名思义，过滤器可在浏览器以及目标资源之间起到一个过滤的作用。例如：水净化器，可以看成是生活中的一个过滤器，他可以将污水中的杂质过滤，从而使进入的污水变成净水。</li><li>对于WEB应用来说，过滤器是一个驻留在服务器中的WEB组件，他可以截取客户端和WEB资源之间的请求和响应信息。</li><li>WEB资源可能包括Servlet、JSP、HTML页面等</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606152116.png" alt></p><ul><li>当服务器收到特定的请求后，会先将请求交给过滤器，程序员可以在过滤器中对请求信息进行读取修改等操作，然后将请求信息再发送给目标资源。目标资源作出响应后，服务器会再次将响应转交给过滤器，在过滤器中同样可以对响应信息做一些操作，然后再将响应发送给服务器。</li><li>也就是说过滤器可以在WEB资源收到请求之前，浏览器收到响应之前，对请求和响应信息做一些相应的操作。</li><li>在一个WEB应用中可以部署多个过滤器，多个过滤器就组成了一个过滤器链，请求和响应必须在经过多个过滤器后才能到达目标；</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606152327.png" alt></p><ul><li>过滤器不是必须将请求传送到下一个过滤器（或WEB资源），也可以自己来处理请求，发送响应。</li></ul><h1 id="Filter相关接口"><a href="#Filter相关接口" class="headerlink" title="Filter相关接口"></a>Filter相关接口</h1><ul><li>编写Filter和编写Servlet类似，都需要实现接口。</li><li>编写Filter需要实现Filter接口，我们来看一下Filter接口的主要方法：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606152426.png" alt></p><ul><li>Filter接口，实现Filter需要实现该接口</li></ul><ol><li>init()方法用于初始化Filter  </li><li>doFilter()作用和service()方法类似，是过滤请求和响应的主要方法。  </li><li>destroy()用于在Filter对象被销毁前做一些收尾工作。如：释放资源等。  </li></ol><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606152507.png" alt></p><ul><li>FilterConfig对象在服务器调用init()方法时传递进来。</li></ul><ol><li>getFilterName() 获取Filter的名字  </li><li>getServletContext() 获取ServletContext对象（即application）</li><li>getInitParameter() 获取Filter的初始化参数  </li><li>getInitParameterNames() 获取所有初始化参数的名字</li></ol><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606152559.png" alt></p><ul><li>FilterChain对象是在doFilter()方法被调用时作为参数传递进来的。</li></ul><ol><li>doFilter()方法用于调用Filter链上的下一个过滤器，如果当前过滤器为最后一个过滤器则将请求发送到目标资源。</li></ol><h1 id="创建Filter"><a href="#创建Filter" class="headerlink" title="创建Filter"></a>创建Filter</h1><h2 id="1-实现Filter接口"><a href="#1-实现Filter接口" class="headerlink" title="1    实现Filter接口"></a>1    实现Filter接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HelloFilter implements Filter &#123;</span><br><span class="line">@Override</span><br><span class="line">public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">System.out.println(&quot;Hello Filter&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-在web-xml注册Filter"><a href="#2-在web-xml注册Filter" class="headerlink" title="2    在web.xml注册Filter"></a>2    在web.xml注册Filter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   &lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;HelloFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;com.atguigu.web.filter.HelloFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;HelloFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/index.html&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><ul><li>我们编写的这个Filter用来过滤发送到index.html的请求。</li><li>在doFilter()方法中我们只写了一个打印语句，并没有将请求转交给目标资源处理。</li><li>所以这个过滤器的效果是我们将不能正常查看到index.html页面，在访问index.html时页面上将会是一片空白。同时，控制台将输出Hello Filter。</li><li>如果想要index.html正确显示，需要在输出语句后，调用一个chain.doFilter(request, response)将请求放行。</li><li>Filter的配置文件和Servlet的配置文件类似</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter-name 指定的是过滤器的名字</span><br><span class="line">filter-class 指定的是过滤器的全类名</span><br><span class="line">url-pattern 指定的是需要过滤器处理的请求地址</span><br></pre></td></tr></table></figure><ul><li>除此之外在filter-mapping还有一个子标签dispatcher，该标签用来指定需要Filter处理的请求类型，该标签可以配置四个值：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;</span><br><span class="line">用户直接访问资源时，会调用Filter</span><br><span class="line">&lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;</span><br><span class="line">通过转发访问时，会调用Filter</span><br><span class="line">&lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;</span><br><span class="line">通过动态包含获取时，会调用Filter</span><br><span class="line">&lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;</span><br><span class="line">当通过异常处理访问页面时，会调用Filter</span><br></pre></td></tr></table></figure><ul><li>这四种情况可以设置一个，也可以同时设置多个，如果不设置那么默认为REQUEST。</li></ul><h2 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h2><p>Filter的生命周期和Servlet类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造器：创建Filter实例是调用，Filter实例服务器一旦启动就会被创建</span><br><span class="line"></span><br><span class="line">init()：实例创建后马上被调用，用来对Filter做一些初始化的操作</span><br><span class="line"></span><br><span class="line">doFilter()：Filter的主要方法，用来完成过滤器主要功能的方法，每次访问目标资源时都会调用。</span><br><span class="line"></span><br><span class="line">destroy()：服务器停止时调用，用来释放资源。</span><br></pre></td></tr></table></figure><h2 id="Filter的目标资源"><a href="#Filter的目标资源" class="headerlink" title="Filter的目标资源"></a>Filter的目标资源</h2><p> Filter的目标资源指的是需要调用Filter来进行过滤处理的资源，例如上文我们配置的/index.html就是我们的目标资源，当我们访问项目根目录下的index.html时就会调用HelloFilter来进行过滤。</p><ul><li>目标资源的配置方式主要有两种：<ul><li>第一种：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1通过filter-mapping的url-pattern来配置</span><br><span class="line">这里的配置和Servlet的url-pattern的规则相同</span><br><span class="line">    精确匹配：/路径/资源名。</span><br><span class="line">        如：/index.html 、/hello/index.jsp 、 /client/LoginServlet</span><br><span class="line">        精确匹配只要在请求地址完全一样时才会调用Filter</span><br><span class="line">    路径匹配：/路径名/*</span><br><span class="line">        如：/hello/* 、/*</span><br><span class="line">        路径匹配只要是所请求的资源是在设置的路径下就会调用Filter</span><br><span class="line">            如：/hello/* 只要访问 项目根目录/hello/ 下的任意资源就会调用Filter</span><br><span class="line">            如: /* 只要访问 项目根目录下的资源就会调用Filter</span><br><span class="line">    后缀匹配：*.后缀名</span><br><span class="line">        如：*.jsp 、 *.html</span><br><span class="line">        后缀匹配只要访问的资源路径是以指定后缀结尾就会调用Filter</span><br></pre></td></tr></table></figure><ul><li>第二种<ul><li>通过filter-mapping中的servlet-name来指定要过滤的Servlet</li><li>如：以下是一个项目中的web.xml配置文件，在项目中有一个Filter加做HelloFilter，一个Servlet叫做HelloServlet。在Filter的filter-mapping中增加了一个servlet-name标签，将该标签的值设置成Servlet的名字，在访问Servlet时就会调用该过滤器过滤请求。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;HelloFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.atguigu.web.filter.HelloFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;HelloFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.atguigu.web.servlet.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h1 id="Filter的执行顺序"><a href="#Filter的执行顺序" class="headerlink" title="Filter的执行顺序"></a>Filter的执行顺序</h1><ul><li>我们可以为一个资源配置多个Filter，当配置多个Filter以后就有一个执行顺序的问题，实际执行顺序是按照在web.xml文件中servlet-mapping的顺序决定的，如果顺序越靠前越先被调用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Filter简介&quot;&gt;&lt;a href=&quot;#Filter简介&quot; class=&quot;headerlink&quot; title=&quot;Filter简介&quot;&gt;&lt;/a&gt;Filter简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Filter中文意思为过滤器。顾名思义，过滤器可在浏览器以及目标资源之间起到一个
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>11 web-会话控制-Cookie</title>
    <link href="http://yoursite.com/2017/11/21/30%20web-%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6-Cookie/"/>
    <id>http://yoursite.com/2017/11/21/30 web-会话控制-Cookie/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2019-06-06T15:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h2><ul><li>    HTTP是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分中两次请求是否由一个客户端发出。这样的设计严重阻碍的Web程序的设计。如：在我们进行网购时，买了一条裤子，又买了一个手机。由于http协议是无状态的，如果不通过其他手段，服务器是不能知道用户到底买了什么。而Cookie就是解决方案之一。</li><li>    Cookie实际上就是服务器保存在浏览器上的一段信息。浏览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求。</li><li>    例如：我们上文说的网上商城，当用户向购物车中添加一个商品时，服务器会将这个条信息封装成一个Cookie发送给浏览器，浏览器收到Cookie，会将它保存在内存中(注意这里的内存是本机内存，而不是服务器内存)，那之后每次向服务器发送请求，浏览器都会携带该Cookie，而服务器就可以通过读取Cookie来判断用户到底买了哪些商品。当用户进行结账操作时，服务器就可以根据Cookie的信息来做结算。</li><li>Cookie的用途：<ul><li style="list-style: none"><input type="checkbox" checked>     网上商城的购物车</li><li style="list-style: none"><input type="checkbox" checked>     保持用户登录状态</li><li style="list-style: none"><input type="checkbox" checked>     163邮箱的7天免登陆</li></ul></li><li><p>    Cookie的原理：  </p><blockquote><p>总的来看Cookie像是服务器发给浏览器的一张“会员卡”，浏览器每次向服务器发送请求时都会带着这张“会员卡”，当服务器看到这张“会员卡”时就可以识别浏览器的身份。</p></blockquote><blockquote><p>   实际上这个所谓的“会员卡”就是服务器发送的一个响应头：</p><blockquote><ul><li>Set-Cookie这个响应头就是服务器在向服务器发“会员卡”，这个响应头的名字是Set-Cookie，后边JSESSIONID=95A92EC1D7CCB4ADFC24584CB316382E和Path=/Test_cookie，是两组键值对的结构就是服务器为这个“会员卡”设置的信息。浏览器收到该信息后就会将它保存到内存或硬盘中。    </li><li>当浏览器再次向服务器发送请求时就会携带这个Cookie信息：  </li><li>这是浏览器发送的请求报文，中间画红框的就是Cookie信息，这里可以理解为浏览器这次带着“会员卡”再次访问服务器。<br>-于是服务器就可以根据Cookie信息来判断浏览器的状态。  </li></ul></blockquote></blockquote></li><li>Cookie的缺点<blockquote><ul><li>Cookie最为请求或响应报文发送，无形中增加了网络流量。</li><li>Cookie是明文传送的安全性差。  </li><li>各个浏览器对Cookie有限制，使用上有局限  </li></ul></blockquote><h1 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h1></li><li>使用Cookie主要是先创建Cookie对象，然后将Cookie信息发送给浏览器，浏览器收到Cookie后会自动保存，然后我们可以在下次浏览器发送请求时读取Cookie信息。  <h2 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h2></li></ul><ol><li>创建一个CookieServlet  </li><li>在Servlet的doPost()方法中编写如下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Cookie对象Cookie cookie = new Cookie(&quot;username&quot;, &quot;zhangsan&quot;);//将Cookie对象放入response对象中response.addCookie(cookie);</span><br></pre></td></tr></table></figure><ol start="3"><li>在浏览器中访问该Servlet，会发现响应头中出现如下内容：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: username=zhangsan</span><br></pre></td></tr></table></figure><ol start="4"><li>如此就成功的向浏览器设置了一个Cookie，当我们在刷新页面时会发现浏览器的请求头中出现如下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: username=zhangsan</span><br></pre></td></tr></table></figure><ol start="5"><li>同样我们还可以同时设置多个Cookie：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Cookie对象Cookie cookie1 = new</span><br><span class="line">Cookie(&quot;username&quot;, &quot;zhangsan&quot;);Cookie cookie2 = newCookie(&quot;password&quot;, &quot;123456&quot;);</span><br><span class="line">Cookie cookie3 = new Cookie(&quot;age&quot;, &quot;20&quot;);</span><br><span class="line">//将Cookie对象放入response对象中</span><br><span class="line">response.addCookie(cookie1);</span><br><span class="line">response.addCookie(cookie2);</span><br><span class="line">response.addCookie(cookie3);</span><br></pre></td></tr></table></figure><ol start="6"><li>浏览器会以一下形式发送Cookie：  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie: username=zhangsan;</span><br><span class="line">password=123456;</span><br><span class="line">age=20</span><br></pre></td></tr></table></figure><ol start="8"><li>总之，设置Cookie就是两个步骤：</li></ol><ul><li>创建Cookie对象</li><li>将Cookie对象加入到response中</li></ul><h2 id="读取Cookie"><a href="#读取Cookie" class="headerlink" title="读取Cookie"></a>读取Cookie</h2><ul><li>读取Cookie主要指从读取浏览器中携带的Cookie</li><li>只需要通过一个方法就可以得到浏览器中的Cookie，在Servlet或JSP中通过request对象调用getCookies()方法可以获得浏览器传送过来的所有Cookie对象，返回的是一个Cookie数组，通过遍历Cookie数组可以获得所有的Cookie信息。</li><li>如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//通过request的getCookies()方法获的Cookie数组</span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">//判断数组是否为空</span><br><span class="line">if(cookies != null)&#123;</span><br><span class="line">//如果不为空遍历数组</span><br><span class="line">for(Cookie cookie : cookies)&#123;</span><br><span class="line">//获取cookie的名字</span><br><span class="line">String name = cookie.getName();</span><br><span class="line">//获取cookie的键</span><br><span class="line">String value = cookie.getValue();</span><br><span class="line">System.out.println(name+&quot;---&quot;+value);    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="Cookie有效时间"><a href="#Cookie有效时间" class="headerlink" title="Cookie有效时间"></a>Cookie有效时间</h2><ul><li>经过上边的介绍我们已经知道Cookie是存储在浏览器中的，但是可想而知一般情况下浏览器不可能永远保存一个Cookie，一来是占用硬盘空间，再来一个Cookie可能只在某一时刻有用没必要长久保存。</li><li>所以我们还需要为Cookie设置一个有效时间。</li><li>通过Cookie对象的setMaxAge()可以设置Cookie的有效时间。</li><li>其中setMaxAge()接收一个int型的参数，来设置有效时间。参数主要有一下四种情况：<ul><li>设置为0，setMaxAge(0)<ul><li>Cookie立即失效，下次浏览器发送请求将不会在携带该Cookie</li></ul></li><li>设置大于0，setMaxAge(60)<ul><li>表示有效的秒数60就代表60秒即1分钟，也就是Cookie在1分钟后失效。</li></ul></li><li>设置小于0，setMaxAge(-1)<ul><li>设置为负数表示当前会话有效。也就是关闭浏览器后Cookie失效</li></ul></li><li>不设置<ul><li>如果不设置失效时间，则默认当前会话有效。</li></ul></li></ul></li></ul><h2 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h2><ul><li>Cookie的路径指告诉浏览器访问那些地址时该携带该Cookie，我们知道浏览器会保存很多不同网站的Cookie，比如百度的Cookie，新浪的Cookie，腾讯的Cookie等等。那我们不可能访问百度的时候携带新浪的Cookie，也不可能访问每个网站时都带上所有的Cookie这是不现实的，所以往往我们还需要为Cookie设置一个Path属性，来告诉浏览器何时携带该Cookie。</li><li>我们同过Cookie的setPath()来设置路径，这个路径是由浏览器来解析的所以/代表服务器的根目录。</li><li>如：<ul><li>设置为 /项目名/路径 à cookie.setPath(“/项目名/路径”)<ul><li>这样设置只有访问“/项目名/路径”下的的资源才会携带Cookie</li><li>如：/项目名/路径/1.jsp 、/项目名/路径/hello/2.jsp 等</li></ul></li><li>如果不设置，默认会在访问“/项目名”下的资源时携带<ul><li>如：“/项目名/index.jsp” 、 “/项目名/hello/index.jsp”</li></ul></li></ul></li></ul><h1 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h1><ul><li>使用Cookie有一个非常大的局限，就是如果Cookie很多，则无形的增加了客户端与服务端的数据传输量。而且由于浏览器对Cookie数量的限制，注定我们不能再Cookie中保存过多的信息，于是Session出现。</li><li>Session的作用就是在服务器端保存一些用户的数据，然后传递给用户一个名字为JSESSIONID的Cookie，这个JESSIONID对应这个服务器中的一个Session对象，通过它就可以获取到保存用户信息的Session。</li></ul><h2 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h2><ul><li>Session的创建<ul><li>Session的创建时机是在request.getSession()方法第一次被调用时。</li><li>Session被创建后，同时还会有一个名为JSESSIONID的Cookie被创建。</li><li>这个Cookie的默认时效就是当前会话。</li></ul></li><li>Session的使用<ul><li>Session被创建后，对应的Cookie被保存到浏览器中，之后浏览器每次访问项目时都会携带该Cookie。</li><li>当我们再次调用时会根据该JSESSIONID获取已经存在的Cookie，而不是在创建一个新的Cookie。</li><li>如果Cookie中有JSESSIONID，但是JSESSIONID没有对应的Session存在，则会重新创建一个HttpSession对象，并重新设置JSESSIONID。</li></ul></li></ul><h2 id="Session时效"><a href="#Session时效" class="headerlink" title="Session时效"></a>Session时效</h2><p><strong>基本原则</strong>  </p><blockquote><p>Session对象在服务器端不能长期保存，它是有时间限制的，超过一定时间没有被访问过的Session对象就应该释放掉，以节约内存。所以Session的有效时间并不是从创建对象开始计时，到指定时间后释放——而是从最后一次被访问开始计时，统计其“空闲”的时间。<br><strong>默认设置</strong><br>在全局web.xml中能够找到如下配置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ==================== Default Session Configuration ================= --&gt; </span><br><span class="line">&lt;!-- You can set the default session timeout (in minutes) for all newly   --&gt;  </span><br><span class="line">&lt;!-- created sessions by modifying the value below.                       --&gt;    </span><br><span class="line">&lt;session-config&gt;       </span><br><span class="line">&lt;session-timeout&gt;30&lt;/session-timeout&gt;   </span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure><p>说明Session对象默认的最长有效时间为30分钟。</p><ul><li>手工设置<ul><li>session.setMaxInactiveInterval(int seconds)</li><li>session.getMaxInactiveInterval()</li></ul></li></ul><ul><li>强制失效<ul><li>session.invalidate()</li></ul></li></ul><ul><li>可以使Session对象释放的情况<ul><li>Session对象空闲时间达到了目标设置的最大值，自动释放</li><li>Session对象被强制失效</li><li>Web应用卸载</li><li>服务器进程停止</li></ul></li></ul><h2 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h2><ul><li>在整个会话控制技术体系中，保持JSESSIONID的值主要通过Cookie实现。但Cookie在浏览器端可能会被禁用，所以我们还需要一些备用的技术手段，例如：URL重写。</li><li>URL重写其实就是将JSESSIONID的值以固定格式附着在URL地址后面，以实现保持JSESSIONID，进而保持会话状态。这个固定格式是：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL;jsessionid=xxxxxxxxx</span><br></pre></td></tr></table></figure><ul><li>例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetServlet;jsessionid=F9C893D3E77E3E8329FF6BD9B7A09957</span><br></pre></td></tr></table></figure><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><ul><li>response.encodeURL(String)</li><li>response.encodeRedirectURL(String)</li><li>例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1.获取Session对象</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">//2.创建目标URL地址字符串</span><br><span class="line">String url = &quot;targetServlet&quot;;</span><br><span class="line">//3.在目标URL地址字符串后面附加JSESSIONID的值</span><br><span class="line">url = response.encodeURL(url);</span><br><span class="line">//4.重定向到目标资源</span><br><span class="line">response.sendRedirect(url);</span><br></pre></td></tr></table></figure><h2 id="Session的活化和钝化"><a href="#Session的活化和钝化" class="headerlink" title="Session的活化和钝化"></a>Session的活化和钝化</h2><ul><li>Session机制很好的解决了Cookie的不足，但是当访问应用的用户很多时，服务器上就会创建非常多的Session对象，如果不对这些Session对象进行处理，那么在Session失效之前，这些Session一直都会在服务器的内存中存在。那么就，就出现了Session活化和钝化的机制。</li><li>Session钝化：Session在一段时间内没有被使用时，会将当前存在的Session对象序列化到磁盘上，而不再占用内存空间。</li><li>Session活化：Session被钝化后，服务器再次调用Session对象时，将Session对象由磁盘中加载到内存中使用。</li><li>如果希望Session域中的对象也能够随Session钝化过程一起序列化到磁盘上，则对象的实现类也必须实现java.io.Serializable接口。不仅如此，如果对象中还包含其他对象的引用，则被关联的对象也必须支持序列化，否则会抛出异常：java.io.NotSerializableException</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h1&gt;&lt;h2 id=&quot;Cookie简介&quot;&gt;&lt;a href=&quot;#Cookie简介&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>10 web-JSTL概述</title>
    <link href="http://yoursite.com/2017/11/15/29%20web-JSTL%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/11/15/29 web-JSTL概述/</id>
    <published>2017-11-14T16:00:00.000Z</published>
    <updated>2019-06-06T15:08:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSTL简介"><a href="#JSTL简介" class="headerlink" title="JSTL简介"></a>JSTL简介</h1><ul><li>JSP虽然为我们提供了EL表达式用来替代JSP表达式，但是由于EL表达式仅仅具有输出功能，而不替代页面中的JSP脚本片段。</li><li>为了解决这个问题，JSP为我们提供了可以自定义标签库(Tag Library)的功能。</li><li>所谓自定义标签库就是指可以在JSP页面中以类似于HTML标签的形式调用Java中的方法。使用方法和我们JSP动作标签类似。</li><li>而为了方便开发使用Sun公司又定义了一套通用的标签库名为JSTL(JSP Standard Tag Library)，里面定义很多我们开发中常用的方法，方便我们使用。</li><li>JSTL的标准由Sun公司定制，Apache的Jakarta小组负责实现。</li><li>JSTL由5个不同功能的标签库组成。</li></ul><h2 id="使用JSTL"><a href="#使用JSTL" class="headerlink" title="使用JSTL"></a>使用JSTL</h2><ul><li>使用JSTL必须在项目中导入两个jar包<ul><li>taglibs-standard-impl-1.2.1.jar</li><li>taglibs-standard-spec-1.2.5.jar</li></ul></li></ul><ul><li>然后还需要在JSP页面中通过taglib指令引入标签库。<ul><li>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</li><li>prefix用来指定前缀名，我们通过该名来使用JSTL</li><li>uri相当于库的唯一标识，因为JSTL由多个不同的库组成，使用该属性指定要导入哪个库。</li></ul></li><li>使用JSTL<ul><li>&lt;c:out value=”hello”&gt;&lt;/c:out&gt;</li><li>这个例子标识，调用前缀为c的标签的out方法，向页面中输出value属性中的字符串。</li><li>JSTL的使用非常像html标签。</li></ul></li></ul><h1 id="标签库"><a href="#标签库" class="headerlink" title="标签库"></a>标签库</h1><p>JSTL由五个不同功能的标签库组成。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606115859.png" alt></p><h2 id="核心标签-Core-Tags"><a href="#核心标签-Core-Tags" class="headerlink" title="核心标签(Core Tags)"></a>核心标签(Core Tags)</h2><ul><li>Core标签库，包括了我们最常用的标签。</li><li>要使用Core标签库需要在JSP页面中加入：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-out-gt"><a href="#lt-c-out-gt" class="headerlink" title="&lt;c:out&gt;"></a>&lt;c:out&gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:out&gt;用于计算一个表达式并将结果输出到当前页面。</span><br><span class="line"></span><br><span class="line">功能类似于JSP表达式&lt;%= &gt;和EL表达式$&#123;&#125;</span><br><span class="line"></span><br><span class="line">可以设置的属性</span><br><span class="line">    value</span><br><span class="line">        作用：要输出的值</span><br><span class="line">        参数类型：Object</span><br><span class="line">    default</span><br><span class="line">        作用：当value为null时显示的默认值。</span><br><span class="line">        参数类型：Object</span><br><span class="line">    escaXml</span><br><span class="line">        作用：是否对特殊字符进行转义。</span><br><span class="line">        参数类型：boolean</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:out value=&quot;$&#123;user.name&#125;&quot; default=&quot;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-set-gt"><a href="#lt-c-set-gt" class="headerlink" title="&lt;c:set&gt;"></a>&lt;c:set&gt;</h3><ul><li>&lt;c:set&gt;用于添加或修改域中的属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">可以设置的属性：</span><br><span class="line">    value</span><br><span class="line">        作用：要设置的值</span><br><span class="line">        参数类型：Object</span><br><span class="line">    var</span><br><span class="line">        作用：表示域中存放的属性名。</span><br><span class="line">        参数类型：String</span><br><span class="line">    scope</span><br><span class="line">        作用：指定域（page、request、session、application），若不指定则为page域对象</span><br><span class="line">        参数类型：String</span><br><span class="line">    target</span><br><span class="line">    作用：要修改的域对象的属性名（必须是JavaBean或者Map）</span><br><span class="line">    参数类型：Object</span><br><span class="line">    property</span><br><span class="line">    作用：指定要修改的对象的属性名</span><br><span class="line">    参数类型：String</span><br></pre></td></tr></table></figure><ul><li>例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置属性：</span><br><span class="line">&lt;c:set var=&quot;key&quot; value=&quot;value&quot; scope=&quot;request&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">修改属性：</span><br><span class="line">&lt;c:set property=&quot;name&quot; target=&quot;$&#123;user&#125;&quot; value=&quot;孙悟空&quot;&gt;&lt;/c:set&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-remove-gt"><a href="#lt-c-remove-gt" class="headerlink" title="&lt;c:remove&gt;"></a>&lt;c:remove&gt;</h3><ul><li>&lt;c:remove&gt;用于移除域中的属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以设置的属性：</span><br><span class="line">var</span><br><span class="line">作用：设置要移除的属性的名字</span><br><span class="line">作用：String</span><br><span class="line">scope</span><br><span class="line">作用：设置要移除属性所在的域，若不指定则删除所有域中的对应属性</span><br><span class="line">参数类型：String</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">移除所有域中key属性：&lt;c:remove var=&quot;key&quot;/&gt;</span><br><span class="line">移除request中的key属性: &lt;c:remove var=&quot;key&quot; scope=&quot;request&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-if-gt"><a href="#lt-c-if-gt" class="headerlink" title="&lt;c:if&gt;"></a>&lt;c:if&gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if&gt;用于实现if语句的判断功能</span><br><span class="line">可设置的属性</span><br><span class="line">test</span><br><span class="line">    作用：设置if判断的条件，用于判断标签体是否被执行</span><br><span class="line">    参数类型：boolean</span><br><span class="line">var</span><br><span class="line">    作用：用于指定接收判断结果的变量名</span><br><span class="line">    参数类型：boolean</span><br><span class="line">scope</span><br><span class="line">    作用：指定判断结果保存到哪个域</span><br><span class="line">    参数类型：String</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c:if test=&quot;$&#123;empty user &#125;&quot; var=&quot;isUserEmpty&quot; scope=&quot;request&quot;&gt;</span><br><span class="line">用户为空</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-choose-gt-、-lt-c-when-gt-、-lt-c-otherwise-gt"><a href="#lt-c-choose-gt-、-lt-c-when-gt-、-lt-c-otherwise-gt" class="headerlink" title="&lt;c:choose&gt;、&lt;c:when&gt;、&lt;c:otherwise&gt;"></a>&lt;c:choose&gt;、&lt;c:when&gt;、&lt;c:otherwise&gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;、&lt;c:when&gt;、&lt;c:otherwise&gt;三个标签配合使用，功能类似于Java中的if/else</span><br><span class="line">&lt;c:choose&gt;是&lt;c:when&gt;和&lt;c:otherwise&gt;的父标签</span><br><span class="line">&lt;c:when&gt;的属性</span><br><span class="line">test</span><br><span class="line">    作用：用于设置判断条件，若正确则c:when中的代码执行，否则不执行</span><br><span class="line">    参数类型：boolean</span><br><span class="line">&lt;c:otherwise&gt;</span><br><span class="line">    作用：如果所有的&lt;c:when&gt;都没有执行则执行&lt;c:otherwise&gt;的标签体</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;param.age&gt;=18 &#125;&quot;&gt;</span><br><span class="line">您已经成年</span><br><span class="line">&lt;/c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;</span><br><span class="line">您未成年</span><br><span class="line">&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-forEach-gt"><a href="#lt-c-forEach-gt" class="headerlink" title="&lt;c:forEach&gt;"></a>&lt;c:forEach&gt;</h3><ul><li>&lt;c:forEach&gt;用于对多个对象的集合进行迭代，重复执行标签体，或者重复迭代固定的次数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">可设置属性：</span><br><span class="line">var</span><br><span class="line">    作用：设置遍历出对象的名称</span><br><span class="line">    参数类型：String</span><br><span class="line">items</span><br><span class="line">    作用：指定要遍历的集合对象</span><br><span class="line">    参数类型：数组、字符串和各种集合</span><br><span class="line">varStatus</span><br><span class="line">    作用：指定保存迭代状态的对象的名字，该变量引用的是一个LoopTagStatus类型的对象，通过该对象可以获得一些遍历的状态：</span><br><span class="line">        count</span><br><span class="line">        index</span><br><span class="line">        first</span><br><span class="line">        last</span><br><span class="line">        name</span><br><span class="line">    参数类型：String</span><br><span class="line">begin</span><br><span class="line">    作用：指定遍历的开始位置</span><br><span class="line">    参数类型：int</span><br><span class="line">end</span><br><span class="line">    作用：指定遍历的结束位置</span><br><span class="line">    参数类型：int</span><br><span class="line">step</span><br><span class="line">    作用：迭代的步长</span><br><span class="line">        参数类型：int</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;user&quot; begin=&quot;0&quot; end=&quot;4&quot; step=&quot;2&quot; varStatus=&quot;vs&quot;&gt;</span><br><span class="line">$&#123;vs.index&#125; -- $&#123;user.name &#125; -- $&#123;user.age &#125;&lt;br /&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-url-gt"><a href="#lt-c-url-gt" class="headerlink" title="&lt;c:url&gt;"></a>&lt;c:url&gt;</h3><ul><li>&lt;c:url&gt;主要用来重写URL地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可设置的属性：</span><br><span class="line">value</span><br><span class="line">    作用：设置要处理的URI地址，注意这里要以/开头</span><br><span class="line">可接受参数：String</span><br><span class="line">var</span><br><span class="line">    作用：修改后存储到域对象中的uri属性名。</span><br><span class="line">    可接受参数：String</span><br><span class="line">scope</span><br><span class="line">    作用：设置修改后uri存放的域</span><br><span class="line">    可接受参数：String</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用相对路径：</span><br><span class="line">&lt;c:url value=&quot;index.jsp&quot; var=&quot;uri&quot; scope=&quot;request&quot;&gt;</span><br><span class="line">&lt;c:param name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/c:param&gt;</span><br><span class="line">&lt;/c:url&gt;</span><br><span class="line">会生成如下地址：index.jsp?name=%E5%BC%A0%E4%B8%89</span><br><span class="line">使用绝对路径会自动在路径前加上项目名：</span><br><span class="line">&lt;c:url value=&quot;/index.jsp&quot; var=&quot;uri&quot; scope=&quot;request&quot;&gt;</span><br><span class="line">&lt;c:param name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/c:param&gt;</span><br><span class="line">&lt;/c:url&gt;</span><br><span class="line">会生成如下地址：/Test_JSTL/index.jsp?name=%E5%BC%A0%E4%B8%89</span><br></pre></td></tr></table></figure><h3 id="lt-c-redirect-gt"><a href="#lt-c-redirect-gt" class="headerlink" title="&lt;c:redirect&gt;"></a>&lt;c:redirect&gt;</h3><ul><li>&lt;c:redirect&gt;主要用于将请求重定向到另一个资源地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可设置的属性：</span><br><span class="line">uri</span><br><span class="line">    作用：指定要重定向到的目标地址，注意这里指定绝对路径会自动加上项目名</span><br><span class="line">    参数类型：String</span><br></pre></td></tr></table></figure><ul><li>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:redirect url=&quot;/target.jsp&quot;&gt;&lt;/c:redirect&gt;</span><br></pre></td></tr></table></figure><h2 id="JSTL函数（JSTL-Functions）"><a href="#JSTL函数（JSTL-Functions）" class="headerlink" title="JSTL函数（JSTL Functions）"></a>JSTL函数（JSTL Functions）</h2><ul><li>函数标签库是在JSTL中定义的标准的EL函数集。</li><li>函数标签库中定义的函数基本上都是对字符串的操作。</li><li>引入：&lt;%@ taglib prefix=”fn” uri=”<a href="http://java.sun.com/jsp/jstl/functions&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/functions&quot;</a> %&gt;</li></ul><h3 id="fn-contains和fn-containsIgnoreCase"><a href="#fn-contains和fn-containsIgnoreCase" class="headerlink" title="fn:contains和fn:containsIgnoreCase"></a>fn:contains和fn:containsIgnoreCase</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：用于判断字符串中是否包含指定字符串，containsIgnoreCase忽略大小写。</span><br><span class="line">语法：fn:contains(string,subString)  --&gt;boolean</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606144819.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:contains(&quot;hello&quot;,&quot;HE&quot;)&#125;   --&gt;false</span><br><span class="line">$&#123;fn:containsIgnoreCase(&quot;hello&quot;,&quot;HE&quot;)&#125;  --&gt;true</span><br></pre></td></tr></table></figure><h2 id="fn-startsWith和fn-endsWith"><a href="#fn-startsWith和fn-endsWith" class="headerlink" title="fn:startsWith和fn:endsWith"></a>fn:startsWith和fn:endsWith</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用：判断一个字符串是否以指定字符开头（startsWith）或结尾（endsWith）</span><br><span class="line">语法：</span><br><span class="line">    fn:startsWith(string , prefix)  --&gt;boolean</span><br><span class="line">fn:endsWith(string,suffix)  --&gt;boolean</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606144520.png" alt></p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:startsWith(&quot;hello&quot;,&quot;he&quot;) &#125;  --&gt;true</span><br><span class="line">$&#123;fn:endsWith(&quot;hello&quot;,&quot;he&quot;) &#125;  --&gt;false</span><br></pre></td></tr></table></figure><h2 id="fn-indexOf"><a href="#fn-indexOf" class="headerlink" title="fn:indexOf"></a>fn:indexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：在一个字符串中查找指定字符串，并返回第一个符合的字符串的第一个字符的索引。</span><br><span class="line">语法：fn:indexOf(string,subString)  --&gt;int</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606144625.png" alt></p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:indexOf(&quot;hello&quot;,&apos;e&apos;) &#125;  --&gt;1</span><br></pre></td></tr></table></figure><h2 id="fn-replace"><a href="#fn-replace" class="headerlink" title="fn:replace"></a>fn:replace</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：将一个字符串替换为另外一个字符串，并返回替换结果</span><br><span class="line">语法：fn:replace(str , beforeSubString , afterSubString) --&gt;String</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:replace(&quot;hello&quot;,&quot;llo&quot;,&apos;e&apos;) &#125;  hee</span><br><span class="line">fn:substring</span><br><span class="line">作用：截取字符串</span><br><span class="line">语法：fn: substring (str , beginIndex , endIndex)  String</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="http://note.youdao.com/yws/res/8882/A47D18C6C90D47C19778B9EA50D9B13A" alt="image"></p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:substring(&quot;hello&quot;,1,3) &#125; --&gt; el</span><br></pre></td></tr></table></figure><h2 id="fn-substringBefore和fn-substringAfter"><a href="#fn-substringBefore和fn-substringAfter" class="headerlink" title="fn:substringBefore和fn:substringAfter"></a>fn:substringBefore和fn:substringAfter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：返回一个字符串指定子串之前（substringBefore）之后（substringAfter）的字符串</span><br><span class="line">语法：fn: substringBefore(string,subString)  --&gt;String</span><br><span class="line">fn: substringAfter (string,subString)  --&gt;String</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606145515.png" alt></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:substringBefore(&quot;hello&quot;,&quot;l&quot;) &#125;  --&gt;he</span><br><span class="line">$&#123;fn:substringAfter(&quot;hello&quot;,&quot;l&quot;) &#125;  --&gt;lo</span><br></pre></td></tr></table></figure></p><h2 id="fn-split"><a href="#fn-split" class="headerlink" title="fn:split"></a>fn:split</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：将一个字符串拆分成字符串数组。</span><br><span class="line">语法：fn:split(string,delimiters)  --&gt;String</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606145633.png" alt></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:split(&quot;a-b-c-d-e-f-g&quot;,&quot;-&quot;)&#125;</span><br><span class="line">返回一个数组对象[a,b,c,d,e,f,g]</span><br></pre></td></tr></table></figure></p><h2 id="fn-join"><a href="#fn-join" class="headerlink" title="fn:join"></a>fn:join</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：将数组中所有元素连接成一个字符串</span><br><span class="line">语法：fn:join(array,sparator)  --&gt;String</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606150021.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">&lt;%</span><br><span class="line">String[] strs = new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&#125;;</span><br><span class="line">pageContext.setAttribute(&quot;strs&quot;, strs);</span><br><span class="line">%&gt;</span><br><span class="line">$&#123;fn:join(strs,&apos;-&apos;) &#125;</span><br><span class="line">返回：a-b-c-d-e-f</span><br></pre></td></tr></table></figure><h2 id="fn-toLowerCase和fn-toUpperCase"><a href="#fn-toLowerCase和fn-toUpperCase" class="headerlink" title="fn:toLowerCase和fn:toUpperCase"></a>fn:toLowerCase和fn:toUpperCase</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用：将字符串都转换成大写（toUpperCase）或小写（toLowerCase）字符</span><br><span class="line">语法：</span><br><span class="line">fn: toLowerCase (str)  --&gt;String</span><br><span class="line">    fn: toUpperCase(str)  --&gt;String</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606150205.png" alt></p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   $&#123;fn:toLowerCase(&quot;ABCDEFG&quot;) &#125;  --&gt;abcdefg</span><br><span class="line">$&#123;fn:toUpperCase(&quot;abcdefg&quot;) &#125;  --&gt;ABCDEFG</span><br></pre></td></tr></table></figure><h2 id="fn-trim"><a href="#fn-trim" class="headerlink" title="fn:trim"></a>fn:trim</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：去掉字符串的前后空格</span><br><span class="line">用法：fn:trim(str)  --&gt;String</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606150313.png" alt></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:trim(&quot;     hello  &quot;) &#125;  --&gt;hello</span><br></pre></td></tr></table></figure></p><h2 id="fn-length"><a href="#fn-length" class="headerlink" title="fn:length"></a>fn:length</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：返回集合或者字符串的长度</span><br><span class="line">用法：fn:trim(input)  --&gt;int</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606150356.png" alt></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:length(&quot;hello&quot;) &#125; --&gt;5</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSTL简介&quot;&gt;&lt;a href=&quot;#JSTL简介&quot; class=&quot;headerlink&quot; title=&quot;JSTL简介&quot;&gt;&lt;/a&gt;JSTL简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSP虽然为我们提供了EL表达式用来替代JSP表达式，但是由于EL表达式仅仅具有输出功能，而不替
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>09 web-EL表达式（Expression Language）概述</title>
    <link href="http://yoursite.com/2017/11/09/28%20web-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Expression%20Language%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/11/09/28 web-EL表达式（Expression Language）概述/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2019-06-06T15:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EL简介"><a href="#EL简介" class="headerlink" title="EL简介"></a>EL简介</h1><ul><li>EL是JSP内置的表达式语言，用以访问页面的上下文以及不同作用域中的对象 ，取得对象属性的值，或执行简单的运算或判断操作。EL在得到某个数据时，会自动进行数据类型的转换。</li><li>EL表达式用于代替JSP表达式(&lt;%= %&gt;)在页面中做输出操作。</li><li>EL表达式仅仅用来读取数据，而不能对数据进行修改。</li><li>使用EL表达式输出数据时，如果有则输出数据，如果为null则什么也不输出。</li></ul><h1 id="EL基本使用"><a href="#EL基本使用" class="headerlink" title="EL基本使用"></a>EL基本使用</h1><ul><li>EL表达式总是放在{}中，而且前边有一个$作为前缀。<ul><li>${EL表达式}</li></ul></li></ul><ul><li>获取域中的对象可以直接使用对象名，如获取域中名字为user的对象<ul><li>${user}</li></ul></li></ul><ul><li>获取对象的属性值可以直接通过“对象.属性名”<ul><li>${user.name}</li><li>${user.age}</li><li>注意：这里的属性名是get和set方法对应的属性值，并不是对象中的变量名。</li><li>比如：如果获取name属性值，那么该对象中必定要存在一个getName()方法。</li></ul></li></ul><ul><li>获取对象的属性也可以通过“对象[“属性名”]”<ul><li>${user[“name”]}</li><li>${user[“age”]}</li></ul></li></ul><ul><li>获取Map中属性时可以以直接通过属性的key<ul><li>${map.key}</li><li>${map[key]}</li></ul></li></ul><ul><li>在指定域中获取属性<ul><li>在EL表达式中如果我们直接使用属性名如：${user}，它将会在四个域中由小到大依次查找。顺序：pageScope、requestScope、sessionScope、applicationScope。</li><li>也可以指定从哪个域中获取：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123; pageScope .user&#125;：当前页面</span><br><span class="line">$&#123;requestScope.user&#125;：当前请求</span><br><span class="line">$&#123;sessionScope.user&#125;：当前会话</span><br><span class="line">$&#123;sessionScope.user&#125;：当前应用</span><br></pre></td></tr></table></figure><h1 id="EL隐含对象"><a href="#EL隐含对象" class="headerlink" title="EL隐含对象"></a>EL隐含对象</h1><ul><li>EL中包含11个隐含对象，这些对象可以在EL表达式中直接使用。</li></ul><h2 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h2><ul><li>pageContext和JSP中的pageContext功能一样。</li></ul><h2 id="请求域"><a href="#请求域" class="headerlink" title="请求域"></a>请求域</h2><ul><li>请求域主要用于获取域对象中的属性，四个对象分别对应</li></ul><h2 id="四个请求域。"><a href="#四个请求域。" class="headerlink" title="四个请求域。"></a>四个请求域。</h2><pre><code>- pageScope- requestScope- sessionScope- applicationScope</code></pre><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><ul><li>参数对象主要用于获取get或post请求中的参数。<ul><li>param；</li><li>获取指定的请求参数， 如：${param.username}</li><li>paramValues；</li><li>获取请求参数数组，如：${paramValues.hobby}会返回一个string类型的数组</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">header；</span><br><span class="line">headerValues；</span><br><span class="line">initParam；</span><br><span class="line">cookie；</span><br></pre></td></tr></table></figure><h1 id="EL逻辑运算"><a href="#EL逻辑运算" class="headerlink" title="EL逻辑运算"></a>EL逻辑运算</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606115325.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EL简介&quot;&gt;&lt;a href=&quot;#EL简介&quot; class=&quot;headerlink&quot; title=&quot;EL简介&quot;&gt;&lt;/a&gt;EL简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;EL是JSP内置的表达式语言，用以访问页面的上下文以及不同作用域中的对象 ，取得对象属性的值，或执行简单的运算或
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>08 web-JSP概述</title>
    <link href="http://yoursite.com/2017/11/03/27%20web-JSP%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/11/03/27 web-JSP概述/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2019-06-06T15:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JSP简介"><a href="#1-JSP简介" class="headerlink" title="1.    JSP简介"></a>1.    JSP简介</h1><ul><li>JSP全称Java Server Pages，顾名思义就是运行在java服务器中的页面，也就是在我们JavaWeb中的动态页面，其本质就是一个Servlet。</li><li>其本身是一个动态网页技术标准，它的主要构成有HTML网页代码、Java代码片段、JSP标签几部分组成，后缀是.jsp。</li><li>JSP相比HTML页面来说，最直观的功能就是可以在页面中使用变量，这些变量一般都是从域对象中获取。有了变量的好处就是我们的页面可以动态的显示信息。</li><li>相比于Servlet，JSP更加善于处理显示页面，而Servlet跟擅长处理业务逻辑，两种技术各有专长，所以一般我们会将Servlet和JSP结合使用，Servlet负责业务，JSP负责显示。</li></ul><h1 id="2-JSP的基本语法"><a href="#2-JSP的基本语法" class="headerlink" title="2.    JSP的基本语法"></a>2.    JSP的基本语法</h1><h2 id="2-1-基本格式"><a href="#2-1-基本格式" class="headerlink" title="2.1 基本格式"></a>2.1 基本格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>JSP的基本格式和HTML页面相似，不同之处就是使用JSP时页面的顶部必须使用JSP指令声明一些JSP相关的信息。如上图JSP文件，首行使用一条page指令声明了JSP的相关信息，关于JSP指令我们在这里先不过多讲解，目前可以把它当成一种固定格式。</li><li>在首行的JSP指令下边就可以来编辑我们的HTML代码了，从上边的文件中也可以看出实际上就是原封不动的HTML代码。</li><li>如上这面的JSP文件，我们如果不需要加入动态代码，就可以直接来编写HTML代码，语法是一模一样的。</li><li>代码编辑完成后启动服务器，访问JSP页面（和访问HTML页面一样，直接输入地址），会看到页面正常显示和普通HTML一样。</li><li>注意：JSP文件的运行依赖于WEB服务器，也就是说如果不是通过WEB服务器，浏览器是不能直接打开JSP文件的。</li></ul><h2 id="2-2-JSP脚本元素"><a href="#2-2-JSP脚本元素" class="headerlink" title="2.2 JSP脚本元素"></a>2.2 JSP脚本元素</h2><ul><li>在JSP中我们主要通过脚本元素来编写Java代码，这些Java代码一般会在页面被访问时调用。</li><li>JSP脚本元素主要分三种：脚本片段、表达式还有声明。</li></ul><h3 id="2-2-1-JSP脚本片段"><a href="#2-2-1-JSP脚本片段" class="headerlink" title="2.2.1 JSP脚本片段"></a>2.2.1 JSP脚本片段</h3><ul><li>脚本片段是嵌入到JSP中Java代码段，格式以&lt;%开头，%&gt;结尾，两个%号之间就可以编写Java代码了。</li></ul><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% System.out.println(&quot;Hello World&quot;);%&gt;</span><br></pre></td></tr></table></figure><ul><li>上边就是一个JSP的脚本片段，片段中的Java代码使我们非常熟悉的内容，这条语句会在JSP页面被访问时向页面中打印一条“Hello World”。</li><li>通过这种方式我们可以在JSP中完成大量的Java代码，甚至写一些业务逻辑，但是并不建议这么做。</li><li>这种方式编写的Java代码，会放到Servlet的service方法中执行，既然是写在一个方法中的代码那就对我们就不能随便的去写。比如：不能定义成员变量、不能定义方法、不能定义类。</li></ul><h3 id="2-2-2-JSP表达式"><a href="#2-2-2-JSP表达式" class="headerlink" title="2.2.2 JSP表达式"></a>2.2.2 JSP表达式</h3><ul><li>JSP表达式用来直接将Java变量输出到页面中，格式以&lt;%=开头，以%&gt;结尾，中间是我们要输出的内容。</li></ul><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=str %&gt;</span><br></pre></td></tr></table></figure><ul><li>上边语句中的str是JSP中的一个String型的变量，通过这种方式可以将该变量输出到页面中。</li></ul><h3 id="2-2-3-JSP声明（了解）"><a href="#2-2-3-JSP声明（了解）" class="headerlink" title="2.2.3    JSP声明（了解）"></a>2.2.3    JSP声明（了解）</h3><ul><li>JSP声明中的内容会被直接写到类中，格式以&lt;%!开头，以%&gt;结尾，中间是Java代码</li></ul><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! private int a = 0; %&gt;</span><br></pre></td></tr></table></figure><ul><li>上边这条语句相当于在类中声明了一个成员变量，由于JSP声明中的代码会被写在类中，所以在类中可以编写的内容在JSP声明中都可以编写。如：定义成员变量、定义方法、构造器、构造代码块、静态代码块。</li><li>JSP声明使用的机会并不是很多，所以知道即可。</li></ul><h3 id="2-2-4-注释"><a href="#2-2-4-注释" class="headerlink" title="2.2.4 注释"></a>2.2.4 注释</h3><ul><li>JSP注释和其他注释功能一样，注释的内容只有在当前JSP页面中可以看到，但是在转换后的Servlet中以及浏览器端显示的页面中都是不可见的。</li></ul><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 注释内容 --%&gt;</span><br></pre></td></tr></table></figure></p><ul><li>JSP中个中注释的比较：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606221837.png" alt></p><h2 id="2-3-JSP运行原理"><a href="#2-3-JSP运行原理" class="headerlink" title="2.3 JSP运行原理"></a>2.3 JSP运行原理</h2><ul><li>上边我们演示了JSP中的几种脚本元素，这几种脚本元素都是可以运行的Java代码，大家一定会有一个疑问，为什么在一个页面中可以运行Java代码呢？</li><li>实际上Tomcat在运行JSP时，并不是直接显示的我们所编写的JSP页面，而是将JSP页面转换成了一个Java类，这个Java类是什么，我想大家也能猜到了，它实际上就是一个Servlet。</li><li>这个Servlet在哪呢？还记得我们说过的Tomcat的work目录吗？在那个目录下保存着Tomcat自动生成的一些内容，下面让我们来找到那个目录。</li><li>对于Eclipse来说是在:<ul><li>工作空间下的<code>.metadata\.plugins\org.eclipse.wst.server.core\tmp0</code></li></ul></li></ul><ul><li>对于MyEclipse来说就可以直接去Tomcat的安装目录去查找</li><li>在Work目录下的<code>Catalina\localhost\07_WEB_SERVLET\org\apache\jsp</code>文件夹中我们可以发现两个文件<code>index_jsp.java和index_jsp.class</code>，前者就是Tomcat自动生成的Servlet的源码，后者是编译后的.class文件。打开java文件内容如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.jsp;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.jsp.*;</span><br><span class="line"></span><br><span class="line">public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase</span><br><span class="line">    implements org.apache.jasper.runtime.JspSourceDependent &#123;</span><br><span class="line"></span><br><span class="line">  private int a = 0; //JSP声明生成的代码</span><br><span class="line">  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  private static java.util.List _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  private javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  private org.apache.AnnotationProcessor _jsp_annotationprocessor;</span><br><span class="line"></span><br><span class="line">  public Object getDependants() &#123;</span><br><span class="line">    return _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspInit() &#123;</span><br><span class="line">    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">    _jsp_annotationprocessor = (org.apache.AnnotationProcessor) getServletConfig().getServletContext().getAttribute(org.apache.AnnotationProcessor.class.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspDestroy() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspService(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">        throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    PageContext pageContext = null;</span><br><span class="line">    HttpSession session = null;</span><br><span class="line">    ServletContext application = null;</span><br><span class="line">    ServletConfig config = null;</span><br><span class="line">    JspWriter out = null;</span><br><span class="line">    Object page = this;</span><br><span class="line">    JspWriter _jspx_out = null;</span><br><span class="line">    PageContext _jspx_page_context = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      response.setContentType(&quot;text/html; charset=UTF-8&quot;);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(this, request, response,</span><br><span class="line">      null, true, 8192, true);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;!DOCTYPE html&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;html&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;head&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;meta charset=\&quot;UTF-8\&quot;&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;title&gt;Insert title here&lt;/title&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/head&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t&quot;);</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;Hello World&quot;);  //脚本片段生成的代码</span><br><span class="line">int x = 20394; //脚本片段生成的代码</span><br><span class="line"></span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t&lt;!-- JSP表达式生成的代码 --&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t&quot;);</span><br><span class="line">      out.print(x );</span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t\r\n&quot;);</span><br><span class="line">      out.write(&quot;\t&quot;);</span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (!(t instanceof SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        if (out != null &amp;&amp; out.getBufferSize() != 0)</span><br><span class="line">          try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125;</span><br><span class="line">        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);</span><br><span class="line">        else log(t.getMessage(), t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过观察发现index_jsp名字和我们创建的jsp文件名字类似，只是把index.jsp中的点换成的_，实际上他就是Tomcat根据我们编写的JSP文件自动生成的类。</li><li>index_jsp这个类继承了org.apache.jasper.runtime.HttpJspBase，而HttpJspBase又继承了HttpServlet。由此证明，index_jsp就是一个Servlet。而在我们访问JSP时服务器就是调用了该Servlet来响应请求。</li><li>有同学可能会有疑问，Servlet是需要在web.xml中配置的，而我们并没有配置JSP的serlvet映射，那他是如何访问的呢？实际在conf目录中的web.xml早已配置好了JSP的映射信息，具体内容如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;fork&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;xpoweredBy&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><ul><li>既然已经证明其就是一个Servlet，那我们已知Servlet是调用service方法来处理请求的，在我们的index_jsp中并没有我们熟悉的service()方法，但是经仔细观察发现有如下方法<code>jspService(HttpServletRequest request, HttpServletResponse response)</code>，该方法就相当于我们JSP中<code>service()</code>方法。</li><li>service方法中声明了如下几个局部变量：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageContext pageContext = null;</span><br><span class="line">HttpSession session = null;</span><br><span class="line">ServletContext application = null;</span><br><span class="line">ServletConfig config = null;</span><br><span class="line">JspWriter out = null;</span><br><span class="line">Object page = this;</span><br></pre></td></tr></table></figure><ul><li>这几个对象在方法下边进行了赋值操作，再加上参数中的request和response，以及出异常的时候还有一个exception。这些是我们JSP中的九大隐含对象，后边我们还要在讲解。这些对象除了exception比较特殊外，其他都可以直接在JSP中直接使用。</li><li>注意观察该方法，是如何将JSP中的代码转换为Java代码的：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Html代码：out.write(&quot;&lt;!DOCTYPE html&gt;\r\n&quot;);</span><br><span class="line">    JSP中的HTML代码会变成字符串通过out.write()方法输出。</span><br><span class="line">&lt;%%&gt;中的代码：System.out.println(&quot;Hello World&quot;); //脚本片段生成的代码。</span><br><span class="line">    脚本片段中的代码会直接复制到对应的位置。</span><br><span class="line">&lt;%=x%&gt;中的代码：out.print(x );</span><br><span class="line">    表达式中的变量，会变成out.print()的参数输出到页面中。</span><br><span class="line">&lt;%! %&gt;中的代码：private int a = 0; //JSP声明生成的代码</span><br><span class="line">    声明中的代码，会被原封不动的写到类中。</span><br></pre></td></tr></table></figure><ul><li>理解了JSP的运行原理对我们理解JSP是非常重要的，也就是说在我们编写JSP代码的时候，在脑海里应该可以想象出编译好的servlet的样子。</li></ul><h2 id="2-4-JSP生命周期"><a href="#2-4-JSP生命周期" class="headerlink" title="2.4 JSP生命周期"></a>2.4 JSP生命周期</h2><h2 id="2-5-JSP隐含对象"><a href="#2-5-JSP隐含对象" class="headerlink" title="2.5 JSP隐含对象"></a>2.5 JSP隐含对象</h2><ul><li>隐含对象指在JSP中无需创建可以直接使用的对象，包括：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">out（JspWriter）：相当于response.getWriter()获取的对象，用于在页面中显示信息。</span><br><span class="line">config（ServletConfig）：对应Servlet中的ServletConfig对象。</span><br><span class="line">page（Object）：对应当前Servlet对象，实际上就是this。</span><br><span class="line">pageContext（PageContext）：当前页面的上下文，也是一个域对象。</span><br><span class="line">exception（Throwable）：错误页面中异常对象</span><br><span class="line">request（HttpServletRequest）：HttpServletRequest对象</span><br><span class="line">response（HttpServletResponse）：HttpServletResponse对象</span><br><span class="line">application（ServletContext）：ServletContext对象</span><br><span class="line">session（HttpSession）：HttpSession对象</span><br></pre></td></tr></table></figure><h3 id="2-5-1-域对象"><a href="#2-5-1-域对象" class="headerlink" title="2.5.1 域对象"></a>2.5.1 域对象</h3><ul><li>在JavaWeb中总共有四个域，页面、请求、会话和整个应用。域对象主要作用就是在这四个域中传递数据的。</li><li>每个域对象的内部实际上都有一个map用来存储数据，数据以键值对的结构存放，key是String类型的，value使用Object类型。</li><li>我们可以在一个域对象中放入数据。然后，在当前域中的其他JSP页面或Servlet中获取该数据。以达到一个共享数据的目的。</li><li>在JSP中可以获得全部四个域对象，而Servlet中只能获取三个域对象request、session、application。</li><li>四个域对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pageContext</span><br><span class="line">1.类型：PageContext</span><br><span class="line">2.范围：当前JSP页面</span><br><span class="line">3.注意：该对象只能在JSP中获取，Servlet中没有</span><br><span class="line">Request</span><br><span class="line">1.类型：HttpServletRequest</span><br><span class="line">2.范围：当前请求</span><br><span class="line">Session</span><br><span class="line">1.类型：HttpSession</span><br><span class="line">2.范围：当前会话</span><br><span class="line">Application</span><br><span class="line">1.类型：ServletContext</span><br><span class="line">2.范围：当前应用</span><br></pre></td></tr></table></figure><ul><li>域对象都有三个操作数据的主要方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void setAttribute(String name, Object o);</span><br><span class="line">1.在当前域中放入数据</span><br><span class="line">public Object getAttribute(String name)</span><br><span class="line">2.根据名字获取当前域中的数据</span><br><span class="line">public void removeAttribute(String name);</span><br><span class="line">3.根据名字删除当前域中的数据</span><br></pre></td></tr></table></figure><ul><li>四个范围<ul><li>页面：页面范围内的数据，只能在当前页面中获取，一旦转到其他页面当前域中的数据便失效，不能获取。</li><li>请求：请求范围内的数据，和页面范围类似，它表示的是一次请求范围。区分一次请求主要是看是不是同一个request。比如：转发是表示一个请求，重定向是多个请求。</li><li>会话：会话比请求更高一级。简单来说，就是打开浏览器到关闭浏览器，这一个完整的上网过程叫做一个会话。只要没有关闭浏览器或设置session失效，就可以在域中获取到Session中的数据。</li><li>应用：应用是最高级的域对象，他代表整个WEB应用，在这个域对象中设置的数据在所有的域中都能获取。</li></ul></li><li>PageContext<ul><li>PageContext和其他域对象还不太一样，还有一些特有的功能。</li><li>PageContext是整个页面的上下文，可以获取页面相关的内容。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.作为页面域对象。</span><br><span class="line">2.可以获取指定域中的数据。</span><br><span class="line">getAttribute(String name, int scope)</span><br><span class="line">3.可以向指定域中设置数据。</span><br><span class="line">setAttribute(String name, Object value, int scope)</span><br><span class="line">上述两个方法中int scope是域类型的常量值，PageContext为每个域对象设置了一个整形常量分别为：</span><br><span class="line">    PageContext.PAGE_SCOPE 值为 1</span><br><span class="line">    PageContext.REQUEST_SCOPE 值为 2</span><br><span class="line">    PageContext.SESSION_SCOPE 值为 3</span><br><span class="line">    PageContext.APPLICATION_SCOPE 值为 4</span><br><span class="line">4.全域查找</span><br><span class="line">Object findAttribute(String name)</span><br><span class="line">5.可以获取其他隐含对象。</span><br><span class="line">HttpSession getSession()</span><br><span class="line">Object getPage()</span><br><span class="line">ServletRequest getRequest()</span><br><span class="line">ServletResponse getResponse()</span><br><span class="line">Exception getException()</span><br><span class="line">ServletConfig getServletConfig()</span><br><span class="line">ServletContext getServletContext()</span><br><span class="line">JspWriter getOut()</span><br></pre></td></tr></table></figure><h2 id="2-5-2-其他隐含对象"><a href="#2-5-2-其他隐含对象" class="headerlink" title="2.5.2 其他隐含对象"></a>2.5.2 其他隐含对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">out（JspWriter）</span><br><span class="line">赋值：out = pageContext.getWriter();</span><br><span class="line">作用：向页面中输出内容。</span><br><span class="line">本质：JSP的字符输出流。</span><br><span class="line">config（ServletConfig）：对应Servlet中的ServletConfig对象。</span><br><span class="line">赋值：config = pageContext.getServletConfig();</span><br><span class="line">作用：获取配置信息。</span><br><span class="line">本质：ServletConfig对象。</span><br><span class="line">page（Object）：对应当前Servlet对象，实际上就是this。</span><br><span class="line">赋值：Object page = this;</span><br><span class="line">本质：当前Servlet对象的引用。</span><br><span class="line">exception（Throwable）：错误页面中异常对象</span><br><span class="line">赋值：Throwable exception = </span><br><span class="line">org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);</span><br><span class="line">作用：获取异常信息。</span><br><span class="line">本质：Throwable对象。</span><br><span class="line">response（HttpServletResponse）：HttpServletResponse对象</span><br><span class="line">赋值：service()方法的参数。</span><br><span class="line">作用：同Servlet中的response。</span><br></pre></td></tr></table></figure><h2 id="2-6-JSP指令"><a href="#2-6-JSP指令" class="headerlink" title="2.6 JSP指令"></a>2.6 JSP指令</h2><ul><li>JSP指令用来设置与整个jsp页面相关的属性，它并不直接产生任何可见的输出,而只是告诉引擎如何处理其余JSP页面。</li><li>指令格式：&lt;%@指令名 属性名1=”属性值1” 属性名2=”属性值2”  %&gt;</li><li>JSP中有三种指令page、include、taglib。</li></ul><h3 id="2-6-1-page指令"><a href="#2-6-1-page指令" class="headerlink" title="2.6.1 page指令"></a>2.6.1 page指令</h3><p>ν    page指令是我们最常用的指令，属性非常多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import 导包</span><br><span class="line">isThreadSafe 是否单线程模式</span><br><span class="line">contentType 响应的文件类型</span><br><span class="line">isELIgnored 是否忽略EL表达式</span><br><span class="line">isErrorPage 是否是一个错误页面</span><br><span class="line">errorPage 发生错误后转发的页面</span><br><span class="line">language JSP使用的语言，目前只有java</span><br><span class="line">extends 继承父类</span><br><span class="line">session 页面中是否具有session对象</span><br><span class="line">buffer 定义out对象如何处理缓存</span><br><span class="line">autoFlush 缓存是否自动刷新</span><br><span class="line">info 定义转换后放到页面中的串</span><br><span class="line">pageEncoding 定义JSP页面的字符编码</span><br></pre></td></tr></table></figure><h3 id="2-6-2-include指令"><a href="#2-6-2-include指令" class="headerlink" title="2.6.2 include指令"></a>2.6.2 include指令</h3><ul><li>include是静态包含指令，主要是用于在当前页面中引入其他页面。</li><li>用法：<code>&lt;%@ include file=”页面地址”%&gt;</code></li><li>例如，有如下两个页面<ul><li>index.jsp</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">pageEncoding=&quot;UTF-8&quot; errorPage=&quot;error.jsp&quot;%&gt;</span><br><span class="line">&lt;%@ include file=&quot;in.html&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>-</p><pre><code>- in.html</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello I&apos;m in.html Page&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><ul><li>这种写法就相当于在index.jsp中的include标签的位置，将in.html的代码复制一遍</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">pageEncoding=&quot;UTF-8&quot; errorPage=&quot;error.jsp&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello I&apos;m in.html Page&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>-</p><pre><code>- 也就是说include的所引入页面的代码会在JSP对应的Servlet文件中生成</code></pre><h3 id="2-6-3-taglib指令"><a href="#2-6-3-taglib指令" class="headerlink" title="2.6.3 taglib指令"></a>2.6.3 taglib指令</h3><ul><li>定义JSP可以使用的标签库，这部分我们目前还用不到，等到JSTL时我们在详细讲解</li></ul><h2 id="2-7-JSP动作标签"><a href="#2-7-JSP动作标签" class="headerlink" title="2.7 JSP动作标签"></a>2.7 JSP动作标签</h2><ul><li>JSP动作标签与HTML标签不同，HTML标签由浏览器来解析，而JSP动作标签需要服务器（Tomcat）来运行。</li><li>常用的JSP动作标签。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward&gt;:</span><br><span class="line">作用：在页面中用于转发操作</span><br><span class="line">实例：</span><br><span class="line">        &lt;jsp:forward page=&quot;target.jsp&quot;&gt;&lt;/jsp:forward&gt;</span><br><span class="line">子标签：</span><br><span class="line">    &lt;jsp:param value=&quot;paramValue&quot; name=&quot;paramName&quot;/&gt;</span><br><span class="line">    作用：在转发时设置请求参数，通过request.getParameter()在目标页面获取请求参数。</span><br><span class="line">实例：</span><br><span class="line">    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;</span><br><span class="line">    &lt;jsp:param value=&quot;paramValue&quot; name=&quot;paramName&quot;/&gt;</span><br><span class="line">    &lt;/jsp:forward&gt;</span><br><span class="line">&lt;jsp:include&gt;:</span><br><span class="line">作用：动态包含，将其他页面包含到当前页面中。</span><br><span class="line">实例：</span><br><span class="line">        &lt;jsp:include page=&quot;target.jsp&quot;&gt;&lt;/jsp:include&gt;</span><br><span class="line">原理：当使用动态包含时，Tomcat会在生成的Servlet中加入如下代码：</span><br><span class="line"></span><br><span class="line">org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, &quot;target.jsp&quot;, out, false);</span><br></pre></td></tr></table></figure><ul><li>与静态包含的区别：<ul><li>静态包含使用include指令，动态包含使用<a href="jsp:inclued" target="_blank" rel="noopener">jsp:inclued</a>标签</li><li>静态包含会直接将目标页面复制到生成的Servlet中，动态包含是在生成的servlet中使用include()方法来引入目标页面。</li><li>当目标页面发生改变时，静态包含不能体现，动态包含可以体现</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JSP简介&quot;&gt;&lt;a href=&quot;#1-JSP简介&quot; class=&quot;headerlink&quot; title=&quot;1.    JSP简介&quot;&gt;&lt;/a&gt;1.    JSP简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSP全称Java Server Pages，顾名思义就是运行在java
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>07 web-Servlet概述</title>
    <link href="http://yoursite.com/2017/10/30/26%20web-Servlet%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/10/30/26 web-Servlet概述/</id>
    <published>2017-10-29T16:00:00.000Z</published>
    <updated>2019-06-06T15:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Why？我们为什么需要Servlet？"><a href="#1-Why？我们为什么需要Servlet？" class="headerlink" title="1    Why？我们为什么需要Servlet？"></a>1    Why？我们为什么需要Servlet？</h1><h2 id="1-1-Web应用基本运行模式"><a href="#1-1-Web应用基本运行模式" class="headerlink" title="1.1    Web应用基本运行模式"></a>1.1    Web应用基本运行模式</h2><p>①生活中的例子</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110357.png" alt></p><p>②Web应用运行模式</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110604.png" alt></p><h2 id="1-2-通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。"><a href="#1-2-通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。" class="headerlink" title="1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。"></a>1.2    通过网页驱动服务器端的Java程序。在网页上显示Java程序返回的数据。</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110525.png" alt></p><h1 id="2-What？什么是Servlet？"><a href="#2-What？什么是Servlet？" class="headerlink" title="2    What？什么是Servlet？"></a>2    What？什么是Servlet？</h1><p>●如果把Web应用比作一个餐厅，Servlet就是餐厅中的服务员——负责接待顾客、上菜、结账。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110646.png" alt></p><p>●从广义上来讲，Servlet规范是Sun公司制定的一套技术标准，包含与Web应用相关的一系列接口，是Web应用实现方式的宏观解决方案。而具体的Servlet容器负责提供标准的实现。<br>●从狭义上来讲，Servlet指的是javax.servlet.Servlet接口及其子接口，也可以指实现了Servlet接口的实现类。<br>●Servlet作为服务器端的一个组件，它的本意是“服务器端的小程序”。Servlet的实例对象由Servlet容器负责创建；Servlet的方法由容器在特定情况下调用；Servlet容器会在Web应用卸载时销毁Servlet对象的实例。  </p><h1 id="3-How？如何使用Servlet？"><a href="#3-How？如何使用Servlet？" class="headerlink" title="3    How？如何使用Servlet？"></a>3    How？如何使用Servlet？</h1><h2 id="3-1-操作步骤"><a href="#3-1-操作步骤" class="headerlink" title="3.1    操作步骤"></a>3.1    操作步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①搭建Web开发环境  </span><br><span class="line">②创建动态Web工程  </span><br><span class="line">③创建javax.servlet.Servlet接口的实现类：com.atguigu.servlet.MyFirstServlet  </span><br><span class="line">④在service(ServletRequest, ServletResponse)方法中编写如下代码，输出响应信息：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line">//1.编写输出语句，证明当前方法被调用</span><br><span class="line">System.out.println(&quot;Servlet worked...&quot;);</span><br><span class="line">//2.通过PrintWriter对象向浏览器端发送响应信息</span><br><span class="line">PrintWriter writer = res.getWriter();</span><br><span class="line">writer.write(&quot;Servlet response&quot;);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤在web.xml配置文件中注册MyFirstServlet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 声明一个Servlet --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;!-- 为Servlet指定一个名称，以便于引用 --&gt;</span><br><span class="line">&lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;!-- 注册Servlet实现类的全类名 --&gt;</span><br><span class="line">&lt;servlet-class&gt;com.atguigu.servlet.MyFirstServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 建立一个从虚拟路径到Servlet之间的映射关系 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;!-- 引用Servlet名称 --&gt;</span><br><span class="line">&lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;!-- 映射到Servlet的虚拟路径：“/MyFirstServlet” --&gt;</span><br><span class="line">&lt;url-pattern&gt;/MyFirstServlet&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>⑥在WebContent目录下创建index.html<br>⑦在index.html中加入超链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;MyFirstServlet&quot;&gt;To Servlet&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>⑧点击超链接测试Servlet</p><h2 id="3-2-运行分析"><a href="#3-2-运行分析" class="headerlink" title="3.2    运行分析"></a>3.2    运行分析</h2><ul><li>index.html</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606110954.png" alt>    </p><ul><li>web.xml</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111017.png" alt></p><h1 id="4-Servlet技术体系（了解）"><a href="#4-Servlet技术体系（了解）" class="headerlink" title="4    Servlet技术体系（了解）"></a>4    Servlet技术体系（了解）</h1><h2 id="4-1-Servlet"><a href="#4-1-Servlet" class="headerlink" title="4.1    Servlet"></a>4.1    Servlet</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111053.png" alt></p><p>①Servlet接口</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111115.png" alt></p><p>②GenericServlet抽象类</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111136.png" alt></p><p>●对Servlet功能进行了封装和完善，将service(ServletRequest req, ServletResponse res)保留为抽象方法，让使用者仅关心业务实现即可。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111225.png" alt></p><p>③HttpServlet抽象类</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111248.png" alt></p><p>●对GenericServlet进行了进一步的封装和扩展，更贴近HTTP协议下的应用程序编写，在service(ServletRequest req, ServletResponse res)方法中，根据不同HTTP请求类型调用专门的方法进行处理。<br>●今后在实际使用中继承HttpServlet抽象类创建自己的Servlet实现类即可。重写doGet(HttpServletRequest req, HttpServletResponse resp)和doPost(HttpServletRequest req, HttpServletResponse resp)方法实现请求处理，不再需要重写service(ServletRequest req, ServletResponse res)方法了。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111327.png" alt></p><h2 id="4-2-ServletConfig接口"><a href="#4-2-ServletConfig接口" class="headerlink" title="4.2    ServletConfig接口"></a>4.2    ServletConfig接口</h2><p>封装了Servlet配置信息</p><h2 id="4-3-ServletContext接口"><a href="#4-3-ServletContext接口" class="headerlink" title="4.3    ServletContext接口"></a>4.3    ServletContext接口</h2><p>封装了当前Web应用上下文信息</p><h2 id="4-4-HttpServletRequest接口"><a href="#4-4-HttpServletRequest接口" class="headerlink" title="4.4    HttpServletRequest接口"></a>4.4    HttpServletRequest接口</h2><p>封装了HTTP请求信息，ServletRequest的子接口</p><h2 id="4-5-HttpServletResponse接口"><a href="#4-5-HttpServletResponse接口" class="headerlink" title="4.5    HttpServletResponse接口"></a>4.5    HttpServletResponse接口</h2><p>封装了HTTP响应信息，ServletResponse的子接口</p><h1 id="5-Servlet生命周期"><a href="#5-Servlet生命周期" class="headerlink" title="5    Servlet生命周期"></a>5    Servlet生命周期</h1><p>5.1    应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。<br>5.2    Servlet对象是Servlet容器创建的，生命周期方法都是由容器调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。  </p><h2 id="5-3-Servlet生命周期的主要过程"><a href="#5-3-Servlet生命周期的主要过程" class="headerlink" title="5.3    Servlet生命周期的主要过程"></a>5.3    Servlet生命周期的主要过程</h2><h3 id="①Servlet对象的创建"><a href="#①Servlet对象的创建" class="headerlink" title="①Servlet对象的创建"></a>①Servlet对象的创建</h3><p>默认情况下，Servlet容器第一次收到HTTP请求时创建对应Servlet对象。容器之所以能做到这一点是由于我们在注册Servlet时提供了全类名，容器使用反射技术创建了Servlet的对象。</p><h3 id="②Servlet对象初始化"><a href="#②Servlet对象初始化" class="headerlink" title="②Servlet对象初始化"></a>②Servlet对象初始化</h3><p>●Servlet容器创建Servlet对象之后，会调用init(ServletConfig config)方法，对其进行初始化。在javax.servlet.Servlet接口中，public void init(ServletConfig config)方法要求容器将ServletConfig的实例对象传入，这也是我们获取ServletConfig的实例对象的根本方法。  </p><h3 id="③处理请求"><a href="#③处理请求" class="headerlink" title="③处理请求"></a>③处理请求</h3><p>●在javax.servlet.Servlet接口中，定义了service(ServletRequest req, ServletResponse res)方法处理HTTP请求，同时要求容器将ServletRequest对象和ServletResponse对象传入。</p><h3 id="④Servlet对象销毁"><a href="#④Servlet对象销毁" class="headerlink" title="④Servlet对象销毁"></a>④Servlet对象销毁</h3><p>●服务器重启或服务器停止执行时会销毁Servlet对象，而销毁之前为了执行一些诸如释放缓存、关闭连接、保存数据等操作，所以设计了public void destroy()方法。</p><h1 id="6-ServletConfig接口"><a href="#6-ServletConfig接口" class="headerlink" title="6    ServletConfig接口"></a>6    ServletConfig接口</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111546.png" alt></p><p>6.1    ServletConfig接口封装了Servlet配置信息，这一点从接口的名称上就能够看出来。但同时，代表当前Web应用的ServletContext对象也封装到了ServletConfig对象中，使ServletConfig对象成为了获取ServletContext对象的一座桥梁。  </p><h2 id="6-2-ServletConfig对象的主要功能"><a href="#6-2-ServletConfig对象的主要功能" class="headerlink" title="6.2    ServletConfig对象的主要功能"></a>6.2    ServletConfig对象的主要功能</h2><p>①获取Servlet名称<br>②获取Servlet初始化参数<br>③获取ServletContext对象  </p><h1 id="7-ServletContext接口"><a href="#7-ServletContext接口" class="headerlink" title="7    ServletContext接口"></a>7    ServletContext接口</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111633.png" alt></p><p>7.1    Web容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前Web应用——作用很像餐厅的经理。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606111650.png" alt></p><p>7.2    由于一个Web应用程序中的所有Servlet都共享同一个ServletContext对象，所以ServletContext对象也被称为 application 对象（Web应用程序对象）。<br>7.3    在应用程序中能够获取运行环境或容器信息的对象通常称之为“上下文对象”。<br>7.4    ServletContext对象的主要功能<br>①获取WEB应用程序的初始化参数<br>●设置Web应用初始化参数的方式是在web.xml的根标签下加入如下代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Web应用初始化参数 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;ParamName&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;ParamValue&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure><p>●获取Web应用初始化参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">//1.获取ServletContext对象</span><br><span class="line">ServletContext context = this.getServletContext();</span><br><span class="line">//2.获取Web应用初始化参数</span><br><span class="line">String paramValue = context.getInitParameter(&quot;ParamName&quot;);</span><br><span class="line">System.out.println(&quot;paramValue=&quot;+paramValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②获取虚拟路径所映射的本地路径<br>●虚拟路径：浏览器访问Web应用中资源时所使用的路径。<br>●本地路径：资源在文件系统中的实际保存路径。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">//1.获取ServletContext对象</span><br><span class="line">ServletContext context = this.getServletContext();</span><br><span class="line">//2.获取index.html的本地路径</span><br><span class="line">//index.html的虚拟路径是“/index.html”,其中“/”表示当前Web应用的根目录，</span><br><span class="line">//即WebContent目录</span><br><span class="line">String realPath = context.getRealPath(&quot;/index.html&quot;);</span><br><span class="line">//realPath=D:\DevWorkSpace\MyWorkSpace\.metadata\.plugins\</span><br><span class="line">//org.eclipse.wst.server.core\tmp0\wtpwebapps\MyServlet\index.html</span><br><span class="line">System.out.println(&quot;realPath=&quot;+realPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③application域范围的属性</p><h1 id="8-HttpServletRequest接口"><a href="#8-HttpServletRequest接口" class="headerlink" title="8    HttpServletRequest接口"></a>8    HttpServletRequest接口</h1><p>①该接口是ServletRequest接口的子接口，封装了HTTP请求的相关信息，由Servlet容器创建其实现类对象并传入service(ServletRequest req, ServletResponse res)方法中。以下我们所说的HttpServletRequest对象指的是容器提供的HttpServletRequest实现类对象。<br>②HttpServletRequest对象的主要功能有<br>●获取请求参数。<br>●在请求域中保存数据。<br>●将请求转发给另外一个URL地址，参见[请求的转发与重定向]。<br>●获取项目虚拟路径。  </p><h1 id="9-HttpServletResponse接口"><a href="#9-HttpServletResponse接口" class="headerlink" title="9    HttpServletResponse接口"></a>9    HttpServletResponse接口</h1><p>①该接口是ServletResponse接口的子接口，封装了HTTP响应的相关信息，由Servlet容器创建其实现类对象并传入service(ServletRequest req, ServletResponse res)方法中。以下我们所说的HttpServletResponse对象指的是容器提供的HttpServletResponse实现类对象。<br>②主要功能<br>●使用PrintWriter对象向浏览器输出数据<br>●实现请求重定向，参见[请求的转发与重定向]。  </p><h1 id="10-请求的转发与重定向"><a href="#10-请求的转发与重定向" class="headerlink" title="10    请求的转发与重定向"></a>10    请求的转发与重定向</h1><p>10.1    请求的转发与重定向是Servlet控制页面跳转的主要方法，在Web应用中使用非常广泛。  </p><h2 id="10-2-请求的转发"><a href="#10-2-请求的转发" class="headerlink" title="10.2    请求的转发"></a>10.2    请求的转发</h2><p>①Servlet接收到浏览器端请求后，进行一定的处理，先不进行响应，而是在服务器端内部“转发”给其他Servlet程序继续处理。在这种情况下浏览器端只发出了一次请求，浏览器地址栏不会发生变化，用户也感知不到请求被转发了。<br>②转发请求的Servlet和目标Servlet共享同一个request对象。<br>③实现转发的API  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">//1.使用RequestDispatcher对象封装目标资源的虚拟路径</span><br><span class="line">RequestDispatcher dispatcher = request</span><br><span class="line">.getRequestDispatcher(&quot;/index.html&quot;);</span><br><span class="line">//2.调用RequestDispatcher对象的forward()方法“前往”目标资源</span><br><span class="line">//[注意：传入的参数必须是传递给当前Servlet的service方法的</span><br><span class="line">//那两个ServletRequest和ServletResponse对象]</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-请求的重定向"><a href="#10-3-请求的重定向" class="headerlink" title="10.3    请求的重定向"></a>10.3    请求的重定向</h2><p>①Servlet接收到浏览器端请求并处理完成后，给浏览器端一个特殊的响应，这个特殊的响应要求浏览器去请求一个新的资源，整个过程中浏览器端会发出两次请求，且浏览器地址栏会改变为新资源的地址。<br>②重定向的情况下，原Servlet和目标资源之间就不能共享请求域数据了。<br>③实现重定向的API  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">//1.调用HttpServletResponse对象的sendRedirect()方法</span><br><span class="line">//2.传入的参数是目标资源的虚拟路径</span><br><span class="line">response.sendRedirect(&quot;index.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-对比请求的转发和重定向"><a href="#10-4-对比请求的转发和重定向" class="headerlink" title="10.4    对比请求的转发和重定向"></a>10.4    对比请求的转发和重定向</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606113122.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Why？我们为什么需要Servlet？&quot;&gt;&lt;a href=&quot;#1-Why？我们为什么需要Servlet？&quot; class=&quot;headerlink&quot; title=&quot;1    Why？我们为什么需要Servlet？&quot;&gt;&lt;/a&gt;1    Why？我们为什么需要Serv
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>06 web-HTTP协议</title>
    <link href="http://yoursite.com/2017/10/27/25%20web-HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2017/10/27/25 web-HTTP协议/</id>
    <published>2017-10-26T16:00:00.000Z</published>
    <updated>2019-06-06T15:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HTTP协议简介"><a href="#1-HTTP协议简介" class="headerlink" title="1.    HTTP协议简介"></a>1.    HTTP协议简介</h1><ul><li>HTTP 超文本传输协议 (HTTP-Hypertext transfer protocol)，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。它是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</li><li>客户端与服务端通信时传输的内容我们称之为报文。</li><li>HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文。客户端发送给服务器的称为”请求报文“，服务器发送给客户端的称为”响应报文“。</li></ul><h1 id="2-HTTP协议的发展历程"><a href="#2-HTTP协议的发展历程" class="headerlink" title="2.    HTTP协议的发展历程"></a>2.    HTTP协议的发展历程</h1><ul><li>超文本传输协议的前身是世外桃源(Xanadu)项目，超文本的概念是泰德˙纳尔森(Ted Nelson)在1960年代提出的。进入哈佛大学后，纳尔森一直致力于超文本协议和该项目的研究，但他从未公开发表过资料。1989年，蒂姆˙伯纳斯˙李(Tim Berners Lee)在CERN(欧洲原子核研究委员会 = European Organization for Nuclear Research)担任软件咨询师的时候，开发了一套程序，奠定了万维网(WWW = World Wide Web)的基础。1990年12月，超文本在CERN首次上线。1991年夏天，继Telnet等协议之后，超文本转移协议成为互联网诸多协议的一分子。</li><li>当时，Telnet协议解决了一台计算机和另外一台计算机之间一对一的控制型通信的要求。邮件协议解决了一个发件人向少量人员发送信息的通信要求。文件传输协议解决一台计算机从另外一台计算机批量获取文件的通信要求，但是它不具备一边获取文件一边显示文件或对文件进行某种处理的功能。新闻传输协议解决了一对多新闻广播的通信要求。而超文本要解决的通信要求是：在一台计算机上获取并显示存放在多台计算机里的文本、数据、图片和其他类型的文件；它包含两大部分：超文本转移协议和超文本标记语言(HTML)。HTTP、HTML以及浏览器的诞生给互联网的普及带来了飞跃。</li></ul><h1 id="3-HTTP协议的会话方式"><a href="#3-HTTP协议的会话方式" class="headerlink" title="3.    HTTP协议的会话方式"></a>3.    HTTP协议的会话方式</h1><ul><li>浏览器与服务器之间的通信过程要经历四个步骤</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606103412.png" alt></p><ul><li>浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。</li><li>浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。<h1 id="4-HTTP1-0和HTTP1-1的区别"><a href="#4-HTTP1-0和HTTP1-1的区别" class="headerlink" title="4.    HTTP1.0和HTTP1.1的区别"></a>4.    HTTP1.0和HTTP1.1的区别</h1></li><li>在HTTP1.0版本中，浏览器请求一个带有图片的网页，会由于下载图片而与服务器之间开启一个新的连接；但在HTTP1.1版本中，允许浏览器在拿到当前请求对应的全部资源后再断开连接，提高了效率。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606103540.png" alt></p><h1 id="5-HttpWatch"><a href="#5-HttpWatch" class="headerlink" title="5.    HttpWatch"></a>5.    HttpWatch</h1><h2 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h2><ul><li>由于IE8以下的IE浏览器没有提供监听HTTP的功能，所以如果要使用IE8以下的浏览器查看HTTP请求的内容需要安装一个工具HttpWatch。</li><li>Firefox和chrome都有内置的开发者工具，可以直接查看Http请求。</li><li>HttpWatch的使用非常简单，直接安装，然后一直下一步，直到安装完成。</li></ul><h2 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h2><ul><li>安装完成后，打开IE浏览器，工具下拉列表可以看到HttpWatch Professional选项</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606103649.png" alt></p><ul><li>打开后点击Record按钮开始监听Http请求。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606103715.png" alt></p><h1 id="6-报文"><a href="#6-报文" class="headerlink" title="6.    报文"></a>6.    报文</h1><h2 id="6-1-报文格式"><a href="#6-1-报文格式" class="headerlink" title="6.1 报文格式"></a>6.1 报文格式</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606103741.png" alt></p><h2 id="6-2-请求报文"><a href="#6-2-请求报文" class="headerlink" title="6.2 请求报文"></a>6.2 请求报文</h2><h3 id="6-2-1-报文格式"><a href="#6-2-1-报文格式" class="headerlink" title="6.2.1 报文格式"></a>6.2.1 报文格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求首行（请求行）；</span><br><span class="line">请求头信息（请求头）；</span><br><span class="line">空行；</span><br><span class="line">请求体；</span><br></pre></td></tr></table></figure><h3 id="6-2-2-GET请求"><a href="#6-2-2-GET请求" class="headerlink" title="6.2.2 GET请求"></a>6.2.2 GET请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /Hello/index.jsp HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: JSESSIONID=C55836CDA892D9124C03CF8FE8311B15</span><br></pre></td></tr></table></figure><ul><li>GET /Hello/index.jsp HTTP/1.1：GET请求，请求服务器路径为Hello/index.jsp，协议为1.1；</li><li>Host:localhost：请求的主机名为localhost；</li><li>User-Agent: Mozilla/4.0 (compatible; MSIE 8.0…：与浏览器和OS相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取User-Agent头信息而来的；</li><li>Accept: <em>/</em>：告诉服务器，当前客户端可以接收的文档类型， <em>/</em>，就表示什么都可以接收；</li><li>Accept-Language: zh-CN：当前客户端支持的语言，可以在浏览器的工具选项中找到语言相关信息；</li><li>Accept-Encoding: gzip, deflate：支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送；</li><li>Connection: keep-alive：客户端支持的链接方式，保持一段时间链接，默认为3000ms；</li><li>Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98：因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的Cookie在请求中一并发送过去。</li></ul><h3 id="6-2-3-POST请求"><a href="#6-2-3-POST请求" class="headerlink" title="6.2.3 POST请求"></a>6.2.3 POST请求</h3><ul><li>POST请求要求将form标签的method的属性设置为post</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606104102.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /Hello/target.html HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*</span><br><span class="line">Referer: http://localhost:8080/Hello/</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 14</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Cookie: JSESSIONID=774DA38C1B78AE288610D77621590345</span><br><span class="line"></span><br><span class="line">username=admin</span><br></pre></td></tr></table></figure><ul><li>POST请求有请求体，而GET请求没有请求体。</li><li>Referer: <a href="http://localhost:8080/hello/index.jsp：请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:http://www.baidu.com；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了；" target="_blank" rel="noopener">http://localhost:8080/hello/index.jsp：请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:http://www.baidu.com；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了；</a></li><li>Content-Type: application/x-www-form-urlencoded：表单的数据类型，说明会使用url格式编码数据；url编码的数据都是以“%”为前缀，后面跟随两位的16进制，例如“传智”这两个字使用UTF-8的url编码用为“%E4%BC%A0%E6%99%BA”；</li><li>Content-Length:13：请求体的长度，这里表示13个字节。</li><li>keyword=hello：请求体内容！hello是在表单中输入的数据，keyword是表单字段的名字。</li></ul><h2 id="6-3-响应报文"><a href="#6-3-响应报文" class="headerlink" title="6.3 响应报文"></a>6.3 响应报文</h2><h3 id="6-3-1-报文格式"><a href="#6-3-1-报文格式" class="headerlink" title="6.3.1 报文格式"></a>6.3.1 报文格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">响应首行（响应行）；</span><br><span class="line">响应头信息（响应头）；</span><br><span class="line">空行；</span><br><span class="line">响应体；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 274</span><br><span class="line">Date: Tue, 07 Apr 2015 10:08:26 GMT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>HTTP/1.1 200 OK：响应协议为HTTP1.1，状态码为200，表示请求成功；</li><li>Server: Apache-Coyote/1.1：服务器的版本信息；</li><li>Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8；</li><li>Content-Length: 274：响应体为274字节；</li><li>Date: Tue, 07 Apr 2015 10:08:26 GMT：响应的时间，这可能会有8小时的时区差；</li></ul><h3 id="6-3-2-响应码"><a href="#6-3-2-响应码" class="headerlink" title="6.3.2 响应码"></a>6.3.2 响应码</h3><p>响应码对浏览器来说很重要，它告诉浏览器响应的结果；</p><ul><li>200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；</li><li>404：请求的资源没有找到，说明客户端错误的请求了不存在的资源；</li><li>500：请求资源找到了，但服务器内部出现了错误；</li><li>302：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-HTTP协议简介&quot;&gt;&lt;a href=&quot;#1-HTTP协议简介&quot; class=&quot;headerlink&quot; title=&quot;1.    HTTP协议简介&quot;&gt;&lt;/a&gt;1.    HTTP协议简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;HTTP 超文本传输协议 (HTTP-Hyper
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>05 web-环境搭建及Tomcat安装、配置、启动.md</title>
    <link href="http://yoursite.com/2017/10/20/24%20web-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8ATomcat%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E5%90%AF%E5%8A%A8.md/"/>
    <id>http://yoursite.com/2017/10/20/24 web-环境搭建及Tomcat安装、配置、启动.md/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2019-06-06T15:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Web服务器"><a href="#1-Web服务器" class="headerlink" title="1.Web服务器"></a>1.Web服务器</h1><ul><li>Web服务器主要用来接收客户端发送的请求和响应客户端请求。</li><li>常见的JavaWeb服务器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tomcat（Apache）：当前应用最广的JavaWeb服务器；</span><br><span class="line">JBoss（Redhat红帽）：支持JavaEE，应用比较广EJB容器 –&gt; SSH轻量级的框架代替</span><br><span class="line">GlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广；</span><br><span class="line">Resin（Caucho）：支持JavaEE，应用越来越广；</span><br><span class="line">Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目；</span><br><span class="line">Websphere（IBM）：要钱的！支持JavaEE，适合大型项目；</span><br></pre></td></tr></table></figure><h1 id="2-Tomcat服务器"><a href="#2-Tomcat服务器" class="headerlink" title="2.Tomcat服务器"></a>2.Tomcat服务器</h1><h2 id="2-1-Tomcat简介"><a href="#2-1-Tomcat简介" class="headerlink" title="2.1 Tomcat简介"></a>2.1 Tomcat简介</h2><ul><li>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。目前最新版本是9.0。我们要用的是7.0。</li></ul><h2 id="2-2-Tomcat安装、配置、启动"><a href="#2-2-Tomcat安装、配置、启动" class="headerlink" title="2.2 Tomcat安装、配置、启动"></a>2.2 Tomcat安装、配置、启动</h2><p>①解压apache-tomcat-6.0.44-windows-x64.zip到非中文无空格目录中</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173314.png" alt></p><ul><li>bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat6.exe、tomcat6w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdown.bat用来停止Tomcat；</li><li>conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：<ul><li>server.xml：配置整个服务器信息。例如修改端口号</li><li>tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；</li><li>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！</li><li>context.xml：对所有应用的统一配置，通常我们不会去配置它。</li></ul></li></ul><ul><li>lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；</li><li>logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。</li><li>temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</li><li>webapps：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。<a href="http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。" target="_blank" rel="noopener">http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。</a></li><li>work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</li><li>LICENSE：许可证。</li><li>NOTICE：说明文件。</li></ul><p>②如果双击startup.bat后窗口一闪而过，请查看JAVA_HOME是否配置正确</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173446.png" alt><br>③新建环境变量CATALINA_HOME=解压目录</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173512.png" alt></p><p>④在Path环境变量中加入Tomcat解压目录\bin目录</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173550.png" alt></p><p>⑤在命令行中运行catalina run或者 startup启动Tomcat服务器，在浏览器地址栏访问如下地址进行测试<br>    <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173611.png" alt></p><p>⑥如果启动失败，提示端口号被占用，则将默认的8080端口修改为其他未使用的值，例如10086等。<br>    打开：解压目录\conf\server.xml，找到第一个Connector标签，修改port属性</p><h2 id="2-3在Eclipse中创建Tomcat镜像"><a href="#2-3在Eclipse中创建Tomcat镜像" class="headerlink" title="2.3在Eclipse中创建Tomcat镜像"></a>2.3在Eclipse中创建Tomcat镜像</h2><p>①在Servers视窗里点击超链接或在空白处右键→New<br><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173659.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173719.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173753.png" alt></p><p>②创建动态Web工程进行测试</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605173811.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1]在WebContent目录下创建index.jsp，加入如下代码</span><br><span class="line"></span><br><span class="line">    &lt;%@page import=&quot;java.util.Date&quot;%&gt;</span><br><span class="line">&lt;%=new Date() %&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2]在index.jsp上点右键：Run as→Run on Server查看运行结果</span><br></pre></td></tr></table></figure><p>③说明：关联Tomcat镜像时，Eclipse会从本地Tomcat中复制信息及文件，之后二者的配置信息就没有关系了，其中任何一个的配置信息发生变化都不会自动同步到另外一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Web服务器&quot;&gt;&lt;a href=&quot;#1-Web服务器&quot; class=&quot;headerlink&quot; title=&quot;1.Web服务器&quot;&gt;&lt;/a&gt;1.Web服务器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Web服务器主要用来接收客户端发送的请求和响应客户端请求。&lt;/li&gt;
&lt;li&gt;常
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
      <category term="开发环境配置" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>04 web-XML概述</title>
    <link href="http://yoursite.com/2017/10/14/23%20web-XML%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/10/14/23 web-XML概述/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2019-06-06T15:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h1><p>•XML–可扩展标记语言<br>    eXtensible Markup Language<br>•由W3C组织发布，目前推荐遵守的是W3C组织于2000年发布的XML1.0规范<br>•XML的使命，就是以一个统一的格式，组织有关系的数据，为不同平台下的应用程序服务<br>•XML用来传输和存储数据，HTML用来显示数据<br>•XML没有预定义标签，均为自定义标签<br>•XML用途<br>•XML–可扩展标记语言<br>    eXtensible Markup Language<br>•由W3C组织发布，目前推荐遵守的是W3C组织于2000年发布的XML1.0规范<br>•XML的使命，就是以一个统一的格式，组织有关系的数据，为不同平台下的应用程序服务<br>•XML用来传输和存储数据，HTML用来显示数据<br>•XML没有预定义标签，均为自定义标签 </p><h1 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h1><p>①XML声明要么不写，要写就写在第一行，并且前面没有任何其他字符<br>②只能有一个根标签<br>③标签必须正确结束<br>④标签不能交叉嵌套<br>⑤严格区分大小写<br>⑥属性必须有值，且必须加引号<br>⑦标签不能以数字开头<br>⑧注释不能嵌套  </p><h1 id="XML文档组成"><a href="#XML文档组成" class="headerlink" title="XML文档组成"></a>XML文档组成</h1><ul><li>XML声明</li></ul><p>•version属性指定XML版本，固定值是1.0<br>•encoding指定的字符集，是告诉解析器使用什么字符集进行解码，而编码是由文本编辑器决定的</p><ul><li>CDATA区<br>•当XML文档中需要写一些程序代码、SQL语句或其他不希望XML解析器进行解析的内容时，就可以写在CDATA区中<br>•XML解析器会将CDATA区中的内容原封不动的输出<br>•CDATA区的定义格式：&lt;![CDATA[…]]&gt;</li></ul><h1 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h1><p>•XML解析是指通过解析器读取XML文档，解释语法，并将文档转化成对象<br>•对XML的一切操作都是由解析开始的，所以解析非常重要。<br>•Java 平台同时提供了 DOM（Document Object Model）和 SAX（Simple API for XML）。  </p><h2 id="XML解析技术体系"><a href="#XML解析技术体系" class="headerlink" title="XML解析技术体系"></a>XML解析技术体系</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605165437.png" alt></p><h1 id="DOM和SAX对比"><a href="#DOM和SAX对比" class="headerlink" title="DOM和SAX对比"></a>DOM和SAX对比</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605165528.png" alt><br> DOM SAX</p><h1 id="dom4j"><a href="#dom4j" class="headerlink" title="dom4j"></a>dom4j</h1><p>•dom4j是一个开源XML解析包<br>•dom4j是一个非常优秀的Java XML API，具有性能优异、功能强大和极易使用的特点。现在很多软件都采用dom4j，例如Hibernate。<br>•使用dom4j开发，需导入dom4j相应的jar包dom4j-1.6.1.jar</p><h2 id="Dom4j解析关键步骤"><a href="#Dom4j解析关键步骤" class="headerlink" title="Dom4j解析关键步骤"></a>Dom4j解析关键步骤</h2><p>•解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建解析器对象</span><br><span class="line">SAXReader saxReader = new SAXReader();</span><br><span class="line">//2.解析xml文件获取document对象</span><br><span class="line">Document document = saxReader.read(&quot;students.xml&quot;);</span><br><span class="line">//3.得到根元素</span><br><span class="line">Element root = document.getRootElement();</span><br><span class="line">•修改</span><br><span class="line">//添加一个新的student节点</span><br><span class="line">Element newEle = rootElement.addElement(&quot;student&quot;);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建解析器</span><br><span class="line">    SAXReader reader = new SAXReader();</span><br><span class="line">    //将.xml文件解析为document对象</span><br><span class="line">Document document = reader.read(&quot;students.xml&quot;);</span><br><span class="line">//通过Document对象获取跟元素</span><br><span class="line">Element rootElement = document.getRootElement();</span><br><span class="line">//通过跟元素，遍历子元素</span><br><span class="line">List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line">for (Element element : elements) &#123;</span><br><span class="line">//获取元素的属性值</span><br><span class="line">String id = element.attributeValue(&quot;id&quot;);</span><br><span class="line">//获取子元素的文本值</span><br><span class="line">String name = element.elementText(&quot;name&quot;);</span><br><span class="line">String age = element.elementText(&quot;age&quot;);</span><br><span class="line">Student stu = new Student(id, name, age);</span><br><span class="line">System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (DocumentException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Xpath查询"><a href="#Xpath查询" class="headerlink" title="Xpath查询"></a>Xpath查询</h1><p>•XPath 是在 XML 文档中查找信息的语言<br>•XPath通过元素和属性进行查找，简化了Dom4j查找节点的过程，是W3C组织发布的标准。<br>•使用XPath必须导入jaxen-1.1-beta-6.jar包<br>•具体语法见 XPathTutorial(菜鸟必备)<br>•两个重要方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.selectSingleNode(&quot;/students/student[@id=&apos;1&apos;]&quot;)</span><br><span class="line">document.selectNodes(&quot;/students/student&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XML简介&quot;&gt;&lt;a href=&quot;#XML简介&quot; class=&quot;headerlink&quot; title=&quot;XML简介&quot;&gt;&lt;/a&gt;XML简介&lt;/h1&gt;&lt;p&gt;•XML–可扩展标记语言&lt;br&gt;    eXtensible Markup Language&lt;br&gt;•由W3C组织发
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>03 web-jQuery基础</title>
    <link href="http://yoursite.com/2017/10/10/22%20jQuery%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/10/10/22 jQuery基础/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2019-06-06T15:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605155605.png" alt></p><h1 id="1-jQuery简介"><a href="#1-jQuery简介" class="headerlink" title="1. jQuery简介"></a>1. jQuery简介</h1><ul><li>为了简化 JavaScript 的开发, 一些 JavsScript 库诞生了. JavaScript库封装了很多预定义的对象和实用函数。能帮助使用者建立有高难度交互的页面, 并且兼容各大浏览器</li><li>当前流行的 JavaScript 库有</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605155508.png" alt></p><ul><li>jQuery是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS,DO MORE。优势如下:<ul><li>轻量级(压缩后只有几十k)</li><li><strong>强大的选择器</strong></li><li><strong>出色的 DOM 操作的封装</strong></li><li><strong>可靠的事件处理机制</strong></li><li>完善的 Ajax</li><li>出色的浏览器兼容性</li><li><strong>隐式迭代：对集合对象做相同操作时不需要逐个进行遍历，jQuery自动进行遍历</strong><br>文档说明很全<br>可扩展插件</li></ul></li></ul><h1 id="2-jQuery快速入门"><a href="#2-jQuery快速入门" class="headerlink" title="2. jQuery快速入门"></a>2. jQuery快速入门</h1><h2 id="2-1-将jQuery的库文件加入应用"><a href="#2-1-将jQuery的库文件加入应用" class="headerlink" title="2.1. 将jQuery的库文件加入应用"></a>2.1. 将jQuery的库文件加入应用</h2><ul><li>在开发测试时, 用的是未压缩的版本: jquery-1.7.2.js</li><li>在上线项目中, 会使用压缩后的版本: jquery-1.7.2.min.js</li></ul><h2 id="2-2-HelloWorld"><a href="#2-2-HelloWorld" class="headerlink" title="2.2. HelloWorld"></a>2.2. HelloWorld</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入jQuery库--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;/&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//调用jQuery库定义的函数</span><br><span class="line">$(function()&#123;</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">alert(&quot;Hello&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="3-Jquery语法详解"><a href="#3-Jquery语法详解" class="headerlink" title="3. Jquery语法详解"></a>3. Jquery语法详解</h1><h2 id="3-1-jQuery源码初分析"><a href="#3-1-jQuery源码初分析" class="headerlink" title="3.1. jQuery源码初分析"></a>3.1. jQuery源码初分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(function( window, undefined ) &#123;//16行</span><br><span class="line"></span><br><span class="line">var jQuery = (function() &#123;//22行</span><br><span class="line"></span><br><span class="line">var jQuery = function( selector, context ) &#123;</span><br><span class="line">// The jQuery object is actually just the init constructor &apos;enhanced&apos;</span><br><span class="line">return new jQuery.fn.init( selector, context, rootjQuery );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;//97行</span><br><span class="line">constructor: jQuery,</span><br><span class="line">init: function( selector, context, rootjQuery ) &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;//207行</span><br><span class="line"></span><br><span class="line">&#125;;//319行</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">return jQuery;//981行</span><br><span class="line"></span><br><span class="line">&#125;)();//983行</span><br><span class="line"></span><br><span class="line">// Expose jQuery to the global object</span><br><span class="line">window.jQuery = window.$ = jQuery;//9384行</span><br><span class="line"></span><br><span class="line">&#125;)( window );//9404行</span><br></pre></td></tr></table></figure><p>说明: </p><ul><li>自执行函数</li><li>给window添加了两个等同的函数: jQuery()/$()</li><li>执行$()后,返回的是一个jQuery库包装的对象, 一般称之为:jQuery对象</li></ul><h2 id="3-2-核心"><a href="#3-2-核心" class="headerlink" title="3.2. 核心"></a>3.2. 核心</h2><h3 id="1-jQuery核心函数"><a href="#1-jQuery核心函数" class="headerlink" title="1).  jQuery核心函数: $()"></a>1).  jQuery核心函数: $()</h3><ul><li>jQuery库中为window对象定义了一个$函数(方法)  jQuery()</li><li>$函数会根据参数数据类型的不同做不同的工作, 返回一个jQuery封装的伪数组的对象</li></ul><h4 id="1-1-callback"><a href="#1-1-callback" class="headerlink" title="1.1). $(callback)"></a>1.1). $(callback)</h4><ul><li>传入一个function参数, 作为回调函数</li><li>在DOM文档载入完成后, 回调函数自动执行</li><li>这个函数的作用如同$(document).ready(callback)一样</li><li>它与window.onload是有区别的</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160044.png" alt></p><ul><li>源码聚焦</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160103.png" alt></p><h4 id="1-2-selector"><a href="#1-2-selector" class="headerlink" title="1.2). $(selector)"></a>1.2). $(selector)</h4><ul><li>接收一个CSS选择器格式的字符串参数</li><li>根据此字符串在document中去匹配一组元素, 并封装成jQuery对象返回</li></ul><p>源码聚焦</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160138.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160158.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160250.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160403.png" alt></p><h4 id="1-3-domEle"><a href="#1-3-domEle" class="headerlink" title="1.3). $(domEle)"></a>1.3). $(domEle)</h4><ul><li>接收一个DOM对象类型的参数</li><li>返回包含这个dom对象的jQuery对象<ul><li>[注意：如果声明一个变量指向jQuery对象，那么这个变量习惯上要以$开头。这就是jQuery对象的命名规范。]</li></ul></li></ul><ul><li>jQuery对象只能调用jQuery封装的方法</li><li>DOM对象只能调用DOM中所定义的方法</li></ul><p>源码聚焦</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605160552.png" alt></p><ul><li>DOM对象和jQuery对象的互相转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①DOM对象转jQuery对象</span><br><span class="line">使用jQuery核心函数包装DOM对象：$(btnEle)</span><br><span class="line">②jQuery对象转DOM对象</span><br><span class="line">[1]使用数组下标：$btn[0]</span><br><span class="line">[2]使用get(index)方法：$btn.get(0)</span><br></pre></td></tr></table></figure><h4 id="1-4-htmlString"><a href="#1-4-htmlString" class="headerlink" title="1.4). $(htmlString)"></a>1.4). $(htmlString)</h4><ul><li>接收一个标签字符串参数</li><li>创建对应的标签对象, 并包装成jQuery对象</li><li>如: $(“<div><p>Hello</p></div>“)</li></ul><h3 id="2-jQuery对象访问"><a href="#2-jQuery对象访问" class="headerlink" title="2).  jQuery对象访问"></a>2).  jQuery对象访问</h3><h4 id="2-1-each-callback"><a href="#2-1-each-callback" class="headerlink" title="2.1).each(callback)"></a>2.1).each(callback)</h4><ul><li>callback函数:  function (index, domEle)  </li><li>遍历jQuery对象中包含的所有DOM对象, 每拿到一个dom对象都会调用指定的回调函数, 并将下标和dom对象传入</li></ul><h4 id="2-2-text"><a href="#2-2-text" class="headerlink" title="2.2).text()"></a>2.2).text()</h4><ul><li>text() 得到元素节点对象的文本内容。</li><li>text(str) 设置元素的文本内容</li></ul><h4 id="2-3-attr"><a href="#2-3-attr" class="headerlink" title="2.3).attr()"></a>2.3).attr()</h4><ul><li>attr(属性名) 返回“属性名”对应的属性值</li><li>attr(属性名,属性值) 将“属性名”对应的属性设置为“属性值”</li></ul><h4 id="2-4-val"><a href="#2-4-val" class="headerlink" title="2.4).val()"></a>2.4).val()</h4><ul><li>val() 读取value属性</li><li>val(value值) 设置value属性</li><li>val([选项值1,选项值2,…,选项值n]) 设置单选框、多选框或下拉列表被选中的值</li></ul><h2 id="3-3-选择器-同css"><a href="#3-3-选择器-同css" class="headerlink" title="3.3. 选择器(同css)"></a>3.3. 选择器(同css)</h2><ul><li>jQuery最牛的地方就是其强大的选择器, 使用其选择器基本可以快速轻松的找到页面的任意节点</li><li>jquery的选择器分类<ul><li>基本选择器</li><li>层次选择器</li><li>过滤选择器</li><li>基本</li><li>内容</li><li>可见</li><li>属性</li><li>子元素</li><li>表单</li><li>表单属性</li></ul></li></ul><h3 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1). 基本选择器"></a>1). 基本选择器</h3><ul><li>基本选择器是jquery中最简单，也是最常用的选择器</li><li>它通过标签名,id属性,class属性来查找匹配的DOM元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.1)id选择器    </span><br><span class="line">用法:$(‘#id’)</span><br><span class="line">返回值：根据id属性匹配一个标签, 封装成jQuery对象</span><br><span class="line"></span><br><span class="line">1.2)标签选择器</span><br><span class="line">用法:  $(‘tagName’) </span><br><span class="line">返回值：根据标签名匹配的一个或多个标签, 封装成jQuery对象</span><br><span class="line"></span><br><span class="line">1.3)class选择器</span><br><span class="line">用法:  $(‘.class’) </span><br><span class="line">返回值：根据class属性值匹配一个或多个标签, 封装成jQuery对象</span><br><span class="line"></span><br><span class="line">1.4)*选择器</span><br><span class="line">用法:  $(*)  </span><br><span class="line">返回值: 匹配所有标签, 封装成jQuery对象</span><br><span class="line"></span><br><span class="line">1.5)selector1,selector2,…</span><br><span class="line">用法:  $(”div,span,.myClass”)    </span><br><span class="line">返回值: 所有匹配选择器的标签, 封装成jQuery对象</span><br></pre></td></tr></table></figure><h3 id="2-层次选择器"><a href="#2-层次选择器" class="headerlink" title="2). 层次选择器"></a>2). 层次选择器</h3><ul><li>如果想通过DOM元素之间的层次关系来获取特定元素。例如子元素、兄弟元素等。则需要通过层次选择器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2.1). ancestor descendant</span><br><span class="line">用法:$(”form input”)</span><br><span class="line">说明:在给定的祖先元素下匹配所有后代元素</span><br><span class="line">2.2)parent &gt; child</span><br><span class="line">用法: $(”form &gt; input”) </span><br><span class="line">说明: 在指定父元素下匹配所有子元素.注意:要区分好后代元素与子元素</span><br><span class="line">2.3)prev + next</span><br><span class="line">用法: $(”label + input”) </span><br><span class="line">说明: 匹配所有紧接在prev元素后的next元素</span><br><span class="line">2.4)prev ~ siblings</span><br><span class="line">用法: $(”form ~ input”) </span><br><span class="line">说明: 匹配prev元素之后的所有 siblings元素, 不包含该元素在内,</span><br><span class="line">    并且siblings匹配的是和prev同辈的元素,其后辈元素不被匹配.</span><br></pre></td></tr></table></figure><h3 id="3-基本过滤选择器"><a href="#3-基本过滤选择器" class="headerlink" title="3). 基本过滤选择器"></a>3). 基本过滤选择器</h3><ul><li>过滤选择器主要是通过特定的过滤规则来筛选出所需的DOM元素, 该选择器都以 “:”开头</li><li>按照不同的过滤规则, 过滤选择器可以分为基本过滤, 内容过滤, 可见性过滤, 属性过滤, 子元素过滤, 表单过滤和表单属性过滤选择器.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">3.1). :first</span><br><span class="line">用法: $(”tr:first”) ;   </span><br><span class="line">说明: 匹配找到的第一个元素</span><br><span class="line"></span><br><span class="line">3.2). :last</span><br><span class="line">用法: $(”tr:last”)  </span><br><span class="line">说明: 匹配找到的最后一个元素.与 :first 相对应</span><br><span class="line"></span><br><span class="line">3.3). :not(selector)</span><br><span class="line">用法: $(”input:not(:checked)”)</span><br><span class="line">说明: 去除所有与给定选择器匹配的元素.有点类似于”非”,</span><br><span class="line">    意思是没有被选中的input(当input的type=”checkbox”).</span><br><span class="line"></span><br><span class="line">3.4). :even</span><br><span class="line">用法: $(”tr:even”)   </span><br><span class="line">说明: 匹配所有索引值为偶数的元素，从0开始计数.js的数组都是从0开始计数的.</span><br><span class="line"></span><br><span class="line">3.5). :odd</span><br><span class="line">用法: $(”tr:odd”) </span><br><span class="line">说明: 匹配所有索引值为奇数的元素,和:even对应,从 0 开始计数.</span><br><span class="line"></span><br><span class="line">3.6). :eq(index)</span><br><span class="line">用法: $(”tr:eq(0)”)   </span><br><span class="line">说明: 匹配一个给定索引值的元素.eq(0)就是获取第一个tr元素.</span><br><span class="line">    括号里面的是索引值,不是元素排列数.</span><br><span class="line"></span><br><span class="line">3.7). :gt(index)</span><br><span class="line">用法: $(”tr:gt(0)”)  </span><br><span class="line">说明: 匹配所有大于给定索引值的元素.</span><br><span class="line"></span><br><span class="line">3.8). :lt(index)</span><br><span class="line">用法: $(”tr:lt(2)”)    </span><br><span class="line">说明: 匹配所有小于给定索引值的元素.</span><br></pre></td></tr></table></figure><h3 id="4-内容过滤选择器"><a href="#4-内容过滤选择器" class="headerlink" title="4). 内容过滤选择器"></a>4). 内容过滤选择器</h3><ul><li>内容过滤选择器的过滤规则主要体现在它所包含的子元素和文本内容上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4.1).  :contains(text)</span><br><span class="line">用法: $(”div:contains(’John’)”)  </span><br><span class="line">说明: 匹配包含给定文本的元素.这个选择器比较有用，当我们要选择的不是dom标签元素时,</span><br><span class="line">    它就派上了用场了,它的作用是查找被标签”围”起来的文本内容是否符合指定的内容的.</span><br><span class="line"></span><br><span class="line">4.2).  :empty</span><br><span class="line">用法: $(”td:empty”) </span><br><span class="line">说明: 匹配所有不包含子元素或者文本的空元素</span><br><span class="line"></span><br><span class="line">4.3).  :has(selector)</span><br><span class="line">用法: $(”div:has(p)”).addClass(”test”)</span><br><span class="line">说明: 匹配含有选择器所匹配的元素的元素.这个解释需要好好琢磨,但是一旦看了使用的例子就完全清楚了:</span><br><span class="line">给所有包含p元素的div标签加上class=”test”.</span><br><span class="line"></span><br><span class="line">4.4). :parent</span><br><span class="line">用法: $(”td:parent”) </span><br><span class="line">说明: 匹配含有子元素或者文本的元素.注意:这里是”:parent”,</span><br><span class="line">    可不是”.parent”哦!感觉与上面讲的”:empty”形成反义词.</span><br></pre></td></tr></table></figure><h3 id="5-可见过滤选择器"><a href="#5-可见过滤选择器" class="headerlink" title="5). 可见过滤选择器"></a>5). 可见过滤选择器</h3><ul><li>根据元素的可见和不可见状态来选择相应的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5.1).  :hidden</span><br><span class="line">用法: $(”tr:hidden”) </span><br><span class="line">说明: 匹配所有的不可见元素，input 元素的 type 属性为 “hidden” 的话也会被匹配到.</span><br><span class="line">    意思是css中display:none和input type=”hidden”的都会被匹配到.</span><br><span class="line">    同样,要在脑海中彻底分清楚冒号”:”, 点号”.”和逗号”,”的区别. </span><br><span class="line"></span><br><span class="line">5.2).  :visible</span><br><span class="line">用法: $(”tr:visible”)  </span><br><span class="line">说明: 匹配所有的可见元素.</span><br></pre></td></tr></table></figure><h3 id="6-属性过滤选择器"><a href="#6-属性过滤选择器" class="headerlink" title="6). 属性过滤选择器"></a>6). 属性过滤选择器</h3><ul><li>属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">6.1). [attribute]</span><br><span class="line">用法: $(”div[id]“) </span><br><span class="line">说明: 匹配包含给定属性的元素. 例子中是选取了所有带id属性的div标签.</span><br><span class="line"></span><br><span class="line">6.2). [attribute=value]</span><br><span class="line">用法: $(”input[name=&apos;newsletter&apos;]“).attr(”checked”, true)</span><br><span class="line">说明: 匹配给定的属性是某个特定值的元素.例子中选取了所有name属性是newsletter的 input 元素.</span><br><span class="line"></span><br><span class="line">6.3). [attribute!=value]</span><br><span class="line">用法: $(”input[name!=&apos;newsletter&apos;]“).attr(”checked”, true)。   </span><br><span class="line">说明：匹配所有不含有指定的属性，或者属性不等于特定值的元素.此选择器等价于:not([attr=value]),</span><br><span class="line">    要匹配含有特定属性但不等于特定值的元素,请使用[attr]:not([attr=value]).</span><br><span class="line">    之前看到的 :not 派上了用场.</span><br><span class="line"></span><br><span class="line">6.4). [attribute^=value]</span><br><span class="line">用法: $(”input[name^=‘news’]“)</span><br><span class="line">说明: 匹配给定的属性是以某些值开始的元素.</span><br><span class="line"></span><br><span class="line">6.5). [attribute$=value]</span><br><span class="line">用法: $(”input[name$=‘letter’]“)</span><br><span class="line">说明: 匹配给定的属性是以某些值结尾的元素.</span><br><span class="line"></span><br><span class="line">6.6). [attribute*=value]</span><br><span class="line">用法: $(”input[name*=‘man’]“)</span><br><span class="line">说明: 匹配给定的属性是以包含某些值的元素.</span><br></pre></td></tr></table></figure><h3 id="7-子元素过滤选择器"><a href="#7-子元素过滤选择器" class="headerlink" title="7). 子元素过滤选择器"></a>7). 子元素过滤选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">7.1). :nth-child(index/even/odd/equation)</span><br><span class="line">用法: $(”ul li:nth-child(2)”) </span><br><span class="line">说明: 匹配其父元素下的第N个子或奇偶元素.这个选择器和之前说的基础过滤(Basic Filters)中的 </span><br><span class="line">    eq() 有些类似,不同的地方就是前者是从0开始,后者是从1开始.</span><br><span class="line"></span><br><span class="line">7.2). :first-child</span><br><span class="line">用法: $(”ul li:first-child”) </span><br><span class="line">说明: 匹配第一个子元素.’:first’ 只匹配一个元素,而此选择符将为每个父元素匹配一个子元素.</span><br><span class="line">    这里需要特别的记忆一下区别.</span><br><span class="line"></span><br><span class="line">7.3). :last-child</span><br><span class="line">用法: $(”ul li:last-child”)</span><br><span class="line">说明: 匹配最后一个子元素.’:last’只匹配一个元素,而此选择符将为每个父元素匹配一个子元素.</span><br><span class="line"></span><br><span class="line">7.4). : only-child</span><br><span class="line">用法: $(”ul li:only-child”)</span><br><span class="line">说明: 如果某个元素是父元素中唯一的子元素,那将会被匹配.如果父元素中含有其他元素,</span><br><span class="line">    那将不会被匹配.意思就是:只有一个子元素的才会被匹配!</span><br></pre></td></tr></table></figure><h3 id="8-表单选择器"><a href="#8-表单选择器" class="headerlink" title="8). 表单选择器"></a>8). 表单选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">8.1). :input</span><br><span class="line">用法: $(”:input”)  </span><br><span class="line">说明:匹配所有 text, textarea, select 和 button 元素 </span><br><span class="line"></span><br><span class="line">8.2). :text</span><br><span class="line">用法: $(”:text”) </span><br><span class="line">说明: 匹配所有的单行文本框.</span><br><span class="line"></span><br><span class="line">8.3). :password</span><br><span class="line">用法: $(”:password”) </span><br><span class="line">说明: 匹配所有密码框.</span><br><span class="line"></span><br><span class="line">8.4). :radio</span><br><span class="line">用法: $(”:radio”) </span><br><span class="line">说明: 匹配所有单选按钮.</span><br><span class="line"></span><br><span class="line">8.5). :checkbox</span><br><span class="line">用法: $(”:checkbox”) </span><br><span class="line">说明: 匹配所有复选框</span><br><span class="line"></span><br><span class="line">8.6). :submit</span><br><span class="line">用法: $(”:submit”) </span><br><span class="line">说明: 匹配所有提交按钮</span><br><span class="line"></span><br><span class="line">8.7). :image</span><br><span class="line">用法: $(”:image”) </span><br><span class="line">说明: 匹配所有图像域.</span><br><span class="line"></span><br><span class="line">8.8). :reset</span><br><span class="line">用法: $(”:reset”) </span><br><span class="line">说明: 匹配所有重置按钮.</span><br><span class="line"></span><br><span class="line">8.9). :button</span><br><span class="line">用法: $(”:button”) </span><br><span class="line">说明: 匹配所有按钮.这个包括直接写的元素button.</span><br><span class="line"></span><br><span class="line">8.10). :file</span><br><span class="line">用法: $(”:file”) </span><br><span class="line">说明: 匹配所有文件域.</span><br><span class="line"></span><br><span class="line">8.11). :hidden</span><br><span class="line">用法: $(”input:hidden”) </span><br><span class="line">说明: 匹配所有不可见元素，或者type为hidden的元素.这个选择器就不仅限于表单了,</span><br><span class="line">除了匹配input中的hidden外,那些style为hidden的也会被匹配.</span><br></pre></td></tr></table></figure><h3 id="9-表单对象属性过滤选择器"><a href="#9-表单对象属性过滤选择器" class="headerlink" title="9). 表单对象属性过滤选择器"></a>9). 表单对象属性过滤选择器</h3><ul><li>此选择器主要对所选择的表单元素进行过滤</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">9.1). :enabled</span><br><span class="line">用法: $(”input:enabled”)</span><br><span class="line">说明: 匹配所有可用元素.意思是查找所有input中不带有disabled=”disabled”的input.</span><br><span class="line">    不为disabled,当然就为enabled啦.</span><br><span class="line"></span><br><span class="line">9.2). :disabled</span><br><span class="line">用法: $(”input:disabled”)</span><br><span class="line">说明: 匹配所有不可用元素.与上面的那个是相对应的. </span><br><span class="line"></span><br><span class="line">9.3). :checked</span><br><span class="line">用法: $(”input:checked”)</span><br><span class="line">说明: 匹配所有被选中的元素(复选框、单选框等，不包括select中的option).</span><br><span class="line"></span><br><span class="line">9.4). :selected</span><br><span class="line">用法: $(”select option:selected”)</span><br><span class="line">说明: 匹配所有选中的option元素.</span><br></pre></td></tr></table></figure><h2 id="3-4-文档处理-CRUD"><a href="#3-4-文档处理-CRUD" class="headerlink" title="3.4.    文档处理(CRUD)"></a>3.4.    文档处理(CRUD)</h2><h3 id="1-内部插入节点"><a href="#1-内部插入节点" class="headerlink" title="1). 内部插入节点"></a>1). 内部插入节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.1). append(content) </span><br><span class="line">    向每个匹配的元素的内部的结尾处追加内容</span><br><span class="line"></span><br><span class="line">1.2). appendTo(content) </span><br><span class="line">    把所有匹配的元素追加到另一个指定的元素集合中</span><br><span class="line"></span><br><span class="line">1.3). prepend(content)</span><br><span class="line">    向每个匹配的元素的内部的开始处插入内容</span><br><span class="line"></span><br><span class="line">1.4). prependTo(content) </span><br><span class="line">    将每个匹配的元素插入到指定的元素内部的开始处</span><br></pre></td></tr></table></figure><h3 id="2-外部插入节点"><a href="#2-外部插入节点" class="headerlink" title="2). 外部插入节点"></a>2). 外部插入节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.1). after(content) :</span><br><span class="line">     在每个匹配的元素之后插入内容 </span><br><span class="line"></span><br><span class="line">2.2). before(content)</span><br><span class="line">     在每个匹配的元素之前插入内容 </span><br><span class="line"></span><br><span class="line">2.3). insertAfter(content)</span><br><span class="line">     把所有匹配的元素插入到另一个、指定的元素集合的后面 </span><br><span class="line"></span><br><span class="line">2.4). insertBefore(content) </span><br><span class="line">     把所有匹配的元素插入到另一个、指定的元素集合的前面</span><br></pre></td></tr></table></figure><h3 id="3-查找节点"><a href="#3-查找节点" class="headerlink" title="3).查找节点"></a>3).查找节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3.1). 使用jQuery选择器查询</span><br><span class="line">     $(selector) </span><br><span class="line">     得到一个包含所有匹配的dom节点对象的jQuery对象</span><br><span class="line"></span><br><span class="line">3.2). 查询jQuery对象内部数据</span><br><span class="line">    $object.find(selector)</span><br><span class="line">    在Jquery对象中根据selector查找其中匹配的后代节点</span><br><span class="line"></span><br><span class="line">3.3). 遍历jQuery对象包含的数据</span><br><span class="line">    $(selector1).each(function(index, itemDom)&#123; &#125;)</span><br><span class="line">     遍历jQuery对象所包含的所有节点, 每取一个dom节点对象都去调用设置的回调函数,</span><br><span class="line">     并将取出的节点在数组中的下标和节点对象传入函数</span><br></pre></td></tr></table></figure><h3 id="4-创建节点"><a href="#4-创建节点" class="headerlink" title="4).创建节点"></a>4).创建节点</h3><ul><li>$(htmlString).</li><li>动态创建的新元素节点不会被自动添加到文档中, 需要使用其他方法将其插入到文档中; </li><li>当创建单个元素时, 需注意闭合标签和使用标准的 XHTML 格式. 例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建一个&lt;p&gt;元素, 可以使用 $(“&lt;p/&gt;”) 或 $(“&lt;p&gt;&lt;/p&gt;”),</span><br><span class="line">但不能使用 $(“&lt;p&gt;”) 或 $(“&lt;/P&gt;”)</span><br></pre></td></tr></table></figure><ul><li>创建文本节点就是在创建元素节点时直接把文本内容写出来; 创建属性节点也是在创建元素节点时一起创建</li></ul><h3 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5). 删除节点"></a>5). 删除节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5.1). empty():</span><br><span class="line"> 删除匹配的元素集合中所有的子节点(不包括本身)。</span><br><span class="line"></span><br><span class="line">5.2). remove(): </span><br><span class="line">  删除匹配的元素及其子元素(包括本身)</span><br></pre></td></tr></table></figure><h3 id="6-属性操作"><a href="#6-属性操作" class="headerlink" title="6). 属性操作"></a>6). 属性操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6.1). attr(name ,[value])</span><br><span class="line"> 根据属性名获取属性值或者设置一个属性</span><br><span class="line"></span><br><span class="line">6.2).  removeAttr(name)</span><br><span class="line"> 根据属性名删除对应的属性</span><br></pre></td></tr></table></figure><h3 id="7-HTML代码-值"><a href="#7-HTML代码-值" class="headerlink" title="7). HTML代码/值"></a>7). HTML代码/值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7.1). html([val])</span><br><span class="line"> 得到元素的内容或者设置元素的内容</span><br><span class="line"></span><br><span class="line">7.2). val([value])</span><br><span class="line"> 获得匹配元素的当前值或者设置其值</span><br></pre></td></tr></table></figure><h3 id="8-CSS"><a href="#8-CSS" class="headerlink" title="8) CSS"></a>8) CSS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8.1). addClass(className)</span><br><span class="line"> 添加class属性</span><br><span class="line"></span><br><span class="line">8.2). removeClass()</span><br><span class="line"> 移除class属性</span><br><span class="line"></span><br><span class="line">8.3). css(name,[value])</span><br><span class="line">   查看某个样式属性, 或设置某个样式属性</span><br></pre></td></tr></table></figure><h2 id="3-5-事件"><a href="#3-5-事件" class="headerlink" title="3.5.    事件"></a>3.5.    事件</h2><h3 id="1-常用的事件"><a href="#1-常用的事件" class="headerlink" title="1)    常用的事件"></a>1)    常用的事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.1). ready(fn)</span><br><span class="line"> 当DOM载入就绪可以查询及操纵时绑定一个要执行的函数</span><br><span class="line"> 它与window.onload是有区别的</span><br></pre></td></tr></table></figure><p><img src="http://note.youdao.com/yws/res/8509/D3F766EB738F48099517319C8880017D" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.2). click([fn]) </span><br><span class="line"> 触发每一个匹配元素的click事件</span><br><span class="line"></span><br><span class="line">1.3). blur([fn]) </span><br><span class="line"> 触发每一个匹配元素的blur事件</span><br><span class="line"></span><br><span class="line">1.4). change([fn]) </span><br><span class="line"> 触发每一个匹配元素的change事件</span><br></pre></td></tr></table></figure><h3 id="2-绑定与解绑事件"><a href="#2-绑定与解绑事件" class="headerlink" title="2)    绑定与解绑事件"></a>2)    绑定与解绑事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1). bind(type, fn)</span><br><span class="line"> 为每个匹配元素的特定事件绑定事件处理函数。</span><br><span class="line"></span><br><span class="line">2.2).  unbind(type)</span><br><span class="line"> bind()的反向操作，从每一个匹配的元素中删除绑定的事件</span><br></pre></td></tr></table></figure><h3 id="3-事件切换"><a href="#3-事件切换" class="headerlink" title="3)    事件切换"></a>3)    事件切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1). hover(over,out)</span><br></pre></td></tr></table></figure><ul><li>当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。</li></ul><h3 id="4-事件冒泡"><a href="#4-事件冒泡" class="headerlink" title="4)    事件冒泡"></a>4)    事件冒泡</h3><ul><li>描述: 事件会按照 DOM     <ul><li>层次结构像水泡一样不断向上只止顶端</li></ul></li></ul><ul><li>解决: 在事件处理函数中返回 false, 会对事件停止冒泡</li></ul><h2 id="3-6-效果"><a href="#3-6-效果" class="headerlink" title="3.6.    效果"></a>3.6.    效果</h2><h3 id="1-基本"><a href="#1-基本" class="headerlink" title="1)    基本"></a>1)    基本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.1)show()</span><br><span class="line">显示当前标签</span><br><span class="line">1.2)hide()</span><br><span class="line">隐藏当前标签</span><br><span class="line">1.3)toggle()</span><br><span class="line">切换当前标签的可见性</span><br></pre></td></tr></table></figure><h3 id="2-滑动"><a href="#2-滑动" class="headerlink" title="2)    滑动"></a>2)    滑动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.1). slideDown()</span><br><span class="line">这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来</span><br><span class="line">2.2). slideUp()</span><br><span class="line">这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏起来</span><br><span class="line">2.3). slideToggle()</span><br><span class="line">通过高度变化来切换所有匹配元素的可见性</span><br></pre></td></tr></table></figure><h3 id="3-淡入淡出"><a href="#3-淡入淡出" class="headerlink" title="3)    淡入淡出"></a>3)    淡入淡出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.1). fadeIn()</span><br><span class="line">通过不透明度的变化来实现所有匹配元素的淡入效果</span><br><span class="line">3.2). fadeOut()</span><br><span class="line">通过不透明度的变化来实现所有匹配元素的淡出效果</span><br><span class="line">3.3). fadeToggle()</span><br><span class="line">通过不透明度的变化来开关所有匹配元素的淡入和淡出效果</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习路线&quot;&gt;&lt;a href=&quot;#学习路线&quot; class=&quot;headerlink&quot; title=&quot;学习路线&quot;&gt;&lt;/a&gt;学习路线&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SomnambulistOfChin
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>02 web-JavaScript</title>
    <link href="http://yoursite.com/2017/10/06/21%20JavaScript%20/"/>
    <id>http://yoursite.com/2017/10/06/21 JavaScript /</id>
    <published>2017-10-05T16:00:00.000Z</published>
    <updated>2019-06-06T15:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1    JavaScript简介"></a>1    JavaScript简介</h1><h2 id="1-1-起源"><a href="#1-1-起源" class="headerlink" title="1.1    起源"></a>1.1    起源</h2><blockquote><p>在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。Netscape在最初将其脚本语言命名为LiveScript，因为Netscape与Sun合作，网景公司管理层希望它外观看起来像Java，因此取名为JavaScript。</p></blockquote><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2    特性"></a>1.2    特性</h2><p> ①脚本语言。JavaScript是一种解释型的脚本语言,C、C++、Java等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。<br> ②基于对象。JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也    能使用现有的对象。<br> ③简单。JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言。<br> ④动态性。JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务    器就可以对用户的输入做出响应。<br> ⑤跨平台性。JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用,前提是机器上的浏览器支持JavaScript脚本语言,目前JavaScript已被大多数的浏览器所支持。  </p><h1 id="2-JavaScript基本语法"><a href="#2-JavaScript基本语法" class="headerlink" title="2    JavaScript基本语法"></a>2    JavaScript基本语法</h1><h2 id="2-1-编写位置"><a href="#2-1-编写位置" class="headerlink" title="2.1    编写位置"></a>2.1    编写位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① 编写到HTML中&lt;script&gt;标签中。</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">②写在外部的.js文件中。然后通过script标签引入。</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2    变量"></a>2.2    变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①变量的声明</span><br><span class="line">[1]变量声明时不需要指定类型，可以为其赋值任何类型的数据。</span><br><span class="line">[2]JavaScript严格区分大小写，Num和num是完全不同的两个变量。</span><br><span class="line">②变量的使用：变量在使用过程中可以接受不同类型的值。</span><br></pre></td></tr></table></figure><h2 id="2-3-函数"><a href="#2-3-函数" class="headerlink" title="2.3    函数"></a>2.3    函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">①函数声明</span><br><span class="line">[1]使用function关键字</span><br><span class="line">[2]不需要指定形参类型</span><br><span class="line">[3]不需要指定返回值</span><br><span class="line">function sum(n, m) &#123;</span><br><span class="line">return n + m;</span><br><span class="line">&#125;</span><br><span class="line">②函数调用</span><br><span class="line">调用JavaScript函数时系统不检查传入参数的个数和类型。</span><br><span class="line">③函数也是对象</span><br><span class="line">在JavaScript中，函数也作为一种数据类型存在，而且是引用数据类型，函数名就是指向其内存空间地址的引用。</span><br><span class="line">var a = function() &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125;;</span><br><span class="line">var b = a;</span><br><span class="line">a.fname = &quot;tom&quot;;</span><br><span class="line">alert(b.fname); //结果为tom</span><br><span class="line">④函数的执行</span><br><span class="line">   函数名 + ( )。</span><br><span class="line">var a = function() &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125;;</span><br><span class="line">alert(a());//结果为2</span><br></pre></td></tr></table></figure><h2 id="2-4-对象"><a href="#2-4-对象" class="headerlink" title="2.4    对象"></a>2.4    对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">①对象的创建</span><br><span class="line">    第一种，使用new Object()创建</span><br><span class="line">        var obj = new Object();</span><br><span class="line">    第二种，使用&#123;&#125;创建</span><br><span class="line">        var obj = &#123;&#125;;</span><br><span class="line">②为对象添加属性</span><br><span class="line"> 第一种，通过 对象.属性名 = “属性值” 添加</span><br><span class="line">        obj.name = &quot;zhangsan&quot;;</span><br><span class="line">        obj.age = 12;</span><br><span class="line">        obj.sum = function(a,b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">        &#125;</span><br><span class="line"> 第二种，使用&#123;&#125;创建对象时，直接向对象中添加属性</span><br><span class="line">        var obj = &#123;&quot;name&quot; : &quot;zhangsan&quot;,</span><br><span class="line">        &quot;age&quot; : 21,</span><br><span class="line">        &quot;sum&quot; : function(a,b)&#123; return a+b;&#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h2 id="2-5-this关键字"><a href="#2-5-this关键字" class="headerlink" title="2.5    this关键字"></a>2.5    this关键字</h2><p>在JavaScript函数中，this关键字指向的是调用当前函数的对象。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   var obj01 = &#123;</span><br><span class="line">name : &quot;obj01 name&quot;,</span><br><span class="line">getName : showName</span><br><span class="line">&#125;;</span><br><span class="line">var obj02 = &#123;</span><br><span class="line">name : &quot;obj02 name&quot;,</span><br><span class="line">getName : showName</span><br><span class="line">&#125;;</span><br><span class="line">function showName() &#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">obj01.getName();//结果为 obj01 name</span><br><span class="line">obj02.getName();//结果为 obj02 name</span><br></pre></td></tr></table></figure><h1 id="3-JavaScript事件驱动"><a href="#3-JavaScript事件驱动" class="headerlink" title="3    JavaScript事件驱动"></a>3    JavaScript事件驱动</h1><h2 id="3-1-事件"><a href="#3-1-事件" class="headerlink" title="3.1    事件"></a>3.1    事件</h2><p>①用户事件：用户操作，例如单击、鼠标移入、鼠标移出等。<br>②系统事件：由系统触发的事件，例如文档加载完成。</p><h2 id="3-2-自定义事件响应函数"><a href="#3-2-自定义事件响应函数" class="headerlink" title="3.2    自定义事件响应函数"></a>3.2    自定义事件响应函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①从文档对象模型中获取控件对象[借助DOM API实现]</span><br><span class="line">②声明一个事件响应函数</span><br><span class="line">③将事件响应函数的引用赋值给控件对象的事件属性</span><br><span class="line">  例如：window.onload = function()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-取消控件默认行为"><a href="#3-3-取消控件默认行为" class="headerlink" title="3.3    取消控件默认行为"></a>3.3    取消控件默认行为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①默认行为</span><br><span class="line">[1]超链接跳转页面</span><br><span class="line">[2]submit按钮提交表单</span><br><span class="line">②取消方式：return false</span><br></pre></td></tr></table></figure><h1 id="4-JavaScript嵌入方式"><a href="#4-JavaScript嵌入方式" class="headerlink" title="4    JavaScript嵌入方式"></a>4    JavaScript嵌入方式</h1><h2 id="4-1-浏览器加载顺序"><a href="#4-1-浏览器加载顺序" class="headerlink" title="4.1    浏览器加载顺序"></a>4.1    浏览器加载顺序</h2><p>①按从上到下的顺序加载<br>②遇到script标签先执行脚本程序，执行完成后再继续加载  </p><h2 id="4-2-嵌入HTML标签的事件属性中"><a href="#4-2-嵌入HTML标签的事件属性中" class="headerlink" title="4.2    嵌入HTML标签的事件属性中"></a>4.2    嵌入HTML标签的事件属性中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&apos;hello&apos;);&quot;&gt;点我&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>结构与行为耦合，不推荐使用</p><h2 id="4-3-嵌入head标签内"><a href="#4-3-嵌入head标签内" class="headerlink" title="4.3    嵌入head标签内"></a>4.3    嵌入head标签内</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var btnEle = document.getElementById(&quot;btn&quot;);</span><br><span class="line">btnEle.onclick = function() &#123;</span><br><span class="line">alert(&quot;hello&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>无法获取body标签中的节点</p><h2 id="4-4-嵌入body标签后面"><a href="#4-4-嵌入body标签后面" class="headerlink" title="4.4    嵌入body标签后面"></a>4.4    嵌入body标签后面</h2><pre><code>可以获取节点，但是不符合常规习惯</code></pre><h2 id="4-5-window对象"><a href="#4-5-window对象" class="headerlink" title="4.5    window对象"></a>4.5    window对象</h2><p>代表当前浏览器窗口</p><h2 id="4-6-onload事件"><a href="#4-6-onload事件" class="headerlink" title="4.6    onload事件"></a>4.6    onload事件</h2><pre><code>将整个文档加载完成后触发</code></pre><h2 id="4-7-使用window-onload完美解决问题"><a href="#4-7-使用window-onload完美解决问题" class="headerlink" title="4.7    使用window.onload完美解决问题"></a>4.7    使用window.onload完美解决问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">var btnEle = document.getElementById(&quot;btn&quot;);</span><br><span class="line">btnEle.onclick = function() &#123;</span><br><span class="line">alert(&quot;hello&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h1 id="5-DOM"><a href="#5-DOM" class="headerlink" title="5    DOM"></a>5    DOM</h1><h2 id="5-1-DOM标准"><a href="#5-1-DOM标准" class="headerlink" title="5.1    DOM标准"></a>5.1    DOM标准</h2><p>Document Object Model：文档对象模型 定义了访问和处理 HTML 文档的标准方         法。是W3C国际组织制定的统一标准，在很多计算机语言中都有不同实现如C#、PHP、    Java、Ruby、perl、python等</p><h2 id="5-2-document对象"><a href="#5-2-document对象" class="headerlink" title="5.2    document对象"></a>5.2    document对象</h2><p>window对象的一个属性，代表当前HTML文档，包含了整个文档的树形结构。获    取document对象的本质方法是：window.document，而“window.”可以省略。<br>5.3    DOM树</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605154557.png" alt> </p><ul><li>父元素：直接包含当前元素的元素就是当前元素的父元素</li><li>子元素：当前元素直接包含的元素就是当前元素的子元素</li><li>祖先元素：直接或间接包含当前元素的所有元素都是当前元素的祖先元素</li><li>后代元素：当前元素直接或间接包含的元素就是当前元素的后代元素</li><li>兄弟元素：有相同父元素的元素是兄弟元素</li></ul><h2 id="5-4-节点-Node"><a href="#5-4-节点-Node" class="headerlink" title="5.4    节点(Node)"></a>5.4    节点(Node)</h2><h3 id="5-4-1-HTML文档中的每个成分都是一个节点，HTML文档是由DOM节点构成的集合。"><a href="#5-4-1-HTML文档中的每个成分都是一个节点，HTML文档是由DOM节点构成的集合。" class="headerlink" title="5.4.1    HTML文档中的每个成分都是一个节点，HTML文档是由DOM节点构成的集合。"></a>5.4.1    HTML文档中的每个成分都是一个节点，HTML文档是由DOM节点构成的集合。</h3><h3 id="5-4-2-节点的分类"><a href="#5-4-2-节点的分类" class="headerlink" title="5.4.2    节点的分类"></a>5.4.2    节点的分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①文档节点(Document)：</span><br><span class="line">    DOM标准将整个HTML文档的相关信息封装后得到的对象。  </span><br><span class="line">②元素节点(Element)：</span><br><span class="line">    DOM标准将HTML标签的相关信息封装后得到的对象。  </span><br><span class="line">③属性节点(Attribute)：</span><br><span class="line">    DOM标准将HTML标签属性的相关信息封装后得到的对象。  </span><br><span class="line">④文本节点(Text)：</span><br><span class="line">    DOM标准将HTML文本的相关信息封装后得到的对象。</span><br></pre></td></tr></table></figure><h3 id="5-4-3-节点的属性"><a href="#5-4-3-节点的属性" class="headerlink" title="5.4.3    节点的属性"></a>5.4.3    节点的属性</h3><p>①    nodeName: 代表当前节点的名字，只读属性。如果给定节点是一个文本节点，nodeName 属性将返回内容为 #text 的字符串。<br>②    nodeType：返回一个整数, 这个数值代表着给定节点的类型，只读属性。  1 – 元素节点    2 – 属性节点    3 – 文本节点<br>③    nodeValue：返回给定节点的当前值(字符串)，可读写的属性。<br>1)    元素节点, 返回值是 null<br>2)    属性节点: 返回值是这个属性的值<br>3)    文本节点: 返回值是这个文本节点的内容  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605154746.png" alt></p><p>5.5    DOM查询API<br>①元素查询</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605154847.png" alt></p><p>②属性操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1]读取属性值</span><br><span class="line">    元素对象.属性名</span><br><span class="line">[2]修改属性值</span><br><span class="line">    元素对象.属性名=新的属性值</span><br></pre></td></tr></table></figure><p>③文本操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]读取文本值：element.firstChild.nodeValue</span><br><span class="line">[2]修改文本值：element.firstChild.nodeValue=新文本值</span><br></pre></td></tr></table></figure><p>5.6    DOM增删改API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">API                                         功能</span><br><span class="line">document.createElement(“标签名”)    创建元素节点并返回，但不会自动添加到文档中</span><br><span class="line">document.createTextNode(“文本值”)   创建文本节点并返回，但不会自动添加到文档中</span><br><span class="line"></span><br><span class="line">element.appendChild(ele)                    将ele添加到element所有子节点后面</span><br><span class="line">parentEle.insertBefore(newEle,targetEle)    将newEle插入到targetEle前面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parentEle.replaceChild(newEle, oldEle)     用新节点替换原有的旧子节点</span><br><span class="line">parentEle.removeChild(childNode)            删除指定的子节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">element.innerHTML                       读写HTML代码</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JavaScript简介&quot;&gt;&lt;a href=&quot;#1-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;1    JavaScript简介&quot;&gt;&lt;/a&gt;1    JavaScript简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-起源&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>01 web-HTML基础</title>
    <link href="http://yoursite.com/2017/10/01/20%20HTML%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/10/01/20 HTML基础/</id>
    <published>2017-09-30T16:00:00.000Z</published>
    <updated>2019-06-06T15:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h1><p>•结构(HTML)<br>HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。<br>•表现(CSS)SS)<br>•CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。<br>•行为, JavaScript, JQuery<br>JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有购物网站中图片的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的.  </p><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><ul><li>HTML 是用来描述网页的一种语言。</li><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li><li>【超文本】就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li><li>标记语言是一套标记标签 (markup tag)</li><li>HTML 使用标记标签来描述网页</li></ul><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605151610.png" alt></p><h2 id="html文件的结构"><a href="#html文件的结构" class="headerlink" title="html文件的结构"></a>html文件的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;html&gt;&lt;/html&gt;为HTML页面中的根标签，</span><br><span class="line">    所有的HTML网页中的标签都在&lt;html&gt;&lt;/html&gt;中。  </span><br><span class="line">2.&lt;head&gt;标签用于定义文档的头部，它是所有头部元素的容器。</span><br><span class="line">    头部元素有&lt;title&gt;、&lt;script&gt;、 &lt;style&gt;、&lt;link&gt;、 &lt;meta&gt;等标签。  </span><br><span class="line">3.在&lt;body&gt;和&lt;/body&gt;标签之间的内容是网页的主要内容，</span><br><span class="line">    如&lt;h1&gt;、&lt;p&gt;、&lt;a&gt;、&lt;img&gt;等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。</span><br></pre></td></tr></table></figure><h2 id="标签的语法"><a href="#标签的语法" class="headerlink" title="标签的语法"></a>标签的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.标签由英文尖括号 &lt; 和 &gt; 括起来,如：&lt;html&gt;</span><br><span class="line">2.html中的标签一般都是成对出现的,分开始标签和结束标签。结束标签比开始标签多一个 / ,</span><br><span class="line">    &lt;title&gt;..&lt;/title&gt;;还有一些是自结束标签，如：&lt;br/&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">3.标签不区分大小写</span><br><span class="line">&lt;div&gt;i am div&lt;/div&gt;</span><br><span class="line">&lt;DIV&gt;I AM DIV&lt;/DIV&gt;</span><br><span class="line"></span><br><span class="line">4.标签与标签之间是可以嵌套的，但先后顺序必须保持一致，</span><br><span class="line">    如：&lt;div&gt;里嵌套&lt;p&gt;，那么&lt;/p&gt;必须放在&lt;/div&gt;的前面。</span><br><span class="line">    注意：HTML有一定的容错能力。</span><br><span class="line">&lt;div&gt;div&lt;h2&gt;h2&lt;/div&gt;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">5.标签必须正确关闭</span><br><span class="line">&lt;div&gt;i am div&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">6.属性必须有值，且属性值必须加引号 --&gt;</span><br><span class="line">&lt;div id=&quot;divId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">7.注释是不可以嵌套的,如：&lt;!-- &lt;!-- 注释部分 --&gt; --&gt;</span><br><span class="line">&lt;!-- 注释1&lt;!-- 注释2 --&gt; --&gt;</span><br><span class="line"></span><br><span class="line">8..HTML标签不区分大小写,&lt;h1&gt;和&lt;H1&gt;是一样的,但建议小写。</span><br></pre></td></tr></table></figure><h1 id="HTML的常用标签"><a href="#HTML的常用标签" class="headerlink" title="HTML的常用标签"></a>HTML的常用标签</h1><h2 id="1-标题标签"><a href="#1-标题标签" class="headerlink" title="1.标题标签"></a>1.标题标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法:h1-h6</span><br><span class="line">            &lt;h1&gt;h1&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;h2&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;h3&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;h4&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;h5&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;h6&lt;/h6&gt;</span><br></pre></td></tr></table></figure><h2 id="2-div标签"><a href="#2-div标签" class="headerlink" title="2.div标签"></a>2.div标签</h2><pre><code>语法：div  作用：无实际意义，布局。  </code></pre><p>相当于一个容器,可以把一些独立的逻辑部分(如网页中独立的栏目版块)划分出来,如下图：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605152114.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;上&lt;/div&gt;</span><br><span class="line">&lt;div&gt;中&lt;/div&gt;</span><br><span class="line">&lt;div&gt;下&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="3-段落标签"><a href="#3-段落标签" class="headerlink" title="3.段落标签"></a>3.段落标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    语法：p</span><br><span class="line">特点：换两行</span><br><span class="line">br:换行标签</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&amp;emsp;&amp;emsp;段落标签&lt;/p&gt;</span><br><span class="line">aaa&lt;br&gt;</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><h2 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：&amp;;</span><br><span class="line">常用转义字符</span><br><span class="line">空格：&amp;nbsp;  &amp;emsp;</span><br><span class="line">大于号:&amp;gt;</span><br><span class="line">小于号:&amp;lt;</span><br><span class="line">版权号码:&amp;copy;</span><br></pre></td></tr></table></figure><h2 id="5-无序列表-amp-有序列表"><a href="#5-无序列表-amp-有序列表" class="headerlink" title="5.无序列表&amp;有序列表"></a>5.无序列表&amp;有序列表</h2><h3 id="无序列表语法：unorder-list-ul"><a href="#无序列表语法：unorder-list-ul" class="headerlink" title="无序列表语法：unorder list:ul"></a>无序列表语法：unorder list:ul</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        &lt;ul&gt;</span><br><span class="line">&lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;ul type=&quot;square&quot;&gt;</span><br><span class="line">&lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">&lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">&lt;li&gt;ccc&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h3 id="有序列表语法：order-list-ul"><a href="#有序列表语法：order-list-ul" class="headerlink" title="有序列表语法：order list:ul"></a>有序列表语法：order list:ul</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        &lt;ol&gt;</span><br><span class="line">&lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">&lt;ol type=&quot;i&quot;&gt;</span><br><span class="line">&lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">&lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">&lt;li&gt;ccc&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>#3 图片标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img alt=&quot;&quot; src=&quot;&quot; title=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="使用img标签插入图片"><a href="#使用img标签插入图片" class="headerlink" title="使用img标签插入图片"></a>使用img标签插入图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src:图片路径</span><br><span class="line">alt:图片路径有误时的提示文本</span><br><span class="line">title:鼠标悬停时的提示文本</span><br></pre></td></tr></table></figure><h2 id="路径问题："><a href="#路径问题：" class="headerlink" title="路径问题："></a>路径问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 目标b文件与当前a文件是否在同一包下</span><br><span class="line"> 同包下:直接获取目标b文件</span><br><span class="line">     不在同包:先查询目标文件的父包，再找目标文件。</span><br><span class="line">2. 使用../返回上一级</span><br><span class="line">&lt;img alt=&quot;picture&quot; src=&quot;img/wm.jpg&quot; title=&quot;a&quot; &gt;</span><br></pre></td></tr></table></figure><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接:"></a>超链接:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt;</span><br><span class="line">使用a标签实现超链接功能</span><br><span class="line">href:链接的目标路径</span><br><span class="line">target:以何种方式打开</span><br><span class="line">值为”_self”时在向当前窗口(默认)打开新的网页</span><br><span class="line">      值为”_blank”时在新的窗口打开</span><br><span class="line">&lt;a href=&quot;pages/target.html&quot; target=&quot;_self&quot;&gt;跳转到目标页面！&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="了解-一些强调标签："><a href="#了解-一些强调标签：" class="headerlink" title="(了解)一些强调标签："></a>(了解)一些强调标签：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ü &lt;strong&gt;和&lt;em&gt;标签</span><br><span class="line">         两者在强调的语气上有区别: &lt;em&gt; 表示强调，&lt;strong&gt; 表示更强烈的强调。并且在浏览器中&lt;em&gt; 默认用 斜体 表示，&lt;strong&gt; 用 粗体 表示。</span><br><span class="line">ü&lt;span&gt;标签</span><br><span class="line">         &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。有了它就可以对某段文字里的几个字单独设置样式了。</span><br></pre></td></tr></table></figure><h1 id="HTML中表格的创建"><a href="#HTML中表格的创建" class="headerlink" title="HTML中表格的创建"></a>HTML中表格的创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用table制作表格</span><br><span class="line">* 使用tr制作表格中的行</span><br><span class="line">* 使用td|th制作表格中的单元格</span><br><span class="line">* border=&quot;边框&quot;</span><br><span class="line">* 跨行跨列</span><br><span class="line">* 跨行：rowspan</span><br><span class="line">* 跨列：colspan</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605152805.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">&lt;th&gt;阵营&lt;/th&gt;</span><br><span class="line">&lt;th&gt;职业&lt;/th&gt;</span><br><span class="line">&lt;th&gt;武器&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;刘备&lt;/td&gt;</span><br><span class="line">&lt;td&gt;蜀&lt;/td&gt;</span><br><span class="line">&lt;td&gt;蜀汉集团董事长&lt;/td&gt;</span><br><span class="line">&lt;td&gt;双股剑&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>生活中的表单</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605152913.png" alt></p><p>使用form标签制作表单</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* action=&quot;表单提交的目标地址&quot;</span><br><span class="line">* method:get|post</span><br><span class="line">* input属性</span><br><span class="line">type:表单项的类型</span><br><span class="line">name:表单项的名称（必选，提交数据使用name属性）</span><br><span class="line">value:表单项的值</span><br><span class="line">checked:表单项的默认选中状态</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>input</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">•表单标签：&lt;form action=&quot;&quot;&gt;..&lt;/form&gt;</span><br><span class="line">•文本输入框：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;</span><br><span class="line">•密码输入框：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;</span><br><span class="line">•单选框： &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;提交的值&quot;/&gt;</span><br><span class="line">•多选框：</span><br><span class="line"> &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;提交的值&quot; checked=&quot;checked&quot;/&gt;</span><br><span class="line">•下拉列表：</span><br><span class="line">         &lt;select name=&quot;&quot;&gt;</span><br><span class="line">            &lt;option value=&quot;&quot;&gt;没有value属性时提交的值&lt;/option&gt;</span><br><span class="line">         &lt;/select&gt;</span><br><span class="line">•重置按钮：&lt;input type=&quot;reset&quot;&gt;</span><br><span class="line">•提交按钮：&lt;input type=&quot;submit&quot; value=&quot;修改的按钮的值&quot;&gt;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;success.html&quot;&gt;</span><br><span class="line">用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br/&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;man&quot; checked=&quot;checked&quot;/&gt;男</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;woman&quot;/&gt;女&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">  </span><br><span class="line"> 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot; checked=&quot;checked&quot;/&gt;篮球</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;football&quot;/&gt;足球</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;volleyball&quot;/&gt;排球</span><br><span class="line">  &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">  </span><br><span class="line">喜欢的明星：&lt;select name=&quot;star&quot;&gt;</span><br><span class="line">            &lt;option value=&quot;fbb&quot;&gt;范冰冰&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;zy&quot;&gt;杨颖&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;zzy&quot;&gt;章子怡&lt;/option&gt;</span><br><span class="line">         &lt;/select&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;br/&gt;</span><br><span class="line">         &lt;br/&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot;&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h1 id="css"><a href="#css" class="headerlink" title="_css"></a>_css</h1><h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><pre><code>CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体等。</code></pre><h2 id="CSS代码语法"><a href="#CSS代码语法" class="headerlink" title="CSS代码语法"></a>CSS代码语法</h2><p>1.CSS样式由选择符(选择器)和声明组成，而声明又由属性和值组成，如下所示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 语法：选择器&#123;属性:属性值;属性2:属性值2;&#125;</span><br><span class="line">     当有多条声明时, 中间用英文分号&quot;;&quot;分隔</span><br></pre></td></tr></table></figure><p>2.CSS的样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">①写在标签的style属性中：&lt;p style=“font-size: 30px”&gt;字体大小用px表示&lt;/p&gt;</span><br><span class="line">②写在style标签中(style标签一般写在head标签与title标签之间)：</span><br><span class="line">          </span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;CSS基本语法&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    p&#123;</span><br><span class="line">        color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">    css:cascading style sheets</span><br><span class="line">        * 语法：选择器&#123;属性:属性值;属性2:属性值2;&#125;</span><br><span class="line">        * 选择器</span><br><span class="line">            标签选择器:h2  p</span><br><span class="line">            类选择器</span><br><span class="line">                定义: .类名&#123;&#125;</span><br><span class="line">                调用: class=&quot;类名&quot;</span><br><span class="line">            ID选择器</span><br><span class="line">                定义: #ID名&#123;&#125;</span><br><span class="line">                调用: id=&quot;ID名&quot;</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;师傅领进门，修行在个人&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">  ③引入外部CSS文件：</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="选择器的分类"><a href="#选择器的分类" class="headerlink" title="选择器的分类"></a>选择器的分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①标签选择器：</span><br><span class="line">②类选择器：.class属性值&#123;..&#125;</span><br><span class="line">定义: .类名&#123;&#125;</span><br><span class="line">调用: class=&quot;类名&quot;</span><br><span class="line">  ③ID选择器：#id属性值&#123;..&#125;</span><br><span class="line">定义: #ID名&#123;&#125;</span><br><span class="line">调用: id=&quot;ID名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;CSS选择器&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    h2&#123;</span><br><span class="line">        color:#ff0000;</span><br><span class="line">    &#125;</span><br><span class="line">    .cb&#123;</span><br><span class="line">        color:rgb(0,255,255);</span><br><span class="line">    &#125;</span><br><span class="line">    #cy&#123;</span><br><span class="line">        color:yellow;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;冬夜读书示子聿&lt;/h2&gt;</span><br><span class="line">    &lt;p class=&quot;cb&quot;&gt;宋代•陆游&lt;/p&gt;</span><br><span class="line">    &lt;p class=&quot;cb&quot;&gt;古人学问无遗力&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;少壮工夫老始成&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;纸上得来终觉浅&lt;/p&gt;</span><br><span class="line">    &lt;p id=&quot;cy&quot;&gt;绝知此事要躬行&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="CSS中注释语句"><a href="#CSS中注释语句" class="headerlink" title="CSS中注释语句"></a>CSS中注释语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用/*注释语句*/标明。</span><br></pre></td></tr></table></figure><h2 id="CSS中的颜色"><a href="#CSS中的颜色" class="headerlink" title="CSS中的颜色"></a>CSS中的颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CSS中的颜色用RGB颜色：</span><br><span class="line">红色(red)、绿色(green)、蓝色(blue)——光学三原色表示。</span><br><span class="line"></span><br><span class="line">RGB中每种颜色都用两位十六进制数表示，0表示没有光，</span><br><span class="line">F表示最强的光，并按红、绿、蓝的顺序排列，前面再加上#号。</span><br><span class="line"></span><br><span class="line">例如：#000000黑色；#FFFFFF 白色；#FF0000红色；</span><br><span class="line">   #00FF00绿色；#0000FF蓝色等等。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网页的组成&quot;&gt;&lt;a href=&quot;#网页的组成&quot; class=&quot;headerlink&quot; title=&quot;网页的组成&quot;&gt;&lt;/a&gt;网页的组成&lt;/h1&gt;&lt;p&gt;•结构(HTML)&lt;br&gt;HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>15 web-文件的上传和下载</title>
    <link href="http://yoursite.com/2017/09/25/34%20web-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/09/25/34 web-文件的上传和下载/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2019-06-06T15:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h1><ul><li>文件的上传和下载在web应用中是非常常用，也是非常有用的功能。<ul><li>例如：发送电子邮件时可以同过上传附件发送文件，OA系统中可以通过上传文件来提交公文，社交网站通过上传图片来自定义头像等等。</li><li>例如：下载实际上只要资源放在用户可访问的目录中用户就可以直接通过地址下载，但是一些资源是存放到数据库中的，还有一些资源需要一定权限才能下载，这里就需要我们通过Servlet来完成下载的功能。</li></ul></li></ul><ul><li>可以说上传和下载是每一个web应用都需要具有的一个功能，所以需要我们掌握。</li></ul><h1 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h1><p>文件的上传主要分成两个步骤</p><pre><code>- 用户在页面中选择要上传的文件，然后将请求提交到Servlet- Servlet收到请求，解析用户上传的文件，然后将文件存储到服务器</code></pre><h2 id="创建上传文件的表单"><a href="#创建上传文件的表单" class="headerlink" title="创建上传文件的表单"></a>创建上传文件的表单</h2><h3 id="1-创建一个form表单"><a href="#1-创建一个form表单" class="headerlink" title="1.    创建一个form表单"></a>1.    创建一个form表单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>文件上传的表单和之前的表单类似，但有以下内容需要注意</p><ul><li>表单的method属性必须为post</li><li>表单的enctype属性必须为multipart/form-data</li><li>上传文件的控件是input，type属性为file</li></ul><p>该表单打开后是如下效果：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190606161759.png" alt></p><h3 id="2-编写Servelet。"><a href="#2-编写Servelet。" class="headerlink" title="2.    编写Servelet。"></a>2.    编写Servelet。</h3><ul><li>页面的表单控件创建好以后，选中文件点击上传按钮请求将会提交到指定的Servlet来处理。</li><li>注意：这里不能再像以前的Servlet中那样，通过request.getParamter()来获取请求参数了，当enctype=”multipart/form-data” 时，再使用getParamter()获取到内容永远为空。因为浏览器发送请求的方式已经改变。</li><li>既然以前的方法不能使用了，这里我们必须要引入一个新的工具来解析请求中的参数和文件，这个工具就是commons-fileupload。</li></ul><h2 id="commons-fileupload。"><a href="#commons-fileupload。" class="headerlink" title="commons-fileupload。"></a>commons-fileupload。</h2><ul><li>commons-fileupload是Apache开发的一款专门用来处理上传的工具，它的作用就是可以从request对象中解析出，用户发送的请求参数和上传文件的流。</li><li>commons-fileupload包依赖commons-io，两个包需要同时导入。</li><li>核心类：</li></ul><h3 id="1-DiskFileItemFactory"><a href="#1-DiskFileItemFactory" class="headerlink" title="1.    DiskFileItemFactory"></a>1.    DiskFileItemFactory</h3><ul><li>工厂类，用于创建ServletFileUpload，设置缓存等  </li><li>该类一般直接使用构造器直接创建实例</li><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setSizeThreshold(int sizeThreshold)</span><br><span class="line">   用于设置缓存文件的大小（默认值10kb）</span><br><span class="line">public void setRepository(File repository)</span><br><span class="line">   用于设置缓存文件位置（默认系统缓存目录）</span><br></pre></td></tr></table></figure><h3 id="2-ServletFileUpload"><a href="#2-ServletFileUpload" class="headerlink" title="2.    ServletFileUpload"></a>2.    ServletFileUpload</h3><ul><li>该类用于解析request对象从而获取用户发送的请求参数（包括普通参数和文件参数）</li><li>该类需要调用有参构造器创建实例，构造器中需要一个Di- skFileItemFactory作为参数</li><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;FileItem&gt; parseRequest(HttpServletRequest request)</span><br><span class="line">解析request对象，获取请求参数，返回的是一个List，</span><br><span class="line">List中保存的是一个FileItem对象，一个对象代表一个请求参数。</span><br><span class="line">public void setFileSizeMax(long fileSizeMax)</span><br><span class="line">设置单个文件的大小限制，单位为B</span><br><span class="line">如果上传文件超出限制，会在parseRequest()抛出异常</span><br><span class="line">        FileSizeLimitExceededException。</span><br><span class="line">public void setSizeMax(long sizeMax)</span><br><span class="line">限制请求内容的总大小，单位为B</span><br><span class="line">如果上传文件超出限制，会在parseRequest()抛出异常</span><br><span class="line">    SizeLimitExceededException。</span><br></pre></td></tr></table></figure><h3 id="3-FileItem"><a href="#3-FileItem" class="headerlink" title="3.    FileItem"></a>3.    FileItem</h3><ul><li>该类用于封装用户发送的参数和文件，也就是用户发送来的信息将会被封装成一个FileItem对象，我们通过该对象获取请求参数或上传文件的信息。</li><li>该类不用我们手动创建，由ServletFileItem解析request后返回。</li><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String getFieldName()</span><br><span class="line">获取表单项的名字，也就是input当中的name属性的值。</span><br><span class="line">String getName();</span><br><span class="line">获取上传的文件名，普通的请求参数为null。</span><br><span class="line">String getString(String encoding);</span><br><span class="line">获取内容</span><br><span class="line">    若为文件，将文件的流转换为字符串。</span><br><span class="line">    若为请求参数，则获取请求参数的value。</span><br><span class="line">encoding参数需要指定一个字符集</span><br><span class="line">boolean isFormField();</span><br><span class="line">判断当前的FileItem封装的是普通请求参数，还是一个文件。</span><br><span class="line">    如果为普通参数返回：true</span><br><span class="line">    如果为文件参数返回：false</span><br><span class="line">String getContentType();</span><br><span class="line">获取上传文件的MIME类型</span><br><span class="line">long getSize();</span><br><span class="line">获取内容的大小</span><br></pre></td></tr></table></figure><ul><li>实例代码，创建一个Servlet并在doPost()方法中编写如下代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//创建工厂类</span><br><span class="line">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class="line">//创建请求解析器</span><br><span class="line">ServletFileUpload fileUpload = new ServletFileUpload(factory);</span><br><span class="line">//设置上传单个文件的的大小</span><br><span class="line">fileUpload.setFileSizeMax(1024*1024*3);</span><br><span class="line">//设置上传总文件的大小</span><br><span class="line">fileUpload.setSizeMax(1024*1024*3*10);</span><br><span class="line">//设置响应内容的编码</span><br><span class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//解析请求信息，获取FileItem的集合</span><br><span class="line">List&lt;FileItem&gt; items = fileUpload.parseRequest(request);</span><br><span class="line">//遍历集合</span><br><span class="line">for (FileItem fileItem : items) &#123;</span><br><span class="line">//如果是普通的表单项</span><br><span class="line">if(fileItem.isFormField())&#123;</span><br><span class="line">    //获取参数名</span><br><span class="line">    String fieldName = fileItem.getFieldName();</span><br><span class="line">    //获取参数值</span><br><span class="line">    String value = fileItem.getString(&quot;utf-8&quot;);</span><br><span class="line">    System.out.println(fieldName+&quot; = &quot;+value);</span><br><span class="line">        //如果是文件表单项</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    //获取文件名</span><br><span class="line">    String fileName = fileItem.getName();</span><br><span class="line">    //获取上传路径</span><br><span class="line">    String realPath = getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);</span><br><span class="line">    //检查upload文件夹是否存在，如果不存在则创建</span><br><span class="line">    File f = new File(realPath);</span><br><span class="line">    if(!f.exists())&#123;</span><br><span class="line">    f.mkdir();</span><br><span class="line">    &#125;;</span><br><span class="line">    //为避免重名生成一个uuid作为文件名的前缀</span><br><span class="line">    String prefix = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    //将文件写入到服务器中</span><br><span class="line">    fileItem.write(new File(realPath+&quot;/&quot;+prefix+&quot;_&quot;+fileName));</span><br><span class="line">    //清楚文件缓存</span><br><span class="line">    fileItem.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">if(e instanceof SizeLimitExceededException)&#123;</span><br><span class="line">//文件总大小超出限制</span><br><span class="line">response.getWriter().print(&quot;上传文件的总大小不能超过30M&quot;);</span><br><span class="line">&#125;else if(e instanceof FileSizeLimitExceededException)&#123;</span><br><span class="line">//单个文件大小超出限制</span><br><span class="line">response.getWriter().print(&quot;上传单个文件的大小不能超过3M&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">response.getWriter().print(&quot;上传成功&quot;);</span><br></pre></td></tr></table></figure><h1 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h1><ul><li>文件下载最直接的方法就是把文件直接放到服务器的目录中，用户直接访问该文件就可以直接下载。</li><li>但是实际上这种方式并不一定好用，比如我们在服务器上直接放置一个MP3文件，然后通过浏览器访问该文件的地址，如果是IE浏览器可能就会弹出下载窗口，而如果是FireFox和Chrome则有可能直接播放。再有就是有一些文件我们是不希望用户可以直接访问到的，这是我们就要通过Servlet来完成下载功能。</li><li>下载文件的关键是几点：<br>1     服务器以一个流的形式将文件发送给浏览器。<br>2      发送流的同时还需要设置几个响应头，来告诉浏览器下载的信息。</li><li>具体响应头如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Content-Type</span><br><span class="line">下载文件的MIME类型</span><br><span class="line">可以通过servletContext. getMimeType(String file)获取</span><br><span class="line">也可以直接手动指定</span><br><span class="line">使用response.setContentType(String type);</span><br><span class="line">响应头样式：</span><br><span class="line">    Content-Type: audio/mpeg</span><br><span class="line">Content-Disposition</span><br><span class="line">下载文件的名字，主要作用是提供一个默认的用户名</span><br><span class="line">通过response.setHeader(&quot;Content-Disposition&quot;, disposition)设置</span><br><span class="line">响应头样式：</span><br><span class="line">    Content-Disposition: attachment; filename=xxx.mp3</span><br><span class="line">Content-Length</span><br><span class="line">下载文件的长度，用于设置文件的长处（不必须）</span><br><span class="line">通过response. setContentLength(int len)设置。</span><br><span class="line">设置后样式：</span><br><span class="line">    Content-Length: 3140995</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来需要以输入流的形式读入硬盘上的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream is = new FileInputStream(file);</span><br><span class="line">这个流就是我们一会要发送给浏览器的内容</span><br></pre></td></tr></table></figure><ol start="4"><li>通过response获取一个输出流，并将文件（输入流）通过该流发送给浏览器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取输出流</span><br><span class="line">ServletOutputStream out = response.getOutputStream();</span><br><span class="line">通过输出流向浏览器发送文件（不要忘了关闭输入流）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = new byte[1024];</span><br><span class="line">int len = 0;</span><br><span class="line">while((len=is.read(b))&gt; 0)&#123;</span><br><span class="line">out.write(b, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ul><li>一下步骤都是在同一个Servlet的doGet()方法中编写的</li><li>我所下载的文件是放在WEB-INF下mp3文件夹中的文件</li><li>具体步骤</li></ul><h3 id="1-获取文件的流："><a href="#1-获取文件的流：" class="headerlink" title="1.    获取文件的流："></a>1.    获取文件的流：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String realPath = getServletContext().getRealPath(&quot;/WEB-INF/mp3/中国话.mp3&quot;);</span><br><span class="line">//获取文件的File对象</span><br><span class="line">File file = new File(realPath);</span><br><span class="line">//获取文件的输入流</span><br><span class="line">FileInputStream is = new FileInputStream(file);</span><br></pre></td></tr></table></figure><h3 id="2-获取头信息"><a href="#2-获取头信息" class="headerlink" title="2.    获取头信息"></a>2.    获取头信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取文件的MIME信息</span><br><span class="line">String contentType = getServletContext().getMimeType(realPath);</span><br><span class="line">//设置下载文件的名字</span><br><span class="line">String filename = &quot;zhongguohua.mp3&quot;;</span><br><span class="line">//创建Content-Disposition信息</span><br><span class="line">String disposition = &quot;attachment; filename=&quot;+ filename ;</span><br><span class="line">//获取文件长度</span><br><span class="line">long size = file.length();</span><br></pre></td></tr></table></figure><h3 id="3-设置头信息"><a href="#3-设置头信息" class="headerlink" title="3.    设置头信息"></a>3.    设置头信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置Content-Type</span><br><span class="line">response.setContentType(contentType);</span><br><span class="line">//设置Content-Disposition</span><br><span class="line">response.setHeader(&quot;Content-Disposition&quot;, disposition);</span><br><span class="line">//设置文件长度</span><br><span class="line">response.setContentLength((int)size);</span><br></pre></td></tr></table></figure><h3 id="4-发送文件"><a href="#4-发送文件" class="headerlink" title="4.    发送文件"></a>4.    发送文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//通过response获取输出流，用于向浏览器输出内容</span><br><span class="line">ServletOutputStream out = response.getOutputStream();</span><br><span class="line">//将文件输入流通过输出流输出</span><br><span class="line">byte[] b = new byte[1024];</span><br><span class="line">int len = 0;</span><br><span class="line">while((len=is.read(b))&gt; 0)&#123;</span><br><span class="line">out.write(b, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">//最后不要忘记关闭输入流，输出流由Tomcat自己处理，我们不用手动关闭</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><h2 id="乱码："><a href="#乱码：" class="headerlink" title="乱码："></a>乱码：</h2><ul><li>至此实际上文件下载的主要功能都已经完成。但是还有一个问题我们这里没有体现出来，因为目前我们的文件名使用的是纯英文的，没有乱码问题。这里如果我们要使用中文文件名的话，毫无疑问会出现乱码问题。</li><li>解决此问题的方法很简单，在获取文件名之后为文件名进行编码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename = java.net.URLEncoder.encode(filename,&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure><ul><li>但是注意这里火狐浏览器比较特殊，因为他默认是以BASE64解码的，所以这块如果需要考虑火狐的问题的话还需要特殊处理一下。</li></ul><ol><li>先要获取客户端信息（通过获取请求头中的User-Agent信息）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取客户端信息</span><br><span class="line">String ua = request.getHeader(&quot;User-Agent&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>然后判断浏览器版本，做不同的处理（通过判断头信息中是否包含Firefox字符串来判断浏览器版本）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//判断客户端是否为火狐</span><br><span class="line">if(ua.contains(&quot;Firefox&quot;))&#123;</span><br><span class="line">//若为火狐使用BASE64编码</span><br><span class="line">filename = &quot;=?utf-8?B?&quot;+new BASE64Encoder()</span><br><span class="line">.encode(filename.getBytes(&quot;utf-8&quot;))+&quot;?=&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//否则使用UTF-8</span><br><span class="line">filename = URLEncoder.encode(filename,&quot;utf-8&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件的上传和下载&quot;&gt;&lt;a href=&quot;#文件的上传和下载&quot; class=&quot;headerlink&quot; title=&quot;文件的上传和下载&quot;&gt;&lt;/a&gt;文件的上传和下载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;文件的上传和下载在web应用中是非常常用，也是非常有用的功能。&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>14 web-异步 AJAX</title>
    <link href="http://yoursite.com/2017/09/25/33%20web-%E5%BC%82%E6%AD%A5%20AJAX/"/>
    <id>http://yoursite.com/2017/09/25/33 web-异步 AJAX/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2019-06-06T15:02:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>AJAX 是 Asynchronous JavaScript And XML 的简称。直译为，异步的JS和XML。</li><li>AJAX的实际意义是，不发生页面跳转、异步载入内容并改写页面内容的技术。</li><li>AJAX也可以简单的理解为通过JS向服务器发送请求。</li><li>回调函数</li><li>AJAX这门技术很早就被发明，但是直到2005年被谷歌的大量使用，才在市场中流行起来，可以说Google为AJAX的推广起到到推波助澜的作用。</li></ul><h2 id="同步处理-amp-异步处理："><a href="#同步处理-amp-异步处理：" class="headerlink" title="同步处理&amp;异步处理："></a>同步处理&amp;异步处理：</h2><h3 id="同步处理："><a href="#同步处理：" class="headerlink" title="同步处理："></a>同步处理：</h3><ul><li>AJAX出现之前，我们访问互联网时一般都是同步请求，也就是当我们通过一个页面向服务器发送一个请求时，在服务器响应结束之前，我们的整个页面是不能操作的，也就是直观上来看他是卡主不动的。</li><li>这就带来了非常糟糕的用户体验。首先，同步请求时，用户只能等待服务器的响应，而不能做任何操作。其次，如果请求时间过长可能会给用户一个卡死的感觉。最后，同步请求的最大缺点就是即使整个页面中只有一小部分内容发生改变我们也要刷新整个页面。</li></ul><h3 id="异步处理："><a href="#异步处理：" class="headerlink" title="异步处理："></a>异步处理：</h3><ul><li>而异步处理指的是我们在浏览网页的同时，通过AJAX向服务器发送请求，发送请求的过程中我们浏览网页的行为并不会收到任何影响，甚至主观上感知不到在向服务器发送请求。当服务器正常响应请求后，响应信息会直接发送到AJAX中，AJAX可以根据服务器响应的内容做一些操作。</li><li>使用AJAX的异步请求基本上完美的解决了同步请求带来的问题。首先，发送请求时不会影响到用户的正常访问。其次，即使请求时间过长，用户不会有任何感知。最后，AJAX可以根据服务器的响应信息局部的修改页面，而不需要整个页面刷新。</li></ul><h4 id="同步处理问题；"><a href="#同步处理问题；" class="headerlink" title="同步处理问题；"></a>同步处理问题；</h4><ul><li>请求：发送二次请求时，只能等上次请求响应后，才能执行</li><li>效率：就算我们需要刷新局部，也必须刷新整个页面</li></ul><h4 id="异步解决问题"><a href="#异步解决问题" class="headerlink" title="异步解决问题"></a>异步解决问题</h4><ul><li>请求：aJax请求不会影响其他请求</li><li>效率：局部刷新</li></ul><h1 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h1><ul><li>向服务器发送请求，毫无疑问需要使用Http协议，也就是我们需要通过JS来向服务器发送一个请求报文。这里我们来回顾一下请求报文的格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求首行</span><br><span class="line">请求头</span><br><span class="line">空行</span><br><span class="line">请求体</span><br></pre></td></tr></table></figure><ul><li>这是一个请求报文的格式，那我们如果手动的创建这么一个报文格式来发送给服务器想必是非常麻烦呢，于是浏览器为我们提供了一个XMLHttpRequest对象。</li></ul><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><ul><li>XMLHttpRequest对象是AJAX中非常重要的对象，所有的AJAX操作都是基于该对象的。</li><li>XMLHttpRequest对象用来封装请求报文，我们向服务器发送的请求信息全部都需要封装到该对象中。</li><li>这里需要稍微注意一下，XMLHttpRequest对象并没有成为标准，但是现在的主流浏览器都支持该对象，而一些如IE6的老版本浏览器中的创建方式有一些区别，但是问题不大。</li><li>获取XMLHttpRequest对象：<ul><li>由于浏览器之间的差异，不同浏览器中获取XMLHttpRequest的方式不同，但总的来说一共有三种方式：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">目前主流浏览器都支持</span><br><span class="line">var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;)</span><br><span class="line">IE6支持的方式</span><br><span class="line">var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">IE5.5一下支持的方式</span><br></pre></td></tr></table></figure><ul><li>根据三种不同的方式编写通用方法来获取XMLHttpRequest对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//获取XMLHttpRequest的通用方法</span><br><span class="line">function getXMLHttpRequest()&#123;</span><br><span class="line">var xhr;</span><br><span class="line">try&#123;</span><br><span class="line">//大部分浏览器都支持</span><br><span class="line">xhr = new XMLHttpRequest();</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">//如果不支持，在这里捕获异常并且采用IE6支持的方式</span><br><span class="line">xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">//如果还不支持，在这里捕获异常并采用IE5支持的方式</span><br><span class="line">xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest对象的方法："><a href="#XMLHttpRequest对象的方法：" class="headerlink" title="XMLHttpRequest对象的方法："></a>XMLHttpRequest对象的方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">open(method,url,async)</span><br><span class="line">open()用于设置请求的基本信息，接收三个参数。</span><br><span class="line">        1.method</span><br><span class="line">            请求的方法：get或post</span><br><span class="line">        接收一个字符串</span><br><span class="line">        2.url</span><br><span class="line">        请求的地址，接收一个字符串</span><br><span class="line">        3.Assync</span><br><span class="line">        发送的请求是否为异步请求，接收一个布尔值。</span><br><span class="line">        true 是异步请求</span><br><span class="line">        false 不是异步请求（同步请求）</span><br><span class="line">send(string)</span><br><span class="line">send()用于将请求发送给服务器，可以接收一个参数</span><br><span class="line">        1.string参数</span><br><span class="line">        该参数只在发送post请求时需要。</span><br><span class="line">        string参数用于设置请求体</span><br><span class="line">setRequestHeader(header,value)</span><br><span class="line">用于设置请求头</span><br><span class="line">        1.header参数</span><br><span class="line">        字符串类型，要设置的请求头的名字</span><br><span class="line">        2.value参数</span><br><span class="line">        字符串类型，要设置的请求头的值</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest对象的属性："><a href="#XMLHttpRequest对象的属性：" class="headerlink" title="XMLHttpRequest对象的属性："></a>XMLHttpRequest对象的属性：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">readyState</span><br><span class="line">描述XMLHttpRequest的状态</span><br><span class="line">一共有五种状态分别对应了五个数字：</span><br><span class="line">    0 ：请求尚未初始化，open()尚未被调用</span><br><span class="line">    1 ：服务器连接已建立，send()尚未被调用</span><br><span class="line">    2 ：请求已接收，服务器尚未响应</span><br><span class="line">    3 ：请求已处理，正在接收服务器发送的响应</span><br><span class="line">    4 ：请求已处理完毕，且响应已就绪。</span><br><span class="line">status</span><br><span class="line">请求的响应码</span><br><span class="line">    200 响应成功</span><br><span class="line">    404 页面为找到</span><br><span class="line">    500 服务器内部错误 </span><br><span class="line"></span><br><span class="line">… … … …</span><br><span class="line">onreadystatechange</span><br><span class="line">该属性需要指向一个函数</span><br><span class="line">该函数会在readyState属性发生改变时被调用</span><br><span class="line">responseText</span><br><span class="line">获得字符串形式的响应数据。</span><br><span class="line">responseXML（用的比较少）</span><br><span class="line">获得 XML 形式的响应数据。</span><br></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul><li>使用AJAX发送GET请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获取xhr对象</span><br><span class="line">var xhr = getXMLHttpRequest();</span><br><span class="line">//设置请求信息</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;AjaxServlet?&amp;t=&quot;+Math.random(),true);</span><br><span class="line">//发送请求</span><br><span class="line">xhr.send();</span><br><span class="line">//监听请求状态</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">//当响应完成</span><br><span class="line">if(xhr.readyState == 4)&#123;</span><br><span class="line">//且状态码为200时</span><br><span class="line">if(xhr.status == 200)&#123;</span><br><span class="line">//接收响应信息（文本形式）</span><br><span class="line">var text = xhr.responseText;</span><br><span class="line">//弹出消息</span><br><span class="line">      alert(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个最简单的AJAX代码，向AjaxServlet发送了一个get请求，并且在页面中输出响应的内容</p><ul><li>使用AJAX发送POST请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//获取xhr对象</span><br><span class="line">var xhr = getXMLHttpRequest();</span><br><span class="line">//设置请求信息</span><br><span class="line">xhr.open(&quot;post&quot;,&quot;2.jsp&quot;,true);</span><br><span class="line">//设置请求头</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">//发送请求</span><br><span class="line">xhr.send(&quot;hello=123456&quot;);</span><br><span class="line">//监听请求状态</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">//当响应完成</span><br><span class="line">if(xhr.readyState == 4)&#123;</span><br><span class="line">//且状态码为200时</span><br><span class="line">if(xhr.status == 200)&#123;</span><br><span class="line">//接收响应信息（文本形式）</span><br><span class="line">var text = xhr.responseText;</span><br><span class="line">//弹出消息</span><br><span class="line">alert(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ul><li>上边两个示例返回都是一个字符串，那当我们需要返回一个复杂的数据时，比如说需要返回一个对象时，就需要定义一下数据的格式。</li><li>AJAX一开始使用的时XML的数据格式，XML的数据格式非常简单清晰，容易编写，但是由于XML中包含了过多的标签，以及十分复杂的结构，解析起来也相对复杂，所以目前来讲，AJAX中已经几乎不使用XML来发送数据了。取而代之的是一项新的技术JSON。</li><li>JSON是JavaScript Object Notation 的缩写，是JS提供的一种数据交换格式。</li><li>JSON对象本质上就是一个JS对象，但是这个对象比较特殊，它可以直接转换为字符串，在不同语言中进行传递，通过工具又可以转换为其他语言中的对象。</li><li>例，有如下一个JSON对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;“name”:”sunwukong” , ”age”:18 , ”address”:”beijing” &#125;</span><br><span class="line">这个对象中有三个属性name、age和address</span><br><span class="line">如果将该对象使用单引号引起了，那么他就变成了一个字符串</span><br><span class="line">‘&#123;“name”:”sunwukong” , ”age”:18 , ”address”:”beijing” &#125;’</span><br><span class="line">变成字符串后有一个好处，就是可以在不同语言之间传递。</span><br><span class="line">比如，将JSON作为一个字符串发送给Servlet，在Java中就可以把JSON字符串转换为一个Java对象。</span><br></pre></td></tr></table></figure><h2 id="JSON通过6种数据类型来表示："><a href="#JSON通过6种数据类型来表示：" class="headerlink" title="JSON通过6种数据类型来表示："></a>JSON通过6种数据类型来表示：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">字符串</span><br><span class="line">例子：”字符串”</span><br><span class="line">注意：不能使用单引号</span><br><span class="line">数字：</span><br><span class="line">例子：123.4</span><br><span class="line">布尔值：</span><br><span class="line">例子：true、false</span><br><span class="line">null值:</span><br><span class="line">例子：null</span><br><span class="line">对象</span><br><span class="line">例子：&#123;“name”:”sunwukong”, ”age”:18&#125;</span><br><span class="line">数组</span><br><span class="line">例子：[1,”str”,true]</span><br></pre></td></tr></table></figure><h2 id="在JS中操作JSON"><a href="#在JS中操作JSON" class="headerlink" title="在JS中操作JSON"></a>在JS中操作JSON</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建JSON对象</span><br><span class="line">var json = &#123;“name1”:”value1”,”name2”:”value2” , “name3”:[1,”str”,true]&#125;;</span><br><span class="line">var json = [&#123;“name1”:”value1”&#125;,&#123;“name2”:”value2”&#125;];</span><br><span class="line">JSON对象转换为JSON字符串</span><br><span class="line">JSON.stringify(JSON对象)</span><br><span class="line">JSON字符串转换为JSON对象</span><br><span class="line">JSON.parse(JSON字符串)</span><br></pre></td></tr></table></figure><h2 id="在Java中操作JSON"><a href="#在Java中操作JSON" class="headerlink" title="在Java中操作JSON"></a>在Java中操作JSON</h2><ul><li>在Java中可以从文件中读取JSON字符串，也可以是客户端发送的JSON字符串，所以第一个问题，我们先来看如何将一个JSON字符串转换成一个Java对象。</li><li>首先解析JSON字符串我们需要导入第三方的工具，目前主流的解析JSON的工具大概有三种json-lib、jackson、gson。三种解析工具相比较json-lib的使用复杂，且效率较差。而Jackson和gson解析效率较高。使用简单，这里我们以gson为例讲解。</li><li>Gson是Google公司出品的解析JSON工具，使用简单，解析性能好。</li><li>Gson中解析JSON的核心是Gson的类，解析操作都是通过该类实例进行。</li><li>废话不多说直接上代码。</li></ul><h3 id="解析外部文本文件中的JSON："><a href="#解析外部文本文件中的JSON：" class="headerlink" title="解析外部文本文件中的JSON："></a>解析外部文本文件中的JSON：</h3><h4 id="1-JSON字符串转换为对象"><a href="#1-JSON字符串转换为对象" class="headerlink" title="1.    JSON字符串转换为对象"></a>1.    JSON字符串转换为对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String json = &quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:18&#125;&quot;;</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">//转换为集合</span><br><span class="line">Map&lt;String,Object&gt; stuMap = gson.fromJson(json, Map.class);</span><br><span class="line">//如果编写了相应的类也可以转换为指定对象</span><br><span class="line">Student fromJson = gson.fromJson(json, Student.class);</span><br></pre></td></tr></table></figure><h4 id="2．对象转换为JSON字符串"><a href="#2．对象转换为JSON字符串" class="headerlink" title="2．对象转换为JSON字符串"></a>2．对象转换为JSON字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Student stu = new Student(&quot;李四&quot;, 23);</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">//&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:23&#125;</span><br><span class="line">String json = gson.toJson(stu);</span><br><span class="line"></span><br><span class="line">Map&lt;String , Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;孙悟空&quot;);</span><br><span class="line">map.put(&quot;age&quot;, 30);</span><br><span class="line">//&#123;&quot;age&quot;:30,&quot;name&quot;:&quot;孙悟空&quot;&#125;</span><br><span class="line">String json2 = gson.toJson(map);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();</span><br><span class="line">list.add(new Student(&quot;八戒&quot;, 18));</span><br><span class="line">list.add(new Student(&quot;沙僧&quot;, 28));</span><br><span class="line">list.add(new Student(&quot;唐僧&quot;, 38));</span><br><span class="line">//[&#123;&quot;name&quot;:&quot;八戒&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;沙僧&quot;,&quot;age&quot;:28&#125;,&#123;&quot;name&quot;:&quot;唐僧&quot;,&quot;age&quot;:38&#125;]</span><br><span class="line">String json3 = gson.toJson(list);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;AJAX 是 Asynchronous JavaScript And XML 的简称。直译为，异步的JS和XML。&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb概述" scheme="http://yoursite.com/tags/JavaWeb%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>3. SQL-JDBC</title>
    <link href="http://yoursite.com/2017/09/25/19.%20SQL-JDBC/"/>
    <id>http://yoursite.com/2017/09/25/19. SQL-JDBC/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2019-06-06T09:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li>JDBC直接访问数据库</li><li>JDO技术（Java Data Object）</li><li>第三方O/R工具，如Hibernate, Mybatis 等</li></ul><p>JDBC是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p><h2 id="1、什么是JDBC"><a href="#1、什么是JDBC" class="headerlink" title="1、什么是JDBC"></a>1、什么是JDBC</h2><ul><li>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</li><li>JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115232.png" alt></p><p>现在：</p><p><img src="http://note.youdao.com/yws/res/8061/23E2E85D304744C494F1D83F1FE4483B" alt="image"></p><p>结论：  </p><ul><li>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。</li><li>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</li></ul><h2 id="2、JDBC-API"><a href="#2、JDBC-API" class="headerlink" title="2、JDBC API"></a>2、JDBC API</h2><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115353.png" alt></p><h2 id="3、JDBC程序编写步骤"><a href="#3、JDBC程序编写步骤" class="headerlink" title="3、JDBC程序编写步骤"></a>3、JDBC程序编写步骤</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115428.png" alt></p><h1 id="二、获取数据库连接"><a href="#二、获取数据库连接" class="headerlink" title="二、获取数据库连接"></a>二、获取数据库连接</h1><h3 id="（一）引入JDBC驱动程序"><a href="#（一）引入JDBC驱动程序" class="headerlink" title="（一）引入JDBC驱动程序"></a>（一）引入JDBC驱动程序</h3><p>驱动程序由数据库提供商提供下载。 MySQL的驱动下载地址：<a href="http://dev.mysql.com/downloads/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/</a><br>如何在Java Project项目应用中添加数据库驱动jar：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115616.png" alt></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115718.png" alt></p><h2 id="（二）加载并注册驱动"><a href="#（二）加载并注册驱动" class="headerlink" title="（二）加载并注册驱动"></a>（二）加载并注册驱动</h2><p>加载并注册驱动：</p><ul><li>加载驱动，把驱动类加载到内存</li><li>注册驱动，把驱动类的对象交给DriverManager管理，用于后面创建连接等使用。</li></ul><h3 id="1、Class-forName"><a href="#1、Class-forName" class="headerlink" title="1、Class.forName()"></a>1、Class.forName()</h3><p>因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例，所以可以换一种方式来加载驱动。（即只要想办法让驱动类的这段静态代码块执行即可注册驱动类，而要让这段静态代码块执行，只要让该类被类加载器加载即可）</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115834.png" alt></p><p>调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过反射，加载与注册驱动类，解耦合（不直接依赖）</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><h3 id="2、服务提供者框架"><a href="#2、服务提供者框架" class="headerlink" title="2、服务提供者框架"></a>2、服务提供者框架</h3><p>（例如：JDBC的驱动程序）自动注册（有版本要求）<br>符合JDBC 4.0规范的驱动程序包含了一个文件META-INF/services/java.sql.Driver，在这个文件中提供了JDBC驱动实现的类名。例如：mysql-connector-java-5.1.40-bin.jar文件中就可以找到java.sql.Driver文件，用文本编辑器打开文件就可以看到：com.mysql.jdbc.Driver类。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605115935.png" alt></p><p>JVM的服务提供者框架在启动应用时就会注册服务，例如：MySQL的JDBC驱动就会被注册，而原代码中的Class.forName(“com.mysql.jdbc.Driver”)仍然可以存在，但是不会起作用。<br>但是注意mysql-connector-java-5.0.8-bin.jar版本的jar中没有，如下</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605120032.png" alt></p><h2 id="（三）获取数据库链接"><a href="#（三）获取数据库链接" class="headerlink" title="（三）获取数据库链接"></a>（三）获取数据库链接</h2><p>可以通过 DriverManager 类建立到数据库的连接Connection：<br>DriverManager 试图从已注册的 JDBC 驱动程序集中选择一个适当的驱动程序。</p><ul><li>public static Connection getConnection(String url) </li><li>public static Connection getConnection(String url,String user, String password)</li><li>public static Connection getConnection(String url,Properties info)其中Properties info通常至少应该包括 “user” 和 “password” 属性</li></ul><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由三部分组成，各部分间用冒号分隔。<br>jdbc:&lt;子协议&gt;:&lt;子名称&gt;  </p><ul><li>协议：JDBC URL中的协议总是jdbc </li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息   </li></ul><p>例如：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605120219.png" alt></p><ul><li>MySQL的连接URL编写方式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</span><br><span class="line">jdbc:mysql://localhost:3306/testdb</span><br><span class="line">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</span><br><span class="line"></span><br><span class="line">jdbc:mysql://localhost:3306/testdb?user=root&amp;password=123456</span><br></pre></td></tr></table></figure><ul><li>Oracle9i:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</span><br><span class="line">jdbc:oracle:thin:@localhost:1521:testdb</span><br><span class="line">SQLServer</span><br><span class="line">jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</span><br><span class="line">jdbc:sqlserver://localhost:1433:DatabaseName=testdb</span><br><span class="line">//1、加载与注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">//2、获取数据库连接</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure><h2 id="（四）操作或访问数据库"><a href="#（四）操作或访问数据库" class="headerlink" title="（四）操作或访问数据库"></a>（四）操作或访问数据库</h2><ul><li>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。</li><li>其实一个数据库连接就是一个Socket连接。</li><li>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </span><br><span class="line">    PrepatedStatement：SQL 语句被预编译并存储在此对象中，</span><br><span class="line">                                 然后可以使用此对象多次高效地执行该语句。</span><br><span class="line">        CallableStatement：用于执行 SQL 存储过程</span><br></pre></td></tr></table></figure><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>通过调用 Connection 对象的 createStatement() 方法创建该对象<br>该对象用于执行静态的 SQL 语句，并且返回执行结果<br>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE</span><br><span class="line">ResultSet excuteQuery(String sql)：执行查询操作SELECT</span><br></pre></td></tr></table></figure><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul><li>通过调用 Statement 对象的 excuteQuery() 方法创建该对象</li><li>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现</li><li>ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行</li><li>ResultSet 接口的常用方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean next()</span><br><span class="line">getXxx(String columnLabel)：columnLabel使用 SQL AS 子句指定的列标签。</span><br><span class="line">                            如果未指定 SQL AS 子句，则标签是列名称</span><br><span class="line">getXxx(int index) :索引从1开始</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605141430.png" alt></p><h2 id="（五）释放资源"><a href="#（五）释放资源" class="headerlink" title="（五）释放资源"></a>（五）释放资源</h2><p>Connection、Statement、ResultSet都是应用程序和数据库服务器的连接资源，使用后一定要关闭，可以在finally中关闭<br>演示未关闭后果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.conn;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line">public class TestConnectionClose &#123;</span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">//1、加载与注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">//2、获取数据库连接</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line"></span><br><span class="line">//my.ini中max_connections=10</span><br><span class="line">for (int i = 0; i &lt; 15; i++) &#123;</span><br><span class="line">Connection conn = DriverManager.getConnection(url,&quot;root&quot;, &quot;123456&quot;);</span><br><span class="line">System.out.println(conn);</span><br><span class="line">//没有关闭，资源一直没有释放</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（六）增、删、改、查示例代码"><a href="#（六）增、删、改、查示例代码" class="headerlink" title="（六）增、删、改、查示例代码"></a>（六）增、删、改、查示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">package com.statement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 网络编程：tcp</span><br><span class="line"> * </span><br><span class="line"> * 服务器端：</span><br><span class="line"> * 1、ServerSocket server = new ServerSocket(3306);</span><br><span class="line"> * 2、Socket socket = server.accept();</span><br><span class="line"> * 3、InputStream input = socket.getInputStream();//接收sql，客户端传过来的</span><br><span class="line"> * 4、在服务器执行sql</span><br><span class="line"> * 5、把结果给客户端</span><br><span class="line"> * </span><br><span class="line"> * 客户端：</span><br><span class="line"> * 1、Socket socket = new Socket(服务器的IP地址，3306);</span><br><span class="line"> * 2、传sql</span><br><span class="line"> * 3、OutputStream out = socket.getOutputStream();</span><br><span class="line"> * 4、out.write(sql);</span><br><span class="line"> * 5、接收结果</span><br><span class="line"> * 6、断开连接  out.close();socket.close();</span><br><span class="line"> */</span><br><span class="line">public class TestStatement &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testAdd()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">             String sql = &quot;INSERT INTO t_department(dname,description) VALUES(&apos;财务部&apos;,&apos;负责发钱工作&apos;)&quot;;</span><br><span class="line">int len = st.executeUpdate(sql);//把insert,update,delete都用这个方法</span><br><span class="line"></span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;添加成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;添加失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testUpdate()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        String sql = &quot;UPDATE t_department SET description = &apos;负责发工资、社保、公积金工作&apos; WHERE dname =&apos;财务部&apos;&quot;;</span><br><span class="line">int len = st.executeUpdate(sql);//把insert,update,delete都用这个方法</span><br><span class="line"></span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;修改成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;修改失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testDelete()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">String sql = &quot;DELETE FROM t_department WHERE did =6&quot;;</span><br><span class="line">int len = st.executeUpdate(sql);//把insert,update,delete都用这个方法</span><br><span class="line"></span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;删除成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;删除失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testSelect()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        String sql = &quot;SELECT * FROM t_department&quot;;</span><br><span class="line">ResultSet rs = st.executeQuery(sql);//select语句用query方法</span><br><span class="line">while(rs.next())&#123;//是否有下一行</span><br><span class="line">//取这一行的单元格</span><br><span class="line">int id = rs.getInt(1);</span><br><span class="line">String name = rs.getString(2);</span><br><span class="line">String desc = rs.getString(3);</span><br><span class="line"></span><br><span class="line">System.out.println(id+&quot;\t&quot; + name + &quot;\t&quot; + desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testSelect2()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">String sql = &quot;SELECT did,dname FROM t_department&quot;;</span><br><span class="line">ResultSet rs = st.executeQuery(sql);//select语句用query方法</span><br><span class="line">while(rs.next())&#123;//是否有下一行</span><br><span class="line">//取这一行的单元格</span><br><span class="line">int id = rs.getInt(&quot;did&quot;);</span><br><span class="line">String name = rs.getString(&quot;dname&quot;);</span><br><span class="line">System.out.println(id+&quot;\t&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、PreparedStatement"><a href="#四、PreparedStatement" class="headerlink" title="四、PreparedStatement"></a>四、PreparedStatement</h1><h2 id="1、Statement的不足"><a href="#1、Statement的不足" class="headerlink" title="1、Statement的不足"></a>1、Statement的不足</h2><h3 id="（1）SQL拼接"><a href="#（1）SQL拼接" class="headerlink" title="（1）SQL拼接"></a>（1）SQL拼接</h3><h3 id="（2）SQL注入"><a href="#（2）SQL注入" class="headerlink" title="（2）SQL注入"></a>（2）SQL注入</h3><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement 取代 Statement 就可以了。</p><h3 id="（3）处理Blob类型的数据"><a href="#（3）处理Blob类型的数据" class="headerlink" title="（3）处理Blob类型的数据"></a>（3）处理Blob类型的数据</h3><ul><li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li><li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605141849.png" alt></p><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。<br>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,</span><br><span class="line">  `head_picture` mediumblob,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package com.statement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Statement：</span><br><span class="line"> * 1、SQL拼接</span><br><span class="line"> * 2、SQL注入</span><br><span class="line"> * 3、处理不了Blob类型的数据</span><br><span class="line"> */</span><br><span class="line">public class TestStatementProblem &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void add() throws Exception&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入领导编号：&quot;);</span><br><span class="line">int mid = input.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入部门编号：&quot;);</span><br><span class="line">int did = input.nextInt();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/1221db&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、创建Statement对象</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">//3、编写sql</span><br><span class="line">String sql = &quot;INSERT INTO emp (ename,`mid`,did) VALUES(&apos;&quot; + name+&quot;&apos;,&quot; + mid + &quot;,&quot; + did + &quot;)&quot;;</span><br><span class="line"></span><br><span class="line">//4、执行sql</span><br><span class="line">int update = st.executeUpdate(sql);</span><br><span class="line">System.out.println(update&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">//5、释放资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void select()throws Exception&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/1221db&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、写sql</span><br><span class="line">//孙红雷  &apos; or &apos;1&apos; = &apos;1</span><br><span class="line">String sql = &quot;SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = &apos;&quot; + name + &quot;&apos;&quot;;</span><br><span class="line">System.out.println(sql);</span><br><span class="line">//SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = &apos;孙红雷  &apos; or &apos;1&apos; = &apos;1&apos;</span><br><span class="line"></span><br><span class="line">//3、用Statement执行</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">//4、执行查询sql</span><br><span class="line">ResultSet rs = st.executeQuery(sql);</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">int id = rs.getInt(1);</span><br><span class="line">String ename = rs.getString(2);</span><br><span class="line">String tel = rs.getString(3);</span><br><span class="line">String gender =rs.getString(4);</span><br><span class="line">double salary = rs.getDouble(5);</span><br><span class="line"></span><br><span class="line">System.out.println(id+&quot;\t&quot; + ename + &quot;\t&quot; + tel + &quot;\t&quot; + gender + &quot;\t&quot; +salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5、释放资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">public void testAddBlob()&#123;</span><br><span class="line">String sql = &quot;INSERT INTO `user` (username,`password`,photo)VALUES(&apos;chai&apos;,&apos;123&apos;,没法在String中处理Blob类型的数据);&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、PreparedStatement概述"><a href="#2、PreparedStatement概述" class="headerlink" title="2、PreparedStatement概述"></a>2、PreparedStatement概述</h2><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象<br>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</p><ul><li>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</li><li>ResultSet executeQuery()执行查询，并返回该查询生成的 ResultSet 对象。</li><li>int executeUpdate()：执行更新，包括增、删、该 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">package com.preparedstatement;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * PreparedStatement：是Statement子接口</span><br><span class="line"> * 1、SQL不需要拼接</span><br><span class="line"> * 2、SQL不会出现注入</span><br><span class="line"> * 3、可以处理Blob类型的数据</span><br><span class="line"> * tinyblob：255字节以内</span><br><span class="line"> * blob：65K以内</span><br><span class="line"> * mediumblob:16M以内</span><br><span class="line"> * longblob：4G以内</span><br><span class="line"> * </span><br><span class="line"> * 如果还是报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：</span><br><span class="line"> * max_allowed_packet=16M</span><br><span class="line"> * 注意：修改了my.ini文件，一定要重新启动服务</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class TestPreparedStatement &#123;</span><br><span class="line">@Test</span><br><span class="line">public void add() throws Exception &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入手机号码：&quot;);</span><br><span class="line">String tel = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入性别：&quot;);</span><br><span class="line">String gender = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入薪资：&quot;);</span><br><span class="line">double salary = input.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入部门编号：&quot;);</span><br><span class="line">int did = input.nextInt();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、编写带？的SQL</span><br><span class="line">String sql = &quot;INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">// 3、准备一个PreparedStatement：预编译sql</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);// 对带？的sql进行预编译</span><br><span class="line"></span><br><span class="line">// 4、把?用具体的值进行代替</span><br><span class="line">pst.setString(1, name);</span><br><span class="line">pst.setString(2, tel);</span><br><span class="line">pst.setString(3, gender);</span><br><span class="line">pst.setDouble(4, salary);</span><br><span class="line">pst.setInt(5, did);</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void select() throws Exception &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、编写带?的sql</span><br><span class="line">//孙红雷  &apos; or &apos;1&apos; = &apos;1</span><br><span class="line">String sql = &quot;SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = ?&quot;;</span><br><span class="line"></span><br><span class="line">// 3、把带？的sql语句进行预编译</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">// 4、把？用具体的变量的赋值</span><br><span class="line">pst.setString(1, name);</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">int id = rs.getInt(&quot;eid&quot;);</span><br><span class="line">String ename = rs.getString(&quot;ename&quot;);</span><br><span class="line">String tel = rs.getString(&quot;tel&quot;);</span><br><span class="line">String gender = rs.getString(&quot;gender&quot;);</span><br><span class="line">double salary = rs.getDouble(&quot;salary&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(id + &quot;\t&quot; + ename + &quot;\t&quot; + tel + &quot;\t&quot; + gender + &quot;\t&quot; + salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">rs.close();</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void addBlob() throws Exception &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入用户名：&quot;);</span><br><span class="line">String username = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入密码：&quot;);</span><br><span class="line">String pwd = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请指定照片的路径：&quot;);</span><br><span class="line">String photoPath = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、 INSERT INTO `user` VALUES(NULL,用户名,密码,照片)</span><br><span class="line">String sql = &quot;INSERT INTO `user` (username,`password`,head_picture)VALUES(?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">// 3、准备一个PreparedStatement：预编译sql</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);// 对带？的sql进行预编译</span><br><span class="line"></span><br><span class="line">// 4、对？进行设置</span><br><span class="line">pst.setString(1, username);</span><br><span class="line">pst.setString(2, pwd);</span><br><span class="line">pst.setBlob(3, new FileInputStream(photoPath));</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len &gt; 0 ? &quot;添加成功&quot; : &quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、PreparedStatement-vs-Statement"><a href="#3、PreparedStatement-vs-Statement" class="headerlink" title="3、PreparedStatement vs Statement"></a>3、PreparedStatement vs Statement</h2><ul><li>代码的可读性和可维护性. Statement的sql拼接是个难题。</li><li>PreparedStatement 可以防止 SQL 注入 </li><li>PreparedStatement 可以处理Blob类型的数据</li><li>PreparedStatement 能最大可能提高性能：（Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高）<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li></ul></li></ul><h2 id="4、JDBC-取得数据库自动生成的主键"><a href="#4、JDBC-取得数据库自动生成的主键" class="headerlink" title="4、JDBC 取得数据库自动生成的主键"></a>4、JDBC 取得数据库自动生成的主键</h2><h3 id="获取自增长的键值："><a href="#获取自增长的键值：" class="headerlink" title="获取自增长的键值："></a>获取自增长的键值：</h3><h4 id="（1）在创建PreparedStatement对象时"><a href="#（1）在创建PreparedStatement对象时" class="headerlink" title="（1）在创建PreparedStatement对象时"></a>（1）在创建PreparedStatement对象时</h4><p>原来：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pst = conn.preparedStatement(sql);</span><br></pre></td></tr></table></figure><p>现在：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pst = conn.prepareStatement(orderInsert,Statement.RETURN_GENERATED_KEYS);</span><br></pre></td></tr></table></figure><h4 id="（2）原来执行更新"><a href="#（2）原来执行更新" class="headerlink" title="（2）原来执行更新"></a>（2）原来执行更新</h4><p>原来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int len = pst.executeUpdate();</span><br></pre></td></tr></table></figure><p> 现在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int len = pst.executeUpdate();</span><br><span class="line">ResultSet rs = pst.getGeneratedKeys();</span><br><span class="line">if(rs.next())&#123;</span><br><span class="line"> Object key = rs.getObject(第几列);//获取自增长的键值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.preparedstatement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class TestGenerateKey &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入手机号码：&quot;);</span><br><span class="line">String tel = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入性别：&quot;);</span><br><span class="line">String gender = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入薪资：&quot;);</span><br><span class="line">double salary = input.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;请输入部门编号：&quot;);</span><br><span class="line">int did = input.nextInt();</span><br><span class="line"></span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">//2、编写带？的SQL</span><br><span class="line">String sql = &quot;INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">// 3、准备一个PreparedStatement：预编译sql</span><br><span class="line">//执行添加语句，如果需要获取自增长的键值，那么在此处要告知mysql服务器，在创建PreparedStatement对象时，增加一个参数</span><br><span class="line">//autoGeneratedKeys - 指示是否应该返回自动生成的键的标志，它是 Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS 之一</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"></span><br><span class="line">// 4、把?用具体的值进行代替</span><br><span class="line">pst.setString(1, name);</span><br><span class="line">pst.setString(2, tel);</span><br><span class="line">pst.setString(3, gender);</span><br><span class="line">pst.setDouble(4, salary);</span><br><span class="line">pst.setInt(5, did);</span><br><span class="line"></span><br><span class="line">// 5、执行sql</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">ResultSet rs = pst.getGeneratedKeys();</span><br><span class="line">if(rs.next())&#123;</span><br><span class="line">System.out.println(&quot;新员工编号是：&quot; + rs.getObject(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6、释放资源</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、批处理"><a href="#5、批处理" class="headerlink" title="5、批处理"></a>5、批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。<br>JDBC的批量处理语句包括下面两个方法：</p><ul><li>addBatch()：添加需要批量处理的SQL语句或参数</li><li>executeBatch()：执行批量处理语句；</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><p>注意：<br><strong>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements=true<br>PreparedStatement作批处理插入时使用values（使用value没有效果）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.preparedstatement;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestBatch &#123;</span><br><span class="line">@Test</span><br><span class="line">public void noBatch()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql = &quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;;</span><br><span class="line">        PreparedStatement st = conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;1000; i++)&#123;</span><br><span class="line">        st.setString(1, &quot;测试部门&quot; + i);</span><br><span class="line">        st.setString(2, &quot;测试部门描述&quot;  + i);</span><br><span class="line">        </span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void useBatch()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql = &quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;;</span><br><span class="line">        PreparedStatement st = conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;1000; i++)&#123;</span><br><span class="line">        st.setString(1, &quot;测试部门&quot; + i);</span><br><span class="line">        st.setString(2, &quot;测试部门描述&quot;  + i);</span><br><span class="line">        </span><br><span class="line">        st.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st.executeBatch();</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、事务"><a href="#6、事务" class="headerlink" title="6、事务"></a>6、事务</h2><p>JDBC程序中当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。<br>JDBC程序中为了让多个 SQL 语句作为一个事务执行：（重点）  </p><ul><li>调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</li><li>在其中某个操作失败或出现异常时，调用 rollback(); 方法回滚事务</li><li>若此时 Connection 没有被关闭, 则需要恢复其自动提交状态 setAutoCommit(true);</li></ul><p>注意：<br><strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.transaction;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class TestTransaction &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">//1、连接数据库</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">//设置手动提交</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">String sql1 = &quot;update t_department set description = ? where did = ?&quot;;</span><br><span class="line">PreparedStatement pst1 = conn.prepareStatement(sql1);</span><br><span class="line">pst1.setObject(1, &quot;挣大钱的&quot;);</span><br><span class="line">pst1.setObject(2, 4);</span><br><span class="line">int len1 = pst1.executeUpdate();</span><br><span class="line">System.out.println(len1&gt;0?&quot;更新部门信息成功&quot;:&quot;更新部门信息失败&quot;);</span><br><span class="line">pst1.close();</span><br><span class="line"></span><br><span class="line">String sql2 = &quot;update t_employee set salary = salary + ? where did = ?&quot;;</span><br><span class="line">PreparedStatement pst2 = conn.prepareStatement(sql2);</span><br><span class="line">pst2.setObject(1, 20000);</span><br><span class="line">pst2.setObject(2, 4);</span><br><span class="line">int len2 = pst2.executeUpdate();</span><br><span class="line">System.out.println(len2&gt;0?&quot;更新部门信息成功&quot;:&quot;更新部门信息失败&quot;);</span><br><span class="line">pst2.close();</span><br><span class="line"></span><br><span class="line">conn.commit();</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(conn!=null)&#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(conn!=null)&#123;</span><br><span class="line">//恢复自动提交</span><br><span class="line">conn.setAutoCommit(true);</span><br><span class="line">//释放连接</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、数据库连接池"><a href="#五、数据库连接池" class="headerlink" title="五、数据库连接池"></a>五、数据库连接池</h1><h2 id="1、数据库连接池"><a href="#1、数据库连接池" class="headerlink" title="1、数据库连接池"></a>1、数据库连接池</h2><h3 id="（1）数据库连接池的必要性"><a href="#（1）数据库连接池的必要性" class="headerlink" title="（1）数据库连接池的必要性"></a>（1）数据库连接池的必要性</h3><p>不使用数据库连接池存在的问题:  </p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li>对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。</li><li>这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li></ul><p>为解决传统开发中的数据库连接问题，可以采用<strong>数据库连接池技术（connection pool）</strong>。</p><ul><li>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，<strong>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605142920.png" alt></p><p>数据库连接池技术的优点：  </p><ul><li>资源重用：<ul><li>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li></ul></li></ul><ul><li>更快的系统反应速度<ul><li>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</li></ul></li></ul><ul><li>新的资源分配手段<ul><li>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</li></ul></li></ul><ul><li>统一的连接管理，避免数据库连接泄露<ul><li>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</li></ul></li></ul><h3 id="（2）多种开源的数据库连接池"><a href="#（2）多种开源的数据库连接池" class="headerlink" title="（2）多种开源的数据库连接池"></a>（2）多种开源的数据库连接池</h3><p>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：</p><ul><li>DBCP 是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持</li><li>C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以</li><li>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li>BoneCP 是一个开源组织提供的数据库连接池，速度快</li><li>Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不知道是否有BoneCP快</li></ul><p>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池<br>注意：  </p><ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul><h3 id="（3）Druid（德鲁伊）数据源"><a href="#（3）Druid（德鲁伊）数据源" class="headerlink" title="（3）Druid（德鲁伊）数据源"></a>（3）Druid（德鲁伊）数据源</h3><p> Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605143309.png" alt>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.druid;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line">public class TestDruid &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">initialSize=10</span><br><span class="line">maxActive=20</span><br><span class="line">maxWait=1000</span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605143757.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605143854.png" alt></p><h2 id="2、ThreadLocal"><a href="#2、ThreadLocal" class="headerlink" title="2、ThreadLocal"></a>2、ThreadLocal</h2><ul><li>JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</li><li>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。</span><br><span class="line">2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。</span><br><span class="line">3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。</span><br><span class="line">4、ThreadLocal.initialValue:</span><br><span class="line">ThreadLocal没有被当前线程赋值时或当前线程刚调remove方法后调用get方法，返回此方法值。</span><br></pre></td></tr></table></figure><h2 id="3、封装JDBCTools"><a href="#3、封装JDBCTools" class="headerlink" title="3、封装JDBCTools"></a>3、封装JDBCTools</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.util;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 获取连接或释放连接的工具类</span><br><span class="line"> */</span><br><span class="line">public class JDBCTools &#123;</span><br><span class="line">// 1、数据源,即连接池</span><br><span class="line">private static DataSource dataSource;</span><br><span class="line"></span><br><span class="line">// 2、ThreadLocal对象</span><br><span class="line">private static ThreadLocal&lt;Connection&gt; threadLocal;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//1、读取druip.properties文件</span><br><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(JDBCTools.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line"></span><br><span class="line">//2、连接连接池</span><br><span class="line">dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">//3、创建线程池</span><br><span class="line">threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取连接的方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> * @throws SQLException</span><br><span class="line"> */</span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">// 从当前线程中获取连接</span><br><span class="line">Connection connection = threadLocal.get();</span><br><span class="line">if (connection == null) &#123;</span><br><span class="line">// 从连接池中获取一个连接</span><br><span class="line">try &#123;</span><br><span class="line">connection = dataSource.getConnection();</span><br><span class="line">// 将连接与当前线程绑定</span><br><span class="line">threadLocal.set(connection);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 释放连接的方法</span><br><span class="line"> * </span><br><span class="line"> * @param connection</span><br><span class="line"> */</span><br><span class="line">public static void releaseConnection() &#123;</span><br><span class="line">// 获取当前线程中的连接</span><br><span class="line">Connection connection = threadLocal.get();</span><br><span class="line">if (connection != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">connection.close();</span><br><span class="line">// 将已经关闭的连接从当前线程中移除</span><br><span class="line">threadLocal.remove();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、Apache—DBUtils简介"><a href="#六、Apache—DBUtils简介" class="headerlink" title="六、Apache—DBUtils简介"></a>六、Apache—DBUtils简介</h1><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605144149.png" alt></p><h2 id="1、DbUtils类"><a href="#1、DbUtils类" class="headerlink" title="1、DbUtils类"></a>1、DbUtils类</h2><p>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：</p><ul><li>public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接的事务，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li><li>public static void rollback(Connection conn)throws SQLException允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul><h2 id="2、QueryRunner类"><a href="#2、QueryRunner类" class="headerlink" title="2、QueryRunner类"></a>2、QueryRunner类</h2><p>该类封装了SQL的执行，是线程安全的。</p><ul><li>可以实现增、删、改、查、批处理、</li><li>考虑了事务处理需要共用Connection。</li><li>该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</li></ul><p>QueryRunner类提供了两个构造方法：  </p><ul><li>QueryRunner()：默认的构造方法</li><li>QueryRunner(DataSource ds)：需要一个 javax.sql.DataSource 来作参数的构造方法。</li></ul><h3 id="（1）更新"><a href="#（1）更新" class="headerlink" title="（1）更新"></a>（1）更新</h3><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul><h3 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a>（2）插入</h3><ul><li>public <t> T insert(Connection conn,String sql,ResultSetHandler<t> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</t></t></li><li>….</li></ul><h3 id="（3）批处理"><a href="#（3）批处理" class="headerlink" title="（3）批处理"></a>（3）批处理</h3><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <t> T insertBatch(Connection conn,String sql,ResultSetHandler<t> rsh,Object[][] params)throws SQLException：只支持INSERT语句</t></t></li><li>…..</li></ul><h3 id="（4）使用QueryRunner类实现查询"><a href="#（4）使用QueryRunner类实现查询" class="headerlink" title="（4）使用QueryRunner类实现查询"></a>（4）使用QueryRunner类实现查询</h3><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>……    </li></ul><h2 id="3、ResultSetHandler接口"><a href="#3、ResultSetHandler接口" class="headerlink" title="3、ResultSetHandler接口"></a>3、ResultSetHandler接口</h2><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet  rs)该方法的返回值将作为QueryRunner类的query()方法的返回值。<br>该接口有如下实现类可以使用：  </p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li><li>BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li>BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li><li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li><li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li></ul><h2 id="4、表与JavaBean"><a href="#4、表与JavaBean" class="headerlink" title="4、表与JavaBean"></a>4、表与JavaBean</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605144702.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605144730.png" alt></p><h2 id="5、示例代码"><a href="#5、示例代码" class="headerlink" title="5、示例代码"></a>5、示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.apache.dbutils;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.MapListHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.Book;</span><br><span class="line">import com.atguigu.util.JDBCTools;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">QueryRunner qr = new QueryRunner();</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testUpdate() throws Exception &#123;</span><br><span class="line">Book book = new Book(0, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, 88.8, 0, 200, null);</span><br><span class="line">// 写sql语句</span><br><span class="line">String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;</span><br><span class="line">qr.update(JDBCTools.getConnection(), sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(),</span><br><span class="line">book.getStock(), book.getImgPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws Exception &#123;</span><br><span class="line">Book book = new Book(0, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, 88.8, 0, 200, null);</span><br><span class="line">// 写sql语句</span><br><span class="line">String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;</span><br><span class="line">Long id = qr.insert(JDBCTools.getConnection(), sql, new ScalarHandler&lt;Long&gt;(), book.getTitle(),</span><br><span class="line">book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getImgPath());</span><br><span class="line">System.out.println(&quot;新书编号：&quot; + id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testBatch() throws Exception &#123;</span><br><span class="line">Object[][] params = new Object[2][3];</span><br><span class="line">params[0][0] = 1;</span><br><span class="line">params[0][1] = 1;</span><br><span class="line">params[0][2] = 1;</span><br><span class="line"></span><br><span class="line">params[1][0] = 1;</span><br><span class="line">params[1][1] = 1;</span><br><span class="line">params[1][2] = 2;</span><br><span class="line"></span><br><span class="line">String sql = &quot;update books set sales = sales + ? , stock = stock - ? where id = ?&quot;;</span><br><span class="line">qr.batch(JDBCTools.getConnection(), sql, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetBean() throws Exception &#123;</span><br><span class="line">// 写sql语句</span><br><span class="line">// 当JavaBean的属性名与字段名不一致时，可以通过指定别名告知属性名</span><br><span class="line">String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;</span><br><span class="line">Book b = qr.query(JDBCTools.getConnection(), sql, new BeanHandler&lt;Book&gt;(Book.class), 2);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetBeanList() throws Exception &#123;</span><br><span class="line">// 写sql语句</span><br><span class="line">// 当JavaBean的属性名与字段名不一致时，可以通过指定别名告知属性名</span><br><span class="line">String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? &quot;;</span><br><span class="line">List&lt;Book&gt; list = qr.query(JDBCTools.getConnection(), sql, new BeanListHandler&lt;Book&gt;(Book.class), 10, 20);</span><br><span class="line">for (Book b : list) &#123;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetSingleValue() throws Exception &#123;</span><br><span class="line">// 获取数据库中图书的总记录数</span><br><span class="line">String sql = &quot;select count(*) from books&quot;;</span><br><span class="line">Long count = qr.query(JDBCTools.getConnection(), sql,  new ScalarHandler&lt;Long&gt;());</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testGetMap() throws Exception &#123;</span><br><span class="line">String sql = &quot;SELECT user_id userId,COUNT(*) FROM `orders` GROUP BY user_id&quot;;</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; list = qr.query(JDBCTools.getConnection(), sql, new MapListHandler());</span><br><span class="line">for (Map&lt;String, Object&gt; map : list) &#123;</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.bean;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String title;</span><br><span class="line">private String author;</span><br><span class="line">private Double price;</span><br><span class="line">private Integer sales;</span><br><span class="line">private Integer stock;</span><br><span class="line">private String imgPath =&quot;static/img/default.jpg&quot;;</span><br><span class="line">public Book(Integer id, String title, String author, Double price, Integer sales, Integer stock, String imgPath) &#123;</span><br><span class="line">super();</span><br><span class="line">this.id = id;</span><br><span class="line">this.title = title;</span><br><span class="line">this.author = author;</span><br><span class="line">this.price = price;</span><br><span class="line">this.sales = sales;</span><br><span class="line">this.stock = stock;</span><br><span class="line">if(imgPath != null)&#123;</span><br><span class="line">this.imgPath = imgPath;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Book() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(Integer id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public String getTitle() &#123;</span><br><span class="line">return title;</span><br><span class="line">&#125;</span><br><span class="line">public void setTitle(String title) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">&#125;</span><br><span class="line">public String getAuthor() &#123;</span><br><span class="line">return author;</span><br><span class="line">&#125;</span><br><span class="line">public void setAuthor(String author) &#123;</span><br><span class="line">this.author = author;</span><br><span class="line">&#125;</span><br><span class="line">public Double getPrice() &#123;</span><br><span class="line">return price;</span><br><span class="line">&#125;</span><br><span class="line">public void setPrice(Double price) &#123;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getSales() &#123;</span><br><span class="line">return sales;</span><br><span class="line">&#125;</span><br><span class="line">public void setSales(Integer sales) &#123;</span><br><span class="line">this.sales = sales;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getStock() &#123;</span><br><span class="line">return stock;</span><br><span class="line">&#125;</span><br><span class="line">public void setStock(Integer stock) &#123;</span><br><span class="line">this.stock = stock;</span><br><span class="line">&#125;</span><br><span class="line">public String getImgPath() &#123;</span><br><span class="line">return imgPath;</span><br><span class="line">&#125;</span><br><span class="line">public void setImgPath(String imgPath) &#123;</span><br><span class="line">this.imgPath = imgPath;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Book [id=&quot; + id + &quot;, title=&quot; + title + &quot;, author=&quot; + author + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales</span><br><span class="line">+ &quot;, stock=&quot; + stock + &quot;, imgPath=&quot; + imgPath + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、DAO和增删改查通用方法"><a href="#七、DAO和增删改查通用方法" class="headerlink" title="七、DAO和增删改查通用方法"></a>七、DAO和增删改查通用方法</h1><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息<br>作用：为了实现功能的模块化，更有利于代码的维护和升级。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605150226.png" alt></p><h2 id="1、DAO接口"><a href="#1、DAO接口" class="headerlink" title="1、DAO接口"></a>1、DAO接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.User;</span><br><span class="line"></span><br><span class="line">public interface UserDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 根据用户名和密码获取数据库中的记录</span><br><span class="line"> * </span><br><span class="line"> * @param user</span><br><span class="line"> * @return User：用户名和密码正确 null：用户名或密码不正确</span><br><span class="line"> */</span><br><span class="line">public User getUser(User user);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据用户名获取数据库中的记录</span><br><span class="line"> * </span><br><span class="line"> * @param user</span><br><span class="line"> * @return true：用户名已存在， false：用户名可用</span><br><span class="line"> */</span><br><span class="line">public boolean checkUserName(User user);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将用户保存到数据库</span><br><span class="line"> * </span><br><span class="line"> * @param user</span><br><span class="line"> */</span><br><span class="line">public void saveUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.Book;</span><br><span class="line"></span><br><span class="line">public interface BookDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 获取所有图书的方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Book&gt; getBooks();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加图书的方法</span><br><span class="line"> * </span><br><span class="line"> * @param book</span><br><span class="line"> */</span><br><span class="line">public void addBook(Book book);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据图书的id删除图书的方法</span><br><span class="line"> * </span><br><span class="line"> * @param bookId</span><br><span class="line"> */</span><br><span class="line">public void deleteBookById(String bookId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据图书的id获取图书信息</span><br><span class="line"> * </span><br><span class="line"> * @param bookId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Book getBookById(String bookId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新图书信息的方法</span><br><span class="line"> * </span><br><span class="line"> * @param book</span><br><span class="line"> */</span><br><span class="line">public void updateBook(Book book);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量更新图书的库存和销量</span><br><span class="line"> * </span><br><span class="line"> * @param params</span><br><span class="line"> */</span><br><span class="line">public void batchUpdateSalesAndStock(Object[][] params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.Order;</span><br><span class="line"></span><br><span class="line">public interface OrderDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 保存订单的方法</span><br><span class="line"> * </span><br><span class="line"> * @param order</span><br><span class="line"> */</span><br><span class="line">public void saveOrder(Order order);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取所用订单的方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Order&gt; getOrders();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取我的订单的方法</span><br><span class="line"> * </span><br><span class="line"> * @param userId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Order&gt; getMyOrders(int userId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新订单的状态的方法，例如已发货、确认收货等</span><br><span class="line"> * </span><br><span class="line"> * @param orderId</span><br><span class="line"> * @param state</span><br><span class="line"> */</span><br><span class="line">public void updateOrderState(String orderId, int state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.dao;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bean.OrderItem;</span><br><span class="line"></span><br><span class="line">public interface OrderItemDAO &#123;</span><br><span class="line">/**</span><br><span class="line"> * 根据订单号获取对应的订单项</span><br><span class="line"> * </span><br><span class="line"> * @param orderId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;OrderItem&gt; getOrderItemsByOrderId(String orderId);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量插入订单项的方法</span><br><span class="line"> * </span><br><span class="line"> * @param params</span><br><span class="line"> */</span><br><span class="line">public void batchInsertOrderItems(Object[][] params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、BasicDAOImpl"><a href="#2、BasicDAOImpl" class="headerlink" title="2、BasicDAOImpl"></a>2、BasicDAOImpl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.dao.impl;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line">import com.atguigu.util.JDBCTools;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span><br><span class="line"> */</span><br><span class="line">public class BasicDAOImpl &#123;</span><br><span class="line">private QueryRunner queryRunner = new QueryRunner();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通用的增删改操作</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int update(String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">int count = 0;</span><br><span class="line">try &#123;</span><br><span class="line">count = queryRunner.update(connection, sql, params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取一个对象</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T getBean(Class&lt;T&gt; type,String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">T t = null;</span><br><span class="line">try &#123;</span><br><span class="line">t = queryRunner.query(connection, sql, new BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取所有对象</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; List&lt;T&gt; getBeanList(Class&lt;T&gt; type,String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">List&lt;T&gt; list = null;</span><br><span class="line">try &#123;</span><br><span class="line">list = queryRunner.query(connection, sql, new BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取一个单一值的方法，专门用来执行像select count(*)... 这样的sql语句</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object getSingleValue(String sql, Object... params) &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">Object value = null;</span><br><span class="line">try &#123;</span><br><span class="line">value = queryRunner.query(connection, sql, new ScalarHandler(), params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 进行批处理的方法</span><br><span class="line"> * 关于二维数组Object[][] params</span><br><span class="line"> * 二维数组的第一维是sql语句要执行的次数</span><br><span class="line"> * 二维数组的第二维就是每条sql语句中要填充的占位符</span><br><span class="line"> * </span><br><span class="line"> * @param sql</span><br><span class="line"> * @param params</span><br><span class="line"> */</span><br><span class="line">public void batchUpdate(String sql , Object[][] params)&#123;</span><br><span class="line">//获取连接</span><br><span class="line">Connection connection = JDBCTools.getConnection();</span><br><span class="line">try &#123;</span><br><span class="line">queryRunner.batch(connection ,sql, params);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">//将编译时异常转换为运行时异常向上抛</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、DAO实现类"><a href="#3、DAO实现类" class="headerlink" title="3、DAO实现类"></a>3、DAO实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.dao.impl;</span><br><span class="line"></span><br><span class="line">import com.bean.User;</span><br><span class="line">import com.dao.UserDAO;</span><br><span class="line"></span><br><span class="line">public class UserDAOImpl extends BasicDAOImpl implements UserDAO&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public User getUser(User user) &#123;</span><br><span class="line">// 写查询数据库的sql语句</span><br><span class="line">String sql = &quot;select id , username , password , email from users where username = ? and password = ?&quot;;</span><br><span class="line">// 调用BaseDao中的getBean方法</span><br><span class="line">User bean = getBean(User.class, sql, user.getUsername(), user.getPassword());</span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean checkUserName(User user) &#123;</span><br><span class="line">// 写查询数据库的sql语句</span><br><span class="line">String sql = &quot;select id , username , password , email from users where username = ?&quot;;</span><br><span class="line">// 调用BaseDao中的getBean方法</span><br><span class="line">User bean = getBean(User.class, sql, user.getUsername());</span><br><span class="line">return bean!=null;//不为空，说明已存在，返回true，如果bEan是空的，没找到，bean!=null返回false，说明不存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void saveUser(User user) &#123;</span><br><span class="line">//写添加数据到数据库的sql语句</span><br><span class="line">String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;</span><br><span class="line">//调用BaseDao中通用的增删改的方法</span><br><span class="line">update(sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;在Java中，数据库存取技术可分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDBC直接访问数据库&lt;/li&gt;
&lt;li&gt;JDO技术
      
    
    </summary>
    
      <category term="JavaWeb基础笔记" scheme="http://yoursite.com/categories/JavaWeb%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SQL&amp;JDBC" scheme="http://yoursite.com/tags/Java-SQL-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>2. SQL笔记语法(增删改查)</title>
    <link href="http://yoursite.com/2017/09/19/18.%20SQL%E6%A6%82%E8%BF%B0(%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5)/"/>
    <id>http://yoursite.com/2017/09/19/18. SQL概述(增删改查)/</id>
    <published>2017-09-18T16:00:00.000Z</published>
    <updated>2019-06-06T09:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阶段1：常用指令"><a href="#阶段1：常用指令" class="headerlink" title="阶段1：常用指令"></a>阶段1：常用指令</h1><ul><li><p>sql(structure query language)：结构化查询语言  </p></li><li><p>作用：和关系型数据库(dbms)交互的一种方式  </p></li></ul><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ddl(data definition language)：数据定义语言；操作数据库对象(库、表、列..)</span><br><span class="line"></span><br><span class="line">dml(data manipulation language)：数据操作语言；操作数据表中的内容</span><br><span class="line"> 使用的crud操作</span><br><span class="line"> create：创建</span><br><span class="line"> read：查阅</span><br><span class="line"> update：修改</span><br><span class="line"> delete：删除</span><br><span class="line"></span><br><span class="line">dcl(data control language)：数据控制语言；定义访问权限以及安全级别</span><br><span class="line">    使用其中的两个指令配合事务处理：</span><br><span class="line">commit：提交</span><br><span class="line">rollback：回滚</span><br><span class="line"></span><br><span class="line">dql(data query language)：数据查询语言；使用select操作的一些语句</span><br></pre></td></tr></table></figure><h2 id="sql好处："><a href="#sql好处：" class="headerlink" title="sql好处："></a>sql好处：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.易学，语法简单</span><br><span class="line">2.将类似java实现的一些操作简化</span><br></pre></td></tr></table></figure><p>sql的注释：</p><p>分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">单行注释：</span><br><span class="line"></span><br><span class="line">方式一：-- 注释内容</span><br><span class="line">方式二：#注释内容</span><br><span class="line"></span><br><span class="line">多行注释：/* ... */</span><br><span class="line"></span><br><span class="line">#切换数据库(db)</span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line">#显示当前服务器下所有的数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">#显示当前库下的所有数据表(tables)</span><br><span class="line">SHOW TABLES FROM test;</span><br><span class="line"></span><br><span class="line">#简化写法</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">-- 显示当前服务器的版本信息，用户信息</span><br><span class="line">/*</span><br><span class="line">sql语句中函数的使用：</span><br><span class="line">调用方式：</span><br><span class="line">函数名(参数列表)</span><br><span class="line">注意事项：</span><br><span class="line">sql中的函数一定有返回值，和java有区别的</span><br><span class="line">*/</span><br><span class="line">SELECT VERSION(),USER();</span><br></pre></td></tr></table></figure><p>#进阶1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">基础查询</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">select 查询列表 【from 表名】;</span><br><span class="line"></span><br><span class="line">查询列表涉及的内容如下：</span><br><span class="line">常量、表达式、函数、字段(单个、多个)以及上述的组合形式</span><br><span class="line"></span><br><span class="line">涉及到的函数：</span><br><span class="line">database()、user()、version()、ifnull()、concat()、</span><br><span class="line">*/</span><br><span class="line">#切库 --&gt; myemployees</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">#常量：</span><br><span class="line">SELECT 100;</span><br><span class="line">SELECT &apos;jerry&apos;;</span><br><span class="line"> ，</span><br><span class="line">#表达式：</span><br><span class="line">/*</span><br></pre></td></tr></table></figure><p>sql中的+号运算：只做加法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果+号两遍表达式的数据都为数值型，那么直接做加法运算；  </span><br><span class="line">如果+号两遍表达式的数据存在字符型，先尝试将字符型数据隐式转换为数值型数据，  </span><br><span class="line">如果转换成功，直接加法运算；  </span><br><span class="line">如果转换失败，使用0参与加法运算；</span><br></pre></td></tr></table></figure><p>结论：如果运算过程中有null值参与，结果一定为null                   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">SELECT 500+299;</span><br><span class="line">SELECT &apos;300&apos;+200;</span><br><span class="line">SELECT &apos;abc&apos;+&apos;def&apos;;</span><br><span class="line">SELECT &apos;abc&apos;+10;</span><br><span class="line">SELECT NULL + 100;</span><br><span class="line"></span><br><span class="line">#取余操作的符号和被余数有关</span><br><span class="line">SELECT 10%(-3);</span><br><span class="line"></span><br><span class="line">#需求：查询员工的年薪</span><br><span class="line">SELECT salary*12 FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#单个字段</span><br><span class="line">SELECT last_name FROM employees;</span><br><span class="line"></span><br><span class="line">#多个字段</span><br><span class="line">-- 部分字段</span><br><span class="line">-- 需求：查询员工的编号、名字、薪资和部门编号</span><br><span class="line">SELECT employee_id,last_name,salary,department_id</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 全部字段</span><br><span class="line">-- 需求：查询员工信息</span><br><span class="line">-- 方式一：</span><br><span class="line">-- 着重号</span><br><span class="line">SELECT </span><br><span class="line">  `employee_id`,</span><br><span class="line">  `first_name`,</span><br><span class="line">  `last_name`,</span><br><span class="line">  `email`,</span><br><span class="line">  `phone_number`,</span><br><span class="line">  `job_id`,</span><br><span class="line">  `salary`,</span><br><span class="line">  `commission_pct`,</span><br><span class="line">  `manager_id`,</span><br><span class="line">  `department_id`,</span><br><span class="line">  `hiredate` </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">-- 方式二：*</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">#函数</span><br><span class="line">SELECT USER(),VERSION(),DATABASE();</span><br><span class="line"></span><br><span class="line">#【综合案例】：涉及存在函数、单个字段、表达式...</span><br><span class="line">SELECT USER(),last_name,12*salary</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">别名：起一个新的名字</span><br><span class="line">位置：列、表</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">1、AS 别名</span><br><span class="line">2、&apos;&apos;或者&quot;&quot;如果存在特殊符号需要使用引号</span><br><span class="line">*/</span><br><span class="line">#【优化综合案例】：使用别名</span><br><span class="line">SELECT USER(),last_name,12*salary AS year_sal</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT USER(),last_name,12*salary &quot;Year_Sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT USER(),last_name,12*salary 年薪</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT USER(),last_name,12*salary &quot;Year Sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">模拟场景：</span><br><span class="line">错误现象：如何解决？</span><br><span class="line"></span><br><span class="line">ifnull(expr1,expr2)：</span><br><span class="line">如果expr1不为null，就拿其本身参与运算</span><br><span class="line">如果expr1为null，就使用expr2参与运算</span><br><span class="line">*/</span><br><span class="line">SELECT USER(),last_name,commission_pct,12*salary*(1+IFNULL(commission_pct,0)) &quot;Year Sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">模拟场景：</span><br><span class="line">XXX的年薪是XXX</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">concat(...)：拼接类似于java中的+号</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT CONCAT(last_name,&apos;的年薪是&apos;,12*salary*(1+IFNULL(commission_pct,0))) details</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><h1 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">select 查询列表</span><br><span class="line">from 表名</span><br><span class="line">where 条件</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line"></span><br><span class="line">关系表达式：</span><br><span class="line">运算符：&gt; &gt;= &lt; &lt;= = != &lt;&gt;</span><br><span class="line"></span><br><span class="line">逻辑表达式：</span><br><span class="line">运算符：and(与，并且) or(或，或者) not(非，取反)</span><br><span class="line"></span><br><span class="line">其它运算符：</span><br><span class="line">1、模糊查询：like</span><br><span class="line">2、between A and B：在[A,B]之间</span><br><span class="line">3、in(...)：只要满足条件都返回</span><br><span class="line">4、is null：</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">where紧随from</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#演示关系运算符的使用</span><br><span class="line">-- 案例1：查询工资&gt;10000的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE salary &gt; 10000;</span><br><span class="line"></span><br><span class="line">-- 案例2：查询 job_id不是&apos;IT_PROG&apos;的员工姓名、job_id、salary </span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &lt;&gt; &apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id != &apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE NOT(job_id = &apos;IT_PROG&apos;);</span><br><span class="line"></span><br><span class="line">#演示逻辑运算符的使用</span><br><span class="line">-- 案例3：查询工资&gt;10000并且小于20000的员工姓名、工资、年薪</span><br><span class="line">SELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; 10000 AND salary &lt; 20000;</span><br><span class="line">-- 案例4：查询部门编号不在90到120之间的并且 工资&gt;11000的员工信息</span><br><span class="line">SELECT last_name,department_id,salary FROM employees</span><br><span class="line">WHERE NOT(department_id &gt;= 90 AND department_id &lt;= 120) AND salary &gt; 11000;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">模糊查询的使用：</span><br><span class="line">配合通配符使用：</span><br><span class="line">_：匹配任意单个字符</span><br><span class="line">%：匹配0或者任意多个字符</span><br><span class="line">*/</span><br><span class="line">#案例1：查询员工信息表中姓名第一个字符为e的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;e%&apos;;</span><br><span class="line"></span><br><span class="line">#案例2：查询员工信息表中姓名第二个字符为e，第五个字符为a的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;_e__a%&apos;;</span><br><span class="line">#案例3：查询姓名中最后第二个字符为s的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%s_&apos;;</span><br><span class="line">#案例4：查询姓名中第二个字符为_的员工信息</span><br><span class="line">#方式一：使用\实现转义</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;_\_%&apos;;</span><br><span class="line">#方式二：使用escape关键字实现</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;_#_%&apos; ESCAPE &apos;#&apos;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">between...and...的使用：</span><br><span class="line">作用：判断是否在某一个区间范围内(含头含尾闭区间)返回布尔值</span><br><span class="line">将 and操作简化</span><br><span class="line">*/</span><br><span class="line">#查询年薪在100000到200000的员工年薪和姓名</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary*12*(1+IFNULL(commission_pct,0)) BETWEEN 100000 AND 200000;</span><br><span class="line">#案例2：查询年薪在100740到187200的员工年薪和姓名</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary*12*(1+IFNULL(commission_pct,0)) BETWEEN 100740 AND 187200;</span><br><span class="line"></span><br><span class="line">SELECT salary FROM employees</span><br><span class="line">WHERE salary &gt;= 8000 AND salary &lt;= 14000;</span><br><span class="line"></span><br><span class="line">SELECT salary FROM employees</span><br><span class="line">WHERE salary BETWEEN 8000 AND 14000;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">in(...)的使用：</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">可以简化or的使用，</span><br><span class="line">记住：</span><br><span class="line">1、如果内容不匹配页不会报错，只是不返回任何内容</span><br><span class="line">2、会自动将字符类型转换为数值型(如果需要)</span><br><span class="line">*/</span><br><span class="line">-- 案例1：查询在80、90、100号部门工作的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department_id = 80 OR department_id = 90 OR department_id = 100;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department_id IN(80,90,100);</span><br><span class="line">-- where department_id in(80,90,&apos;100&apos;,null);</span><br><span class="line"></span><br><span class="line">SELECT * FROM departments;</span><br><span class="line"></span><br><span class="line">-- 案例2：查询工种编号是IT_PROG或是ST_CLERK或是AD_VP的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE job_id IN(&apos;IT_PROG&apos;,&apos;ST_CLERK&apos;,&apos;AD_VP&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">not的使用：</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">#案例1：查询哪些员工没有奖金</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line">#案例2：查询哪些员工有奖金</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE NOT commission_pct IS NULL;</span><br></pre></td></tr></table></figure><h1 id="进阶3："><a href="#进阶3：" class="headerlink" title="进阶3："></a>进阶3：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">排序查询：</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">select 查询列表 --②</span><br><span class="line">from 表名--①</span><br><span class="line">where 条件--③</span><br><span class="line">order by 排序列表 asc|desc --④</span><br><span class="line"></span><br><span class="line">排序列表：</span><br><span class="line">单个字段、多个字段、函数、别名、表达式</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1、asc可以省略，默认升序排列</span><br><span class="line">`666`</span><br><span class="line">总结：</span><br><span class="line">order by子句出现在最后位置，除了limit...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">#单个字段：</span><br><span class="line">-- 案例1：按工资从低到高排序</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary ASC;</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary;</span><br><span class="line">-- 案例2：按工资从高到低排序</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC;</span><br><span class="line"></span><br><span class="line">#多个字段：</span><br><span class="line">-- 案例：部门编号&gt;50的按工资从高到低排序，如果一样，再按frist_name升序</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department_id &gt; 50</span><br><span class="line">ORDER BY salary DESC,first_name ASC;</span><br><span class="line"></span><br><span class="line">#按表达式排序</span><br><span class="line">-- 案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%e%&apos;</span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;</span><br><span class="line"></span><br><span class="line">#按别名排序</span><br><span class="line">-- 案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">SELECT last_name,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%e%&apos;</span><br><span class="line">ORDER BY 年薪 DESC;</span><br><span class="line"></span><br><span class="line">#按函数排序</span><br><span class="line">-- 案例：显示所有有奖金的员工姓名、奖金、姓名的长度，按姓名的长度从低到高排序</span><br><span class="line">-- length()函数的使用</span><br><span class="line">SELECT last_Name,commission_pct,LENGTH(last_name) 长度</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">ORDER BY LENGTH(last_name);</span><br><span class="line"></span><br><span class="line">SELECT last_Name,commission_pct,LENGTH(last_name) 长度</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">ORDER BY 长度;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阶段1：常用指令&quot;&gt;&lt;a href=&quot;#阶段1：常用指令&quot; class=&quot;headerlink&quot; title=&quot;阶段1：常用指令&quot;&gt;&lt;/a&gt;阶段1：常用指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sql(structure query language)：结构化查询语言
      
    
    </summary>
    
      <category term="JavaWeb基础笔记" scheme="http://yoursite.com/categories/JavaWeb%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java SQL&amp;JDBC" scheme="http://yoursite.com/tags/Java-SQL-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>1. MYSQL数据库5.5安装(win7)及使用</title>
    <link href="http://yoursite.com/2017/09/14/17.%20MYSQL%E6%95%B0%E6%8D%AE%E5%BA%935.5%E5%AE%89%E8%A3%85(win7)%E5%8F%8A%E4%BD%BF%E7%94%A817.9.4/"/>
    <id>http://yoursite.com/2017/09/14/17. MYSQL数据库5.5安装(win7)及使用17.9.4/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2019-06-06T13:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySql数据库</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随便打开一个Web网站，比如淘宝：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604232623.png" alt></p><p>为什么学习MySQL数据库？</p><p> <img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604232703.png" alt></p><ul><li><p>MySQL广占IT市场，比如淘宝、网易、百度、新浪、facebook等大部分互联网公司，都在使用mysql软件，而且在网络游戏领域，大部分的后台数据库都在使用mysql，如劲舞团、魔兽世界，还有更厉害的，中国电网、中国移动中很多项目也在使用我们的mysql。</p></li><li><p>如果我们把mysql学好学精了，还愁没工作吗？我们甚至可以去任何IT行业公司，这不像小众 的产品，你哪怕学透了，也不一定有多少人要你。</p></li></ul><h1 id="第1章-数据库概述"><a href="#第1章-数据库概述" class="headerlink" title="第1章 数据库概述"></a>第1章 数据库概述</h1><h2 id="1-1-什么是数据库"><a href="#1-1-什么是数据库" class="headerlink" title="1.1 什么是数据库"></a>1.1 什么是数据库</h2><ul><li>数据库是持久化数据的一种介质，可以理解成用来存储和管理数据的仓库！</li><li>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。持久化的大多数时候是将内存中的数据存储在数据库中，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><h2 id="1-2为什么要用数据库"><a href="#1-2为什么要用数据库" class="headerlink" title="1.2为什么要用数据库"></a>1.2为什么要用数据库</h2><ul><li>保存数据 的容器：数组、集合、文件  </li><li>保存到文件：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190604232913.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605093234.png" alt></p><ul><li>可将数据持久化到硬盘</li><li>可存储大量数据</li><li>方便检索</li><li>保证数据的一致性、完整性</li><li>安全，可共享</li><li>通过组合分析，可以产生新数据</li></ul><h2 id="1-3常见数据库产品"><a href="#1-3常见数据库产品" class="headerlink" title="1.3常见数据库产品"></a>1.3常见数据库产品</h2><ul><li>Oracle：甲骨文</li><li>DB2：IBM；</li><li>SQL Server：微软；</li><li>MySQL：甲骨文；</li></ul><h2 id="1-4数据库相关概念"><a href="#1-4数据库相关概念" class="headerlink" title="1.4数据库相关概念"></a>1.4数据库相关概念</h2><ul><li><p>DB<br>数据库（ database ）：存储数据的“仓库”。它保存了一系列有组织的数据。</p></li><li><p>DBMS<br>数据库管理系统（ Database Management System ）。数据库是通过 DBMS 创<br>建和操作的容器</p></li><li><p>SQL<br>结构化查询语言（ Structure Query Language ）：专门用来与数据库通信的语<br>言。  </p></li></ul><p>三者的关系：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605093502.png" alt></p><h2 id="1-5数据库存储数据的特点"><a href="#1-5数据库存储数据的特点" class="headerlink" title="1.5数据库存储数据的特点"></a>1.5数据库存储数据的特点</h2><p>1、将数据放到表中，表再放到库中<br>2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。<br>表名具有唯一性。<br>3、表具有一些特性，这些特性定义了数据在表中如何存储，<br>类似java中 “类”的设计。<br>4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，<br>每一列类似java 中的”属性”<br>5、表中的数据是按行存储的，每一行类似于java中的“对象”。  </p><h1 id="第2章-MySQL数据库的介绍"><a href="#第2章-MySQL数据库的介绍" class="headerlink" title="第2章 MySQL数据库的介绍"></a>第2章 MySQL数据库的介绍</h1><h2 id="2-1-MySQL产品的介绍"><a href="#2-1-MySQL产品的介绍" class="headerlink" title="2.1 MySQL产品的介绍"></a>2.1 MySQL产品的介绍</h2><blockquote><p>MySQL是一种开放源代码的关系型数据库管理系统，开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购。而2009年,SUN又被Oracle收购.目前 MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库（Facebook, Twitter, YouTube）。</p></blockquote><h2 id="2-2-MySQL产品的优点"><a href="#2-2-MySQL产品的优点" class="headerlink" title="2.2 MySQL产品的优点"></a>2.2 MySQL产品的优点</h2><ul><li>成本低：开放源代码，一般可以免费试用 </li><li>性能高：执行很快 </li><li>简单：很容易安装和使用 </li></ul><h2 id="2-2-MySQL服务端的安装和卸载"><a href="#2-2-MySQL服务端的安装和卸载" class="headerlink" title="2.2 MySQL服务端的安装和卸载"></a>2.2 MySQL服务端的安装和卸载</h2><p>DBMS分为两类： </p><ul><li>基于共享文件系统的DBMS （Access ） </li><li>基于客户机——服务器的DBMS<br>（MySQL、Oracle、SqlServer） </li></ul><p>注：查看数据库的安装和卸载文档</p><h3 id="1、win7MYSQL卸载"><a href="#1、win7MYSQL卸载" class="headerlink" title="1、win7MYSQL卸载"></a>1、win7MYSQL卸载</h3><h4 id="1）软件的卸载"><a href="#1）软件的卸载" class="headerlink" title="1）软件的卸载"></a>1）软件的卸载</h4><p>方式一：通过控制面板  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605093953.png" alt></p><p>方式二：通过电脑管家等软件卸载  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094036.png" alt></p><p>方式三：通过安装包中提供的卸载功能卸载  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094122.png" alt></p><h4 id="2）清理残余文件"><a href="#2）清理残余文件" class="headerlink" title="2）清理残余文件"></a>2）清理残余文件</h4><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装<br>a）清除安装残余文件  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094245.png" alt></p><p>b）清除数据残余文件<br>请在卸载前做好数据备份  </p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094317.png" alt></p><p>c）清理注册表</p><p>如果前两步做了，再次安装还是失败，那么可以清理注册表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line">2：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除</span><br><span class="line">3：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line">4：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除</span><br><span class="line">5：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务目录删除</span><br><span class="line">6：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除</span><br></pre></td></tr></table></figure></p><p>注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类</p><h3 id="2、win7-MYSQL5-5-安装"><a href="#2、win7-MYSQL5-5-安装" class="headerlink" title="2、win7 MYSQL5.5 安装"></a>2、win7 MYSQL5.5 安装</h3><h4 id="（1）准备安装"><a href="#（1）准备安装" class="headerlink" title="（1）准备安装"></a>（1）准备安装</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094526.png" alt></p><h4 id="（2）欢迎安装"><a href="#（2）欢迎安装" class="headerlink" title="（2）欢迎安装"></a>（2）欢迎安装</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094623.png" alt></p><h4 id="（3）准许协议"><a href="#（3）准许协议" class="headerlink" title="（3）准许协议"></a>（3）准许协议</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094646.png" alt></p><h4 id="（4）选择安装模式"><a href="#（4）选择安装模式" class="headerlink" title="（4）选择安装模式"></a>（4）选择安装模式</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094719.png" alt></p><ul><li>Typical：表示一般常用的组件都会被安装，默认情况下安装到”C:\Program Files\MySQL\MySQL Server 5.5\”下。</li><li>Complete：表示会安装所有的组件。此套件会占用比较大的磁盘空间。</li><li>Custom：表示用户可以选择要安装的组件，可以更改默认按照的路径。这种按照类型最灵活，适用于高级用户。</li></ul><h4 id="（5）选择安装组件及安装路径"><a href="#（5）选择安装组件及安装路径" class="headerlink" title="（5）选择安装组件及安装路径"></a>（5）选择安装组件及安装路径</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605094830.png" alt></p><p>这里可以选择安装哪些部分，主要是这里可以设置两个路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL Server的应用软件的安装路径，默认在</span><br><span class="line">    “C:\Program Files\MySQL\MySQL Server 5.5\”</span><br><span class="line">Server data files的数据存储的目录路径，默认在</span><br><span class="line">    “C:\ProgramData\MySQL\MySQL Server 5.5\”</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095026.png" alt></p><h4 id="（6）开始安装"><a href="#（6）开始安装" class="headerlink" title="（6）开始安装"></a>（6）开始安装</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095109.png" alt></p><p>安装进度</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095142.png" alt></p><p>系统会显示MySQL Enterprise版（企业版）的一些功能介绍界面，可以单击“Next”继续。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095217.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095310.png" alt></p><h4 id="（7）安装完成"><a href="#（7）安装完成" class="headerlink" title="（7）安装完成"></a>（7）安装完成</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095331.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单击“Finish”按钮完成安装过程。</span><br><span class="line">如果想马上配置数据库连接，</span><br><span class="line">选择“Launch the MySQL Instance Configuration Wizard”复选框。</span><br><span class="line">如果现在没有配置，以后想要配置或重新配置都可以在“MySQL Server”的安装目录的bin目录下</span><br><span class="line">（例如：D:\ProgramFiles\MySQL5.5\MySQL Server</span><br><span class="line"> 5.5\bin）找到“MySQLInstanceConfig.exe”打开“MySQL Instance Configuration Wizard”向导。</span><br></pre></td></tr></table></figure><h3 id="3、MySQL的配置"><a href="#3、MySQL的配置" class="headerlink" title="3、MySQL的配置"></a>3、MySQL的配置</h3><h4 id="（1）准备开始"><a href="#（1）准备开始" class="headerlink" title="（1）准备开始"></a>（1）准备开始</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095522.png" alt></p><h4 id="（2）选择配置类型"><a href="#（2）选择配置类型" class="headerlink" title="（2）选择配置类型"></a>（2）选择配置类型</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095606.png" alt></p><p>选择配置方式，“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，我们选择“Detailed Configuration”，方便熟悉配置过程。  </p><h4 id="（3）选择MySQL的应用模式"><a href="#（3）选择MySQL的应用模式" class="headerlink" title="（3）选择MySQL的应用模式"></a>（3）选择MySQL的应用模式</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095652.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Develop Machine（开发机），使用最小数量的内存</span><br><span class="line">Server Machine（服务器），使用中等大小的内存</span><br><span class="line">Dedicated MySQL Server Machine（专用服务器），使用当前可用的最大内存。</span><br></pre></td></tr></table></figure><h4 id="（4）选择数据库用途选择界面"><a href="#（4）选择数据库用途选择界面" class="headerlink" title="（4）选择数据库用途选择界面"></a>（4）选择数据库用途选择界面</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095746.png" alt></p><p>选择mysql数据库的大致用途：</p><ul><li>“Multifunctional Database（通用多功能型，好）”：此选项对事务性存储引擎（InnoDB）和非事务性（MyISAM）存储引擎的存取速度都很快。</li><li>“Transactional Database Only（服务器类型，专注于事务处理，一般）”：此选项主要优化了事务性存储引擎（InnoDB），但是非事务性（MyISAM）存储引擎也能用。</li><li>“Non-Transactional Database Only（非事务处理型，较简单）主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional，注意事务性存储引擎（InnoDB）不能用。</li></ul><h4 id="（5）配置InnoDB数据文件目录"><a href="#（5）配置InnoDB数据文件目录" class="headerlink" title="（5）配置InnoDB数据文件目录"></a>（5）配置InnoDB数据文件目录</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095842.png" alt></p><p>InnoDB的数据文件会在数据库第一次启动的时候创建，默认会创建在MySQL的安装目录下。用户可以根据实际的空间状况进行路径的选择。  </p><h4 id="（6）并发连接设置"><a href="#（6）并发连接设置" class="headerlink" title="（6）并发连接设置"></a>（6）并发连接设置</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605095951.png" alt></p><p>选择您的网站的一般mysql 访问量，同时连接的数目，“Decision Support(DSS)/OLAP（决策支持系统，20个左右）”、“Online Transaction Processing(OLTP)（在线事务系统，500个左右）”、“Manual Setting（手动设置，自己输一个数）”  </p><h4 id="（7）网络选项设置"><a href="#（7）网络选项设置" class="headerlink" title="（7）网络选项设置"></a>（7）网络选项设置</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100049.png" alt></p><ul><li>是否启用TCP/IP连接，设定端口，如果不启用，就只能在自己的机器上访问mysql 数据库了，我这里启用，把前面的勾打上，Port Number：3306，还有一个关于防火墙的设置“Add firewall exception ……”需要选中，将MYSQL服务的监听端口加为windows防火墙例外，避免防火墙阻断。</li><li>在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性。  </li></ul><h4 id="（8）选择字符集"><a href="#（8）选择字符集" class="headerlink" title="（8）选择字符集"></a>（8）选择字符集</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100129.png" alt></p><ul><li>注意：<ul><li>如果要用原来数据库的数据，最好能确定原来数据库用的是什么编码，如果这里设置的编码和原来数据库数据的编码不一致，在使用的时候可能会出现乱码。</li><li>这个比较重要，就是对mysql默认数据库语言编码进行设置，第一个是西文编码，第二个是多字节的通用utf8编码，第三个，手工选择字符集。</li></ul></li><li>提示：<ul><li>如果安装时选择了字符集和“utf8”，通过命令行客户端来操作数据库时，有时候会出现乱码，</li><li>这是因为“命令行客户端”默认是GBK字符集，因此客户端与服务器端就出现了不一致的情况，会出现乱码。</li><li>可以在客户端执行：<br><code>mysql&gt; set names gbk;</code>  </li><li>可以通过以下命令查看：<br><code>mysql&gt; show variables like &#39;character_set_%&#39;;</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100326.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100345.png" alt></p><p>对于客户端和服务器的交互操作，MySQL提供了3个不同的参数：<br>character_set_client、character_set_connection、character_set_results，<br>分别代表客户端、连接和返回结果的字符集。<br>通常情况下，这3个字符集应该是相同的，才能确保用户写入的数据可以正确的读出和写入。<br>“set names xxx;”命令可以同时修改这3个参数的值，但是需要每次连接都重新设置。  </p><h4 id="（9）安全选择"><a href="#（9）安全选择" class="headerlink" title="（9）安全选择"></a>（9）安全选择</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605100519.png" alt></p><p>选择是否将mysql 安装为windows服务，还可以指定Service Name（服务标识名称，例如我这里取名为“MySQL5.5”），是否将mysql的bin目录加入到Windows PATH环境变量中（加入后，就可以直接使用bin下的命令）”，我这里全部打上了勾。</p><h4 id="（10）设置密码"><a href="#（10）设置密码" class="headerlink" title="（10）设置密码"></a>（10）设置密码</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101625.png" alt></p><ul><li><p>这一步询问是否要修改默认root 用户（超级管理）的密码（默认为空），“New root password”如果要修改，就在此填入新密码，“Confirm（再输一遍）”内再填一次，防止输错。（如果是重装，并且之前已经设置了密码，在这里更改密码可能会出错，请留空，并将“Modify Security Settings”前面的勾去掉，安装配置完成后另行修改密码）</p></li><li><p>“Enable root access from remotemachines（是否允许root 用户在其它的机器或使用IP地址登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。如果没有勾选，默认只支持localhost和127.0.0.1连接。</p></li><li><p>最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询，如果要有操作数据的权限需要单独分配）”，一般就不用勾了</p><h4 id="（11）准备执行界面"><a href="#（11）准备执行界面" class="headerlink" title="（11）准备执行界面"></a>（11）准备执行界面</h4></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101704.png" alt></p><h4 id="（12）完成"><a href="#（12）完成" class="headerlink" title="（12）完成"></a>（12）完成</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101733.png" alt></p><h2 id="2-3-MySQL的安装目录"><a href="#2-3-MySQL的安装目录" class="headerlink" title="2.3 MySQL的安装目录"></a>2.3 MySQL的安装目录</h2><ul><li>bin目录中都是可执行文件；</li><li>my.ini文件是MySQL的配置文件；</li><li>MySQL的数据存储目录为data</li><li>data目录通常在C:\Documents and Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data位置。</li><li>在data下的每个目录都代表一个数据库。</li></ul><h2 id="2-4-MySQL环境变量的配置"><a href="#2-4-MySQL环境变量的配置" class="headerlink" title="2.4 MySQL环境变量的配置"></a>2.4 MySQL环境变量的配置</h2><p>将C:\Program Files (x86)\MySQL\MySQL Server 5.5\bin;添加到path中</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605101847.png" alt></p><h1 id="第3章-MySQL的使用"><a href="#第3章-MySQL的使用" class="headerlink" title="第3章 MySQL的使用"></a>第3章 MySQL的使用</h1><h2 id="1、启动和停止服务"><a href="#1、启动和停止服务" class="headerlink" title="1、启动和停止服务"></a>1、启动和停止服务</h2><p>MySQL软件的服务器端必须先启动，客户端才可以连接和使用使用数据库。</p><h3 id="启动服务的方式："><a href="#启动服务的方式：" class="headerlink" title="启动服务的方式："></a>启动服务的方式：</h3><ul><li>方式一：图形化方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“我的电脑/计算机”--&gt;右键--&gt;“管理”--&gt;“服务”--&gt;启动和关闭MySQL</span><br><span class="line">“开始菜单”--&gt;“控制面板”--&gt;“管理工具”--&gt;“服务”--&gt;启动和关闭MySQL</span><br><span class="line">“任务管理器”--&gt;“服务”--&gt;启动和关闭MySQL</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605102748.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605102802.png" alt></p><ul><li>方式二：命令行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net  start  MySQL服务名</span><br><span class="line">net  stop  MySQL服务名</span><br></pre></td></tr></table></figure><h2 id="2、客户端登录"><a href="#2、客户端登录" class="headerlink" title="2、客户端登录"></a>2、客户端登录</h2><h3 id="方式一：MySQL自带客户端"><a href="#方式一：MySQL自带客户端" class="headerlink" title="方式一：MySQL自带客户端"></a>方式一：MySQL自带客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“开始菜单”--&gt;MySQL--&gt;MySQL Server 5.5 --&gt; MySQL 5.5 Command Line Client</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605102904.png" alt></p><p>仅限于root用户</p><h3 id="方式二：命令行"><a href="#方式二：命令行" class="headerlink" title="方式二：命令行"></a>方式二：命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 主机名 -P 端口号 -u 用户名 -p密码</span><br><span class="line">例如：mysql -h localhost -P 3306 -u root -proot</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格</span><br><span class="line">mysql -hlocalhost -P3306 -uroot -proot</span><br><span class="line">（2）密码建议在一行输入</span><br><span class="line">mysql -h localhost -P 3306 -u root -p</span><br><span class="line">Enter password:****</span><br><span class="line">（3）如果是连本机：-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略</span><br><span class="line">简写成：mysql -u root -p</span><br><span class="line">    Enter password:****</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103022.png" alt></p><p>连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。<br>也可以在命令行通过以下方式获取MySQL Server服务版本的信息</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103054.png" alt></p><p>或登录后，通过以下方式查看当前版本信息：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103116.png" alt></p><h3 id="方式三：可视化工具"><a href="#方式三：可视化工具" class="headerlink" title="方式三：可视化工具"></a>方式三：可视化工具</h3><p>例如：Navicat Preminum，SQLyogEnt等工具<br>还有其他工具：mysqlfront,phpMyAdmin</p><h4 id="（1）Navicat-Preminum"><a href="#（1）Navicat-Preminum" class="headerlink" title="（1）Navicat Preminum"></a>（1）Navicat Preminum</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103151.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103232.png" alt></p><h4 id="（2）SQLyog-江湖人称小海豚"><a href="#（2）SQLyog-江湖人称小海豚" class="headerlink" title="（2）SQLyog(江湖人称小海豚)"></a>（2）SQLyog(江湖人称小海豚)</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103343.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103416.png" alt></p><h2 id="3、MySQL的基本命令"><a href="#3、MySQL的基本命令" class="headerlink" title="3、MySQL的基本命令"></a>3、MySQL的基本命令</h2><h3 id="启动和关闭mysql服务"><a href="#启动和关闭mysql服务" class="headerlink" title="启动和关闭mysql服务"></a>启动和关闭mysql服务</h3><p>方式一：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动：net start mysql；  </span><br><span class="line">关闭：net stop mysql；</span><br></pre></td></tr></table></figure><p>方式二：<br><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103526.png" alt></p><p>在启动mysql服务后，打开windows任务管理器，会有一个名为mysqld.exe的进程运行，所以mysqld.exe才是MySQL服务器程序。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103603.png" alt></p><p>客户端登录退出mysql<br>在启动MySQL服务器后，我们需要使用管理员用户登录MySQL服务器，然后来对服务器进行操作。登录MySQL需要使用MySQL的客户端程序：mysql.exe  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">登录：mysql -u root -p root -h localhost；</span><br><span class="line">-u：后面的root是用户名，这里使用的是超级管理员root；</span><br><span class="line">-p：后面的root是密码，这是在安装MySQL时就已经指定的密码；</span><br><span class="line">-h：后面给出的localhost是服务器主机名，它是可以省略的，例如：mysql -u root -p root；</span><br><span class="line">退出：quit或exit；</span><br></pre></td></tr></table></figure><p>在登录成功后，打开windows任务管理器，会有一个名为mysql.exe的进程运行，所以mysql.exe是客户端程序。</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605103707.png" alt></p><h1 id="第4章-SQL语句"><a href="#第4章-SQL语句" class="headerlink" title="第4章 SQL语句"></a>第4章 SQL语句</h1><h2 id="4-1-SQL概述"><a href="#4-1-SQL概述" class="headerlink" title="4.1 SQL概述"></a>4.1 SQL概述</h2><h3 id="1-什么是SQL"><a href="#1-什么是SQL" class="headerlink" title="1. 什么是SQL"></a>1. 什么是SQL</h3><p>SQL（Structured Query Language）是“结构化查询语言”，它是对关系型数据库的操作语言。它可以应用到所有关系型数据库中，例如：MySQL、Oracle、SQL Server等。SQL标准有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1986年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86</span><br><span class="line">1989年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89</span><br><span class="line">1992年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2）</span><br><span class="line">1999年，ISO/IEC 9075:1999，SQL:1999（SQL3）</span><br><span class="line">2003年，ISO/IEC 9075:2003，SQL:2003</span><br><span class="line">2008年，ISO/IEC 9075:2008，SQL:2008</span><br><span class="line">2011年，ISO/IEC 9075:2011，SQL:2011</span><br><span class="line">2016年，ISO/IEC 9075:2016，SQL:2016</span><br></pre></td></tr></table></figure><ul><li>这些标准就与JDK的版本一样，在新的版本中总要有一些语法的变化。不同时期的数据库对不同标准做了实现。</li><li>虽然SQL可以用在所有关系型数据库中，但很多数据库还都有标准之后的一些语法，我们可以称之为“方言”。例如MySQL中的LIMIT语句就是MySQL独有的方言，其它数据库都不支持！当然，Oracle或SQL Server都有自己的方言。</li></ul><h3 id="2-SQL语法要求"><a href="#2-SQL语法要求" class="headerlink" title="2. SQL语法要求"></a>2. SQL语法要求</h3><ul><li>不区分大小写，建议关键字大写，表名和列名小写</li><li>每句命令的结尾使用分号</li><li>每句命令，根据需要可以换行，但关键字或表名、列名不可以拆开</li><li>可以用空格和缩进来来增强语句的可读性；</li></ul><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：-- 注释文字</span><br><span class="line">单行注释：#注释文字</span><br><span class="line">多行注释：/*注释文字*/</span><br></pre></td></tr></table></figure><h2 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDL（Data Definition Language）：</span><br><span class="line">    数据定义语言，用来定义数据库对象：库、表、列等；</span><br><span class="line">DML（Data Manipulation Language）：</span><br><span class="line">    数据操作语言，用来定义数据库记录（数据）；</span><br><span class="line">DCL（Data Control Language）：</span><br><span class="line">    数据控制语言，用来定义访问权限和安全级别；</span><br><span class="line">DQL（Data Query Language）：</span><br><span class="line">    数据查询语言，用来查询记录（数据）。</span><br></pre></td></tr></table></figure><h2 id="4-3-DDL"><a href="#4-3-DDL" class="headerlink" title="4.3 DDL"></a>4.3 DDL</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看所有数据库名称：SHOW DATABASES；　</span><br><span class="line">切换数据库：USE mydb1，切换到mydb1数据库；</span><br></pre></td></tr></table></figure><h3 id="2-操作数据库"><a href="#2-操作数据库" class="headerlink" title="2.操作数据库"></a>2.操作数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建数据库：CREATE DATABASE [IF NOT EXISTS] mydb1；</span><br></pre></td></tr></table></figure><p>创建数据库，例如：CREATE DATABASE mydb1，创建一个名为mydb1的数据库。如果这个数据已经存在，那么会报错。例如CREATE DATABASE IF NOT EXISTS mydb1，在名为mydb1的数据库不存在时创建该库，这样可以避免报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除数据库：DROP DATABASE [IF EXISTS] mydb1；</span><br></pre></td></tr></table></figure><p>删除数据库，例如：DROP DATABASE mydb1，删除名为mydb1的数据库。如果这个数据库不存在，那么会报错。DROP DATABASE IF EXISTS mydb1，就算mydb1不存在，也不会的报错。</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>MySQL与Java一样，也有数据类型。MySQL中数据类型主要应用在列上。</p><p>常用类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int：整型</span><br><span class="line">double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</span><br><span class="line">decimal：浮点型，在表示钱方面使用该类型，因为不会出现精度缺失问题；</span><br><span class="line">char：固定长度字符串类型；char(4) 范围是0-255</span><br><span class="line">varchar：可变长度字符串类型；</span><br><span class="line">text：字符串类型；</span><br><span class="line">blob：字节类型；//jpg mp3 avi</span><br><span class="line">date：日期类型，格式为：yyyy-MM-dd；</span><br><span class="line">time：时间类型，格式为：hh:mm:ss</span><br><span class="line">timestamp：时间戳类型；日期+时间 yyyyMMdd hhmmss</span><br></pre></td></tr></table></figure><h3 id="4-操作表"><a href="#4-操作表" class="headerlink" title="4.操作表"></a>4.操作表</h3><ul><li>创建表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">  字段名 字段类型 【字段约束】,</span><br><span class="line">  字段名 字段类型 【字段约束】,</span><br><span class="line">  ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stus(</span><br><span class="line">sid    CHAR(6),</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emps(</span><br><span class="line">eidCHAR(6),</span><br><span class="line">enameVARCHAR(50),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(6),</span><br><span class="line">birthdayDATE,</span><br><span class="line">hiredateDATE,</span><br><span class="line">salaryDECIMAL(7,2),</span><br><span class="line">resumeVARCHAR(1000)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>MYSQL基础语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">查看当前数据库中所有表名称：SHOW TABLES；　</span><br><span class="line">查看指定表的创建语句：SHOW CREATE TABLE  emps;</span><br><span class="line">查看表结构：DESC emps;</span><br><span class="line">删除表：DROP TABLE emps</span><br><span class="line">修改表结构:</span><br><span class="line">a)修改之添加列：给stus表添加classname列：</span><br><span class="line">ALTER TABLE stu ADD (classname varchar(100));</span><br><span class="line">b)修改之修改列类型：修改stu表的gender列类型为CHAR(2)：</span><br><span class="line">ALTER TABLE stus MODIFY gender CHAR(2);</span><br><span class="line">c)修改之修改列名：修改stu表的gender列名为sex：</span><br><span class="line">ALTER TABLE stus change gender sex CHAR(2);</span><br><span class="line">d)修改之删除列：删除stsu表的classname列：</span><br><span class="line">ALTER TABLE stus DROP classname;</span><br><span class="line">e)修改之修改表名称：修改stu表名称为student：</span><br><span class="line">ALTER TABLE stus RENAME TO student;</span><br></pre></td></tr></table></figure><h2 id="4-4-DML"><a href="#4-4-DML" class="headerlink" title="4.4 DML"></a>4.4 DML</h2><h3 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1.插入数据"></a>1.插入数据</h3><ul><li>语法1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2, …) VALUES(值1, 值2)</span><br></pre></td></tr></table></figure><p>例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stus(sid, sname,age,gender) VALUES(&apos;s_1001&apos;, &apos;zhangSan&apos;, 23, &apos;male&apos;);</span><br><span class="line">INSERT INTO stus(sid, sname) VALUES(&apos;s_1001&apos;, &apos;zhangSan&apos;);</span><br></pre></td></tr></table></figure></p><ul><li>语法2：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES(值1,值2,…)</span><br></pre></td></tr></table></figure><p>因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stus VALUES(&apos;s_1002&apos;, &apos;liSi&apos;, 32, &apos;female&apos;);</span><br></pre></td></tr></table></figure><p>注意：所有字符串数据必须使用单引号</p><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2.修改数据"></a>2.修改数据</h3><h4 id="单表修改语法："><a href="#单表修改语法：" class="headerlink" title="单表修改语法："></a>单表修改语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1=值1, … 列名n=值n [WHERE 条件]</span><br><span class="line">UPDATE stus SET sname=’zhangSanSan’, age=’32’, gender=’female’ WHERE sid=’s_1001’;</span><br><span class="line">UPDATE stus SET sname=’liSi’, age=’20’ WHERE age&gt;50 AND gender=’male’;</span><br><span class="line">UPDATE stus SET sname=’wangWu’, age=’30’ WHERE age&gt;60 OR gender=’female’;</span><br><span class="line">UPDATE stus SET gender=’female’ WHERE gender IS NULL</span><br><span class="line">UPDATE stus SET age=age+1 WHERE sname=’zhaoLiu’;</span><br></pre></td></tr></table></figure><h4 id="多表修改语法："><a href="#多表修改语法：" class="headerlink" title="多表修改语法："></a>多表修改语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表1 【inner】 john 表2 on 表 SET 列名1= 新值1,列名2 =新值2 【where 筛选条件】</span><br></pre></td></tr></table></figure><h3 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3.删除数据"></a>3.删除数据</h3><h4 id="单表删除语法："><a href="#单表删除语法：" class="headerlink" title="单表删除语法："></a>单表删除语法：</h4><p>①语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件]</span><br><span class="line"></span><br><span class="line">DELETE FROM stus WHERE sid=’s_1001’003B</span><br><span class="line">DELETE FROM stus WHERE sname=’chenQi’ OR age &gt; 30;</span><br><span class="line">DELETE FROM stus;</span><br></pre></td></tr></table></figure><p>②语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE stus;</span><br></pre></td></tr></table></figure><ul><li>虽然TRUNCATE和DELETE都可以删除表的所有记录，但有原理不同。DELETE的效率没有TRUNCATE高！<br>TRUNCATE其实属性DDL语句，因为它是先DROP TABLE，再CREATE TABLE。而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的.</li></ul><h2 id="4-5-DQL"><a href="#4-5-DQL" class="headerlink" title="4.5 DQL"></a>4.5 DQL</h2><p>DQL就是数据查询语言，数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">selection_list /*要查询的列名称*/</span><br><span class="line">FROM </span><br><span class="line">table_list /*要查询的表名称*/</span><br><span class="line">WHERE </span><br><span class="line">condition /*行条件*/</span><br><span class="line">GROUP BY </span><br><span class="line">grouping_columns /*对结果分组*/</span><br><span class="line">HAVING </span><br><span class="line">condition /*分组后的行条件*/</span><br><span class="line">ORDER BY</span><br><span class="line">sorting_columns /*对结果分组*/</span><br><span class="line">LIMIT </span><br><span class="line">offset_start, row_count /*结果限定*/</span><br></pre></td></tr></table></figure><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.1　查询常量</span><br><span class="line">1.2　查询表达式</span><br><span class="line">1.3  查询函数(方法)</span><br><span class="line">1.4  查询单个字段</span><br><span class="line">1.5  查询多个字段</span><br><span class="line">1.6  查询所有字段(两种方式)</span><br></pre></td></tr></table></figure><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><p>介绍<br>条件查询就是在查询时给出WHERE子句，在WHERE子句中可以使用如下运算符及关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</span><br><span class="line">AND、OR、NOT</span><br><span class="line">λBETWEEN…AND、IN(set)、IS NULL</span><br></pre></td></tr></table></figure><h3 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3.模糊查询"></a>3.模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Like</span><br><span class="line">like一般搭配通配符使用。</span><br><span class="line">常见的通配符：</span><br><span class="line">%：任意0个或多个字符</span><br><span class="line">_：任意单个字符</span><br></pre></td></tr></table></figure><p>当想查询姓名中包含a字母的员工时就需要使用模糊查询了。模糊查询需要使用关键字LIKE。  </p><ul><li>方式一：直接通过\进行转义</li><li>方式二：通过escape关键字指定转义字符</li></ul><ul><li>between and  </li></ul><p>特点：<br>①用于筛选某个字段或表达式是否在指定的区间范围<br>②等价于 使用逻辑表达式的效果，只是语法上更加简单<br>③两个区间值不能调换顺序  </p><ul><li>两个区间值包含</li></ul><blockquote><p>=左区间 and &lt;=右区间</p></blockquote><h3 id="4-字段控制查询"><a href="#4-字段控制查询" class="headerlink" title="4.字段控制查询"></a>4.字段控制查询</h3><h4 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h4><p>去除重复记录（两行或两行以上记录中系列的上的数据都相同），例如emp表中sal字段就存在相同的记录。当只查询emp表的sal字段时，那么会出现重复记录，那么想去除重复记录，需要使用DISTINCT：</p><h4 id="查看雇员的月薪与薪资之和-IFNULL函数"><a href="#查看雇员的月薪与薪资之和-IFNULL函数" class="headerlink" title="查看雇员的月薪与薪资之和(IFNULL函数)"></a>查看雇员的月薪与薪资之和(IFNULL函数)</h4><ul><li>因为salary和commission_pct两列的类型都是数值类型，所以可以做加运算。如果salary或commission_pct中有一个字段不是数值类型，那么会出错。</li><li>Commission_pct列有很多记录的值为NULL，因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。下面使用了把NULL转换成数值0的函数IFNULL：</li></ul><h4 id="给列名添加别名"><a href="#给列名添加别名" class="headerlink" title="给列名添加别名"></a>给列名添加别名</h4><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名 as 别名 from 表名;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名 别名  from 表名;</span><br></pre></td></tr></table></figure><h3 id="5-排序-order-by"><a href="#5-排序-order-by" class="headerlink" title="5.排序 order by"></a>5.排序 order by</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）按单个字段进行升序 ★</span><br><span class="line">案例1：按工资从低到高排序</span><br><span class="line">案例2：按工资从低到高排序</span><br><span class="line">2）.按多个字段排序</span><br><span class="line">案例1：部门编号&gt;50的按工资从高到低排序，如果一样，再按frist_name升序</span><br><span class="line">3）.按表达式排序</span><br><span class="line">案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">4）.按别名排序</span><br><span class="line">案例：将姓名中包含e字符的年薪和姓名显示出来，并且按年薪进行降序</span><br><span class="line">5）.按函数排序</span><br><span class="line">案例：显示所有有奖金的员工姓名、奖金、姓名的长度，按姓名的长度从低到高排序</span><br></pre></td></tr></table></figure><h3 id="6-常见函数"><a href="#6-常见函数" class="headerlink" title="6.常见函数"></a>6.常见函数</h3><p>MySQL数据库提供了很多函数包括：</p><ul><li>数学函数；</li><li>字符串函数；</li><li>日期和时间函数；</li><li>条件判断函数；流程控制函数；</li><li>系统信息函数；</li><li>加密函数；</li><li>格式化函数；</li></ul><h4 id="1）、数学函数"><a href="#1）、数学函数" class="headerlink" title="1）、数学函数"></a>1）、数学函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ABS（x）        返回x的绝对值   </span><br><span class="line">CEIL（x）       返回大于x的最小整数值  </span><br><span class="line">FLOOR（x）      返回大于x的最大整数值</span><br><span class="line">MOD(x,y)        返回x/y的模</span><br><span class="line">RAND(x)         返回0~1的随机值</span><br><span class="line">ROUND(x,y)      返回参数x的四舍五入的有y位的小数的值</span><br><span class="line">TRUNCATE(x,y)   返回数字x截断为y位小数的结果</span><br><span class="line">SQRT(x)         返回x的平方根</span><br><span class="line">POW(x,y)        返回x的y次方</span><br></pre></td></tr></table></figure><h4 id="2）、字符串函数"><a href="#2）、字符串函数" class="headerlink" title="2）、字符串函数"></a>2）、字符串函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(S1,S2,......,Sn)</span><br><span class="line">    连接S1,S2,......,Sn为一个字符串</span><br><span class="line"></span><br><span class="line">CHAR_LENGTH(s)</span><br><span class="line">    返回字符串s的字符数</span><br><span class="line">    </span><br><span class="line">LENGTH(s)</span><br><span class="line">    返回字符串s的字节数，和字符集有关</span><br><span class="line"></span><br><span class="line">INSERT(str, index , len, instr)</span><br><span class="line">    将字符串str从第index位置开始，len个字符长的子串替换为字符串instr</span><br><span class="line">    </span><br><span class="line">UPPER(s) 或 UCASE(s)</span><br><span class="line">    将字符串s的所有字母转成大写字母</span><br><span class="line">    </span><br><span class="line">LOWER(s)  或LCASE(s)</span><br><span class="line">    将字符串s的所有字母转成小写字母</span><br><span class="line">    </span><br><span class="line">LPAD(str, len, pad)</span><br><span class="line">    用字符串pad对str最左边进行填充，直到str的长度为len个字符</span><br><span class="line">    </span><br><span class="line">RPAD(str ,len, pad)</span><br><span class="line">    用字符串pad对str最右边进行填充，直到str的长度为len个字符</span><br><span class="line">    </span><br><span class="line">TRIM(s)</span><br><span class="line">    去掉字符串s开始与结尾的空格</span><br><span class="line">    </span><br><span class="line">REPLACE（str, a, b）</span><br><span class="line">    用字符串b替换字符串str中所有出现的字符串a</span><br><span class="line">    </span><br><span class="line">SUBSTR(s,index,len)</span><br><span class="line">返回从字符串s的index位置其len个字符</span><br></pre></td></tr></table></figure><h4 id="3）、日期时间函数"><a href="#3）、日期时间函数" class="headerlink" title="3）、日期时间函数"></a>3）、日期时间函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CURDATE() 或 CURRENT_DATE()     返回当前日期</span><br><span class="line">CURTIME() 或 CURRENT_TIME()     返回当前时间</span><br><span class="line">NOW()</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">SYSDATE()               返回当前系统日期时间</span><br><span class="line">CURRENT_TIMESTAMP()</span><br><span class="line">LOCALTIME()</span><br><span class="line">LOCALTIMESTAMP()</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">YEAR(date)              返回具体的时间值</span><br><span class="line">MONTH(date)</span><br><span class="line">DAY(date)</span><br><span class="line">HOUR(time)</span><br><span class="line">MINUTE(time)</span><br><span class="line">SECOND(time)</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">WEEK(date)              返回一年中的第几周</span><br><span class="line">WEEKOFYEAR(date)</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">DAYOFWEEK()</span><br><span class="line">    返回周几，注意：周日是1，周一是2，。。。周六是7</span><br><span class="line"></span><br><span class="line">WEEKDAY(date)</span><br><span class="line">    返回周几，注意，周1是0，周2是1，。。。周日是6</span><br><span class="line"></span><br><span class="line">DAYNAME(date)</span><br><span class="line">    返回星期：MONDAY,TUESDAY.....SUNDAY</span><br><span class="line"></span><br><span class="line">MONTHNAME(date)</span><br><span class="line">    返回月份：January，。。。。。</span><br><span class="line"></span><br><span class="line">DATEDIFF(date1,date2)</span><br><span class="line">    返回date1 - date2的日期间隔</span><br><span class="line">    </span><br><span class="line">TIMEDIFF(time1, time2)</span><br><span class="line">    返回time1 - time2的时间间隔</span><br><span class="line"></span><br><span class="line">DATE_ADD(datetime, INTERVALE  expr  type)</span><br><span class="line">    返回与给定日期时间相差INTERVAL时间段的日期时间</span><br><span class="line"></span><br><span class="line">DATE_FORMAT(datetime ,fmt)</span><br><span class="line">    按照字符串fmt格式化日期datetime值</span><br><span class="line"></span><br><span class="line">STR_TO_DATE(str, fmt)</span><br><span class="line">    按照字符串fmt对str进行解析，解析为一个日期</span><br></pre></td></tr></table></figure><p>（1）DATE_ADD(datetime,INTERVAL  expr  type)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR);             #可以是负数</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL &apos;1_1&apos; YEAR_MONTH);    #需要单引号</span><br><span class="line">-------------------------------------</span><br><span class="line">表达式类型      YEAR_MONTH</span><br><span class="line">YEAR            DAY_HOUR</span><br><span class="line">MONTH           DAY_MINUTE</span><br><span class="line">DAY             DAY_SECOND</span><br><span class="line">HOUR            HOUR_MINUTE</span><br><span class="line">MINUTE          HOUR_SECOND</span><br><span class="line">SECOND          MINUTE_SECOND</span><br></pre></td></tr></table></figure><p>（2）DATE_FORMAT(datetime ,fmt)和STR_TO_DATE(str, fmt)</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605112616.png" alt></p><h4 id="4）、流程函数"><a href="#4）、流程函数" class="headerlink" title="4）、流程函数"></a>4）、流程函数</h4><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605112741.png" alt></p><h3 id="7-聚合函数"><a href="#7-聚合函数" class="headerlink" title="7.聚合函数"></a>7.聚合函数</h3><h4 id="聚合函数是用来做纵向运算的函数："><a href="#聚合函数是用来做纵向运算的函数：" class="headerlink" title="聚合函数是用来做纵向运算的函数："></a>聚合函数是用来做纵向运算的函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COUNT()：统计指定列不为NULL的记录行数；</span><br><span class="line">MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</span><br><span class="line">MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</span><br><span class="line">SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</span><br><span class="line">AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</span><br></pre></td></tr></table></figure><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h4><ul><li>当需要纵向统计时可以使用COUNT()。<ul><li>查询employees表中记录数：</li><li>查询employees表中有奖金的人数：</li></ul></li></ul><p>注意，因为count()函数中给出的是commission_pct列，那么只统计comm列非NULL的行数。</p><p>当需要纵向求和时使用sum()函数。</p><h4 id="MAX和MIN"><a href="#MAX和MIN" class="headerlink" title="MAX和MIN"></a>MAX和MIN</h4><pre><code>- 查询最高工资和最低工资：</code></pre><h3 id="8-分组查询"><a href="#8-分组查询" class="headerlink" title="8.分组查询"></a>8.分组查询</h3><h4 id="8-1-group-by"><a href="#8-1-group-by" class="headerlink" title="8.1 group by"></a>8.1 group by</h4><p>当需要分组查询时需要使用GROUP BY子句，例如查询每个部门的平均工资，这说明要使用部分来分组。</p><h4 id="8-2-having"><a href="#8-2-having" class="headerlink" title="8.2 having"></a>8.2 having</h4><h3 id="9-连接查询"><a href="#9-连接查询" class="headerlink" title="9.连接查询"></a>9.连接查询</h3><p>概念：  </p><ul><li>连接查询就是求出多个表的乘积，例如t1连接t2，那么查询出的结果就是t1*t2。</li><li>连接查询会产生笛卡尔积，假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。可以扩展到多个集合的情况。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113223.png" alt></p><ul><li>那么多表查询产生这样的结果并不是我们想要的，那么怎么去除重复的，不想要的记录呢，当然是通过条件过滤。通常要查询的多个表之间都存在关联关系，那么就通过关联关系去除笛卡尔积。</li><li>你能想像到emp和dept表连接查询的结果么？employees一共107行记录，departments表一共27行记录，那么连接后查询出的结果是2889行记录。</li><li>Sql语句：SELECT * FROM employees,departments;</li><li>查询结果：</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113341.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113358.png" alt></p><p>也就你只是想在查询employees表的同时，把每个员工的所在部门信息显示出来，那么就需要使用主外键来去除无用信息了。<br>Sql语句：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e,deptartments d WHERE e.department_id=d.deptartment_id ;</span><br></pre></td></tr></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113619.png" alt></p><p>上面查询结果会把两张表的所有列都查询出来，也许你不需要那么多列，这时就可以指定要查询的列了。<br>Sql语句：<br>SELECT employee_id,last_name,salary,commission_pct,department_name<br>FROM employees,deptartments<br>WHERE employees.department_id = departments.department_id;<br>查询结果：</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190605113439.png" alt></p><p>给表指定别名的写法：<br>SELECT employee_id,last_name,salary,commission_pct,department_name<br>FROM employees e,deptartments d<br>WHERE e.department_id = d.department_id;</p><h4 id="9-1-内连接"><a href="#9-1-内连接" class="headerlink" title="9.1　内连接"></a>9.1　内连接</h4><p>上面的连接语句就是内连接，但它不是SQL标准中的查询方式，可以理解为方言！SQL标准的内连接为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e INNER JOIN departments d </span><br><span class="line">ON e.department_id=d.department_id;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>inner可以省略、on是连接条件</li><li>内连接的特点：查询结果必须满足条件。</li></ul><h4 id="9-2-外连接（左连接、右连接）"><a href="#9-2-外连接（左连接、右连接）" class="headerlink" title="9.2　外连接（左连接、右连接）"></a>9.2　外连接（左连接、右连接）</h4><p>外连接的特点：查询出的结果存在不满足条件的可能。</p><ul><li>左连接：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e LEFT OUTER JOIN departments d </span><br><span class="line">ON e.department_id=d.department_id;</span><br></pre></td></tr></table></figure><p>注意：OUTER可以省略<br>左连接是先查询出左表（即以左表为主），然后查询右表，右表中满足条件的显示出来，不满足条件的显示NULL。</p><ul><li>右连接<br>右连接就是先把右表中所有记录都查询出来，然后左表满足条件的显示，不满足显示NULL。例如在departments表中的120~270部门并不存在员工，但在右连接中，如果departments表为右表，那么还是会查出120~270部门的信息，但相应的员工信息为NULL。<br>代码如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees e </span><br><span class="line">RIGHT OUTER JOIN departments d </span><br><span class="line">ON e.department_id=d.department_id;</span><br></pre></td></tr></table></figure><p>9.3　自连接（不太常用）</p><p>#案例：查询员工的姓名和工资以及领导姓名和工资</p><p>SELECT e.last_name,e.salary,m.last_name,m.salary<br>FROM employees e<br>JOIN employees m<br>ON e.<code>manager_id</code> = m.<code>employee_id</code>; </p><h3 id="10-子查询"><a href="#10-子查询" class="headerlink" title="10.子查询"></a>10.子查询</h3><p>概念：</p><ul><li>出现在其他语句的内部的select语句，称为子查询或内查询</li><li>里面嵌套其他select语句的查询语句，称为主查询或外查询</li></ul><p>分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行子查询</span><br><span class="line">特点：子查询的结果集只有一行一列</span><br><span class="line">多行子查询</span><br><span class="line">特点：子查询的结果集有多行一列</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、子查询语句需要放在小括号内，提高代码的阅读性  </span><br><span class="line">2、子查询先于主查询执行，一般来讲，主查询会用到子查询的结果  </span><br><span class="line">3、如果子查询放在条件中，一般来讲，子查询需要放在条件的右侧  </span><br><span class="line">示例：where job_id&gt;(子查询)  </span><br><span class="line">不能写成：where (子查询)&lt;job_id  </span><br><span class="line">4、 单行子查询对应的使用单行操作符：&gt; &lt; &gt;= &lt;= = &lt;&gt;    </span><br><span class="line">    多行子查询对应的使用多行操作符:in 、any 、all 、not in</span><br><span class="line">    </span><br><span class="line">LIMIT用来限定查询结果的起始行，以及总行数。</span><br></pre></td></tr></table></figure><h3 id="11-分页查询"><a href="#11-分页查询" class="headerlink" title="11.分页查询"></a>11.分页查询</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">limit 【起始条目索引,】查询的条目数;</span><br></pre></td></tr></table></figure><h1 id="第5章完整性约束"><a href="#第5章完整性约束" class="headerlink" title="第5章完整性约束"></a>第5章完整性约束</h1><p>　　完整性约束是为了表的数据的正确性！如果数据不正确，那么一开始就不能添加到表中。</p><h2 id="5-1主键"><a href="#5-1主键" class="headerlink" title="5.1主键"></a>5.1主键</h2><p>当某一列添加了主键约束后，那么这一列的数据就不能重复出现。这样每行记录中其主键列的值就是这一行的唯一标识。例如学生的学号可以用来做唯一标识，而学生的姓名是不能做唯一标识的，因为学习有可能同名。<br>主键列的值不能为NULL，也不能重复！<br>　指定主键约束使用PRIMARY KEY关键字</p><ul><li>创建表：定义列时指定主键：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">sid    CHAR(6) PRIMARY KEY,</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建表：定义列之后独立指定主键：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">sid    CHAR(6),</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10),</span><br><span class="line">PRIMARY KEY(sid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>修改表时指定主键：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD PRIMARY KEY(sid);</span><br></pre></td></tr></table></figure><ul><li>删除主键（只是删除主键约束，而不会删除主键列）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><h2 id="5-2主键自增长"><a href="#5-2主键自增长" class="headerlink" title="5.2主键自增长"></a>5.2主键自增长</h2><p>MySQL提供了主键自动增长的功能！这样用户就不用再为是否有主键是否重复而烦恼了。当主键设置为自动增长后，在没有给出主键值时，主键的值会自动生成，而且是最大主键值+1，也就不会出现重复主键的可能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 创建表时设置主键自增长（主键必须是整型才可以自增长）：</span><br><span class="line">CREATE TABLE stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">snameVARCHAR(20),</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">- 修改表时设置主键自增长：</span><br><span class="line">ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line">- 修改表时删除主键自增长：</span><br><span class="line">ALTER TABLE stu CHANGE sid sid INT;</span><br></pre></td></tr></table></figure><h2 id="5-3非空"><a href="#5-3非空" class="headerlink" title="5.3非空"></a>5.3非空</h2><p>指定非空约束的列不能没有值，也就是说在插入记录时，对添加了非空约束的列一定要给值；在修改记录时，不能把非空列的值设置为NULL。</p><ul><li>指定非空约束：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(10) NOT NULL,</span><br><span class="line">ageINT,</span><br><span class="line">genderVARCHAR(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当为sname字段指定为非空后，在向stu表中插入记录时，必须给sname字段指定值，否则会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu(sid) VALUES(1);</span><br></pre></td></tr></table></figure><p>插入的记录中sname没有指定值，所以会报错！</p><h2 id="5-4唯一"><a href="#5-4唯一" class="headerlink" title="5.4唯一"></a>5.4唯一</h2><p>还可以为字段指定唯一约束！当为字段指定唯一约束后，那么字段的值必须是唯一的。这一点与主键相似！例如给stu表的sname字段指定唯一约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tab_ab(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(10) UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">　　INSERT INTO sname(sid, sname) VALUES(1001, &apos;zs&apos;);</span><br><span class="line">INSERT INTO sname(sid, sname) VALUES(1002, &apos;zs&apos;);</span><br></pre></td></tr></table></figure><p>　　当两次插入相同的名字时，MySQL会报错！</p><h2 id="5-5外键"><a href="#5-5外键" class="headerlink" title="5.5外键"></a>5.5外键</h2><p>主外键是构成表与表关联的唯一途径！<br>外键是另一张表的主键！例如员工表与部门表之间就存在关联关系，其中员工表中的部门编号字段就是外键，是相对部门表的外键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- 创建dept表，指定deptno为主键列：</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">deptnoINT PRIMARY KEY,</span><br><span class="line">dnamevarchar(14),</span><br><span class="line">locvarchar(13)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">- 创建t_section表，指定sid为主键列，</span><br><span class="line">    u_id为相对t_user表的uid列的外键：</span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">empnoINT,</span><br><span class="line">enameVARCHAR(50),</span><br><span class="line">jobVARCHAR(50),</span><br><span class="line">mgrINT,</span><br><span class="line">hiredateDATE,</span><br><span class="line">salDECIMAL(7,2),</span><br><span class="line">commdecimal(7,2),</span><br><span class="line">deptnoINT,</span><br><span class="line">CONSTRAINT fk_e_d FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="第6章-事务"><a href="#第6章-事务" class="headerlink" title="第6章 事务"></a>第6章 事务</h1><pre><code>事务属于TCL控制语言（Transaction Control Language ）。</code></pre><h2 id="6-1事务概述"><a href="#6-1事务概述" class="headerlink" title="6.1事务概述"></a>6.1事务概述</h2><ul><li>什么是事务？为什么要用事务？<ul><li>一个事务是由一条或者多条sql语句构成，这一条或者多条sql语句要么全部执行成功，要么全部执行失败！</li><li>默认情况下，每条单独的sql语句就是一个单独的事务！</li></ul></li></ul><p>举例：<br>银行转账！张三转10000块到李四的账户，这其实需要两条SQL语句：</p><ul><li>给张三的账户减去10000元；</li><li>给李四的账户加上10000元。</li></ul><blockquote><ul><li>如果在第一条SQL语句执行成功后，在执行第二条SQL语句之前，程序被中断了（可能是抛出了某个异常，也可能是其他什么原因），那么李四的账户没有加上10000元，而张三却减去了10000元。这肯定是不行的！</li><li>你现在可能已经知道什么是事务了吧！事务中的多个操作，要么完全成功，要么完全失败！不可能存在成功一半的情况！也就是说给张三的账户减去10000元如果成功了，那么给李四的账户加上10000元的操作也必须是成功的；否则给张三减去10000元，以及给李四加上10000元都是失败的！</li></ul></blockquote><h2 id="6-2事务的四大特性（ACID）"><a href="#6-2事务的四大特性（ACID）" class="headerlink" title="6.2事务的四大特性（ACID）"></a>6.2事务的四大特性（ACID）</h2><ul><li>原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。</li><li>一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。</li><li>隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。</li><li>持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。</li></ul><h2 id="6-3-MySql中的事务"><a href="#6-3-MySql中的事务" class="headerlink" title="6.3 MySql中的事务"></a>6.3 MySql中的事务</h2><p>在默认情况下，MySQL每执行一条SQL语句，都是一个单独的事务。如果需要在一个事务中包含多条SQL语句，那么需要开启事务和结束事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启事务：start transaction；</span><br><span class="line">结束事务：commit或rollback。</span><br></pre></td></tr></table></figure><p>在执行SQL语句之前，先执行strat transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所做出的影响会持久化到数据库中。或者rollback，表示回滚，即回滚到事务的起点，之前做的所有操作都被撤消了！<br>演示事务  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建事务要用到的表</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(30),</span><br><span class="line">balance NUMERIC(10.2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO account(NAME,balance) VALUES(&apos;fanbingbing&apos;, 100000);</span><br><span class="line">INSERT INTO account(NAME,balance) VALUES(&apos;lichen&apos;, 100000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure><p>演示事务执行失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">案例一：回滚 事务执行失败！</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance=balance-10000 WHERE id=1;</span><br><span class="line">UPDATE account SET balance=balance+10000 WHERE id=2;</span><br><span class="line">ROLLBACK;</span><br><span class="line">案例二：退出mysql客户端 事务执行失败！</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance=balance-10000 WHERE id=1;</span><br><span class="line">UPDATE account SET balance=balance+10000 WHERE id=2;</span><br></pre></td></tr></table></figure></p><p>演示事务执行成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance=balance-10000 WHERE id=1;</span><br><span class="line">UPDATE account SET balance=balance+10000 WHERE id=2;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySql数据库&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随便打开一个Web网站，比如淘宝：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubu
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="开发环境配置" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Java SQL&amp;JDBC" scheme="http://yoursite.com/tags/Java-SQL-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>16. JavaSE-网络编程</title>
    <link href="http://yoursite.com/2017/02/26/16.%20JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/26/16. JavaSE-网络编程/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2019-06-06T15:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="16-1-网络编程概述"><a href="#16-1-网络编程概述" class="headerlink" title="16.1 网络编程概述"></a>16.1 网络编程概述</h1><h2 id="16-1-1-网络编程概述"><a href="#16-1-1-网络编程概述" class="headerlink" title="16.1.1 网络编程概述"></a>16.1.1 网络编程概述</h2><p>•    Java是 Internet   上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。<br>•    Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java   实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。  </p><h2 id="16-1-2-网络基础"><a href="#16-1-2-网络基础" class="headerlink" title="16.1.2 网络基础"></a>16.1.2 网络基础</h2><ul><li>计算机网络：  <ul><li>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</li></ul></li></ul><ul><li>网络编程的目的：  <ul><li>直接或间接地通过网络协议与其它计算机进行通讯。</li></ul></li></ul><ul><li>网络编程中有两个主要的问题：<ul><li>如何准确地定位网络上一台或多台主机</li><li>找到主机后如何可靠高效地进行数据传输</li></ul></li></ul><p>地球村</p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162248.png" alt></p><h1 id="16-2-网络通信要素"><a href="#16-2-网络通信要素" class="headerlink" title="16.2 网络通信要素"></a>16.2 网络通信要素</h1><p>如何实现网络中的主机互相通信：</p><ul><li>通信双方地址 </li><li>一定的规则（有两套参考模型）<ul><li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li><li>TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162351.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162435.png" alt></p><h1 id="16-3-InetAddress类"><a href="#16-3-InetAddress类" class="headerlink" title="16.3 InetAddress类"></a>16.3 InetAddress类</h1><h2 id="16-3-1通讯要素1：IP-和-端口号"><a href="#16-3-1通讯要素1：IP-和-端口号" class="headerlink" title="16.3.1通讯要素1：IP 和 端口号"></a>16.3.1通讯要素1：IP 和 端口号</h2><p>IP 地址：InetAddress</p><ul><li>唯一的标识 Internet 上的计算机</li><li>本地回环地址(hostAddress)：127.0.0.1      主机名(hostName)：localhost</li><li>不易记忆</li><li>端口号标识正在计算机上运行的进程（程序）<ul><li>不同的进程有不同的端口号</li><li>被规定为一个 16 位的整数 0~65535。其中，0~1023被预先定义的服务通信占用（如http占用端口80，Tomcat占用端口8080，MySql占用端口3306,Oracle占用端口1521等）。除非我们需要访问这些特定服务，否则，就应该使用 1024~65535 这些端口中的某一个进行通信，以免发生端口冲突。 </li></ul></li></ul><ul><li>端口号与IP地址的组合得出一个网络套接字：Socket。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162542.png" alt></p><h2 id="16-3-2-InetAddress类"><a href="#16-3-2-InetAddress类" class="headerlink" title="16.3.2 InetAddress类"></a>16.3.2 InetAddress类</h2><ul><li>Internet上的主机有两种方式表示地址：<ul><li>域名(hostName)：<a href="http://www.soc.pub" target="_blank" rel="noopener">www.soc.pub</a></li><li>IP 地址(hostAddress)：202.108.35.210</li></ul></li></ul><ul><li><p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。</p></li><li><p>InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址：<a href="http://www.atguigu.com" target="_blank" rel="noopener">www.atguigu.com</a> 和 202.108.35.210。</p></li><li><p>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地址，这样才能和主机建立连接。 ——-域名解析</p></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162706.png" alt></p><ul><li>InetAddress类没有提供公共的构造器，而是提供了如下两个静态方法来获取InetAddress实例</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162827.png" alt></p><ul><li>InetAddress提供了如下几个常用的方法</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603162859.png" alt></p><h2 id="16-3-2-InetAddress类代码实例"><a href="#16-3-2-InetAddress类代码实例" class="headerlink" title="16.3.2 InetAddress类代码实例"></a>16.3.2 InetAddress类代码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(&quot;www.atguigu.com&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(address);</span><br><span class="line">//获取InetAddress 对象所含的域名</span><br><span class="line">System.out.println(address.getHostName());</span><br><span class="line">//获取InetAddress 对象所含的IP地址</span><br><span class="line">System.out.println(address.getHostAddress());</span><br><span class="line"></span><br><span class="line">//获取本机的域名和IP地址</span><br><span class="line">InetAddress address2 = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(address2);</span><br></pre></td></tr></table></figure><h1 id="16-4-TCP网络通信"><a href="#16-4-TCP网络通信" class="headerlink" title="16.4 TCP网络通信"></a>16.4 TCP网络通信</h1><h2 id="16-4-1-通讯要素2：网络通信协议"><a href="#16-4-1-通讯要素2：网络通信协议" class="headerlink" title="16.4.1 通讯要素2：网络通信协议"></a>16.4.1 通讯要素2：网络通信协议</h2><p>网络通信协议  </p><ul><li>计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。</li></ul><p>通信协议分层的思想</p><ul><li>由于结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</li></ul><h2 id="16-4-2-TCP-IP协议簇"><a href="#16-4-2-TCP-IP协议簇" class="headerlink" title="16.4.2 TCP/IP协议簇"></a>16.4.2 TCP/IP协议簇</h2><ul><li>传输层协议中有两个非常重要的协议：<ul><li>传输控制协议TCP(Transmission Control Protocol)</li><li>用户数据报协议UDP(User Datagram Protocol)。</li></ul></li></ul><ul><li>TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。</li><li>IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。</li><li>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层。</li></ul><h2 id="16-4-3-TCP-和-UDP"><a href="#16-4-3-TCP-和-UDP" class="headerlink" title="16.4.3 TCP 和 UDP"></a>16.4.3 TCP 和 UDP</h2><p>TCP协议：</p><ul><li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li><li>传输前，采用“三次握手”方式，是可靠的</li><li>TCP协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输</li><li>传输完毕，需释放已建立的连接，效率低</li></ul><p>UDP协议：</p><ul><li>将数据、源、目的封装成数据包，不需要建立连接</li><li>每个数据报的大小限制在64K内</li><li>因无需连接，故是不可靠的</li><li>发送数据结束时无需释放资源，速度快</li></ul><h2 id="16-4-4-Socket"><a href="#16-4-4-Socket" class="headerlink" title="16.4.4 Socket"></a>16.4.4 Socket</h2><ul><li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。</li><li>通信的两端都要有Socket，是两台机器间通信的端点</li><li>网络通信其实就是Socket间的通信。</li><li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li></ul><h2 id="16-4-5-基于Socket的TCP编程"><a href="#16-4-5-基于Socket的TCP编程" class="headerlink" title="16.4.5 基于Socket的TCP编程"></a>16.4.5 基于Socket的TCP编程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603163320.png" alt></p><h2 id="16-4-6-Socket类的常用方法"><a href="#16-4-6-Socket类的常用方法" class="headerlink" title="16.4.6 Socket类的常用方法"></a>16.4.6 Socket类的常用方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603163339.png" alt></p><h2 id="16-4-7-ServerSocket类的常用方法"><a href="#16-4-7-ServerSocket类的常用方法" class="headerlink" title="16.4.7 ServerSocket类的常用方法"></a>16.4.7 ServerSocket类的常用方法</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603163401.png" alt></p><h2 id="16-4-8-基于Socket的TCP编程"><a href="#16-4-8-基于Socket的TCP编程" class="headerlink" title="16.4.8 基于Socket的TCP编程"></a>16.4.8 基于Socket的TCP编程</h2><p>客户端Socket的工作过程包含以下四个基本的步骤：</p><ul><li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket 的输入/出流： 使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输</li><li>按照一定的协议对 Socket  进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。</li><li>关闭 Socket：断开客户端到服务器的连接，释放线路 </li></ul><h2 id="4-8-1-客户端创建Socket对象"><a href="#4-8-1-客户端创建Socket对象" class="headerlink" title="4.8.1 客户端创建Socket对象"></a>4.8.1 客户端创建Socket对象</h2><p>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造方法是：</p><ul><li>Socket(String host,int port)throws UnknownHostException,IOException：向服务器(域名是host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li><li>Socket(InetAddress address,int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接。</li></ul><p>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Socket s = new Socket(“192.168.40.165”,9999);</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line">out.write(“hello”.getBytes());</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure><h2 id="4-8-2服务器程序的工作过程包含以下四个基本的步骤："><a href="#4-8-2服务器程序的工作过程包含以下四个基本的步骤：" class="headerlink" title="4.8.2服务器程序的工作过程包含以下四个基本的步骤："></a>4.8.2服务器程序的工作过程包含以下四个基本的步骤：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">调用 ServerSocket(int port) ：</span><br><span class="line">    创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</span><br><span class="line"></span><br><span class="line">调用 accept()：</span><br><span class="line">    监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</span><br><span class="line"></span><br><span class="line">调用 该Socket类对象的 getOutputStream() 和 getInputStream ()：</span><br><span class="line">    获取输出流和输入流，开始网络数据的发送和接收。</span><br><span class="line"></span><br><span class="line">关闭ServerSocket和Socket对象：</span><br><span class="line">    客户端访问结束，关闭通信套接字。</span><br></pre></td></tr></table></figure><h2 id="4-8-3服务器建立-ServerSocket-对象"><a href="#4-8-3服务器建立-ServerSocket-对象" class="headerlink" title="4.8.3服务器建立 ServerSocket 对象"></a>4.8.3服务器建立 ServerSocket 对象</h2><ul><li>ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的ServerSocket对象。</li><li>所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = new ServerSocket(9999);</span><br><span class="line">Socket s = ss.accept ();</span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line">byte[] buf = new byte[1024];</span><br><span class="line">int num = in.read(buf);</span><br><span class="line">String str = new String(buf,0,num);</span><br><span class="line">System.out.println(s.getInetAddress().toString()+”:”+str);</span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure><h1 id="16-5-UDP网络通信"><a href="#16-5-UDP网络通信" class="headerlink" title="16.5 UDP网络通信"></a>16.5 UDP网络通信</h1><h2 id="16-5-1-UDP网络通信"><a href="#16-5-1-UDP网络通信" class="headerlink" title="16.5.1 UDP网络通信"></a>16.5.1 UDP网络通信</h2><ul><li>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</li><li>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li><li>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li><li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li></ul><h2 id="16-5-2-流程"><a href="#16-5-2-流程" class="headerlink" title="16.5.2 流程"></a>16.5.2 流程</h2><p>流  程：</p><ol><li>DatagramSocket与DatagramPacket  </li><li>建立发送端，接收端  </li><li>建立数据包  </li><li>调用Socket的发送、接收方法  </li><li>关闭Socket  </li></ol><ul><li>发送端与接收端是两个独立的运行程序</li></ul><h2 id="16-5-3-发送端"><a href="#16-5-3-发送端" class="headerlink" title="16.5.3 发送端"></a>16.5.3 发送端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket();</span><br><span class="line">byte[] by = “hello,atguigu.com”.getBytes();</span><br><span class="line">DatagramPacket dp = new DatagramPacket(by,0,by.length,</span><br><span class="line">InetAddress.getByName(“127.0.0.1”),10000);</span><br><span class="line">ds.send(dp);</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><h2 id="16-5-4-接收端"><a href="#16-5-4-接收端" class="headerlink" title="16.5.4 接收端"></a>16.5.4 接收端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在接收端，要指定监听的端口。</span><br><span class="line">DatagramSocket ds = new DatagramSocket(10000);</span><br><span class="line">byte[] by = new byte[1024];</span><br><span class="line">DatagramPacket dp = new DatagramPacket(by,by.length);</span><br><span class="line">ds.receive(dp);</span><br><span class="line">String str = new String(dp.getData(),0,dp.getLength());</span><br><span class="line">System.out.println(str+&quot;--&quot;+dp.getAddress());</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><h1 id="16-6-URL编程"><a href="#16-6-URL编程" class="headerlink" title="16.6 URL编程"></a>16.6 URL编程</h1><h2 id="16-6-1-简介"><a href="#16-6-1-简介" class="headerlink" title="16.6.1 简介"></a>16.6.1 简介</h2><ul><li>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 </li><li>URL的基本结构由5部分组成：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;</span><br><span class="line">例如: http://192.168.1.100:8080/helloworld/index.jsp</span><br></pre></td></tr></table></figure><ul><li>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public URL (String spec)：</span><br><span class="line">通过一个表示URL地址的字符串可以构造一个URL对象。</span><br><span class="line">例如：URL url = new URL (&quot;http://www. atguigu.com/&quot;); </span><br><span class="line"></span><br><span class="line">public URL(URL context, String spec)：</span><br><span class="line">通过基 URL 和相对 URL 构造一个 URL 对象。</span><br><span class="line">例如：URL downloadUrl = new URL(url, “download.html&quot;)</span><br><span class="line"></span><br><span class="line">public URL(String protocol, String host, String file); </span><br><span class="line">例如：new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, “download. html&quot;);</span><br><span class="line"></span><br><span class="line">public URL(String protocol, String host, int port, String file); </span><br><span class="line">例如: URL gamelan = new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, 80, “download.html&quot;);</span><br></pre></td></tr></table></figure><ul><li>类URL的构造方法都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。</li><li>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getProtocol(  )        获取该URL的协议名</span><br><span class="line">public String getHost(  )            获取该URL的主机名</span><br><span class="line">public String getPort(  )            获取该URL的端口号</span><br><span class="line">public String getPath(  )            获取该URL的文件路径</span><br><span class="line">public String getFile(  )             获取该URL的文件名</span><br><span class="line">public String getQuery(   )          获取该URL的查询名</span><br></pre></td></tr></table></figure><h2 id="16-6-2-代码"><a href="#16-6-2-代码" class="headerlink" title="16.6.2 代码"></a>16.6.2 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://localhost:8080/examples/myTest.txt&quot;);</span><br><span class="line">System.out.println(&quot;getProtocol() :&quot;+url.getProtocol());</span><br><span class="line">System.out.println(&quot;getHost() :&quot;+url.getHost());</span><br><span class="line">System.out.println(&quot;getPort() :&quot;+url.getPort());</span><br><span class="line">System.out.println(&quot;getPath() :&quot;+url.getPath());</span><br><span class="line">System.out.println(&quot;getFile() :&quot;+url.getFile());</span><br><span class="line">System.out.println(&quot;getQuery() :&quot;+url.getQuery());</span><br></pre></td></tr></table></figure><h2 id="16-6-3-针对HTTP协议的URLConnection类"><a href="#16-6-3-针对HTTP协议的URLConnection类" class="headerlink" title="16.6.3 针对HTTP协议的URLConnection类"></a>16.6.3 针对HTTP协议的URLConnection类</h2><ul><li>URL的方法 openStream()：能从网络上读取数据</li><li>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</li><li>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL netchinaren = new URL (&quot;http://www.atguigu.com/index.shtml&quot;); </span><br><span class="line">URLConnectonn u = netchinaren.openConnection( );</span><br></pre></td></tr></table></figure><ul><li>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object getContent( ) throws IOException</span><br><span class="line">public int getContentLength( )</span><br><span class="line">public String getContentType( )</span><br><span class="line">public long getDate( )</span><br><span class="line">public long getLastModified( )</span><br><span class="line">public InputStream getInputStream( )throws IOException</span><br><span class="line">public OutputSteram getOutputStream( )throws IOException</span><br></pre></td></tr></table></figure><h2 id="16-6-4-小结"><a href="#16-6-4-小结" class="headerlink" title="16.6.4 小结"></a>16.6.4 小结</h2><ul><li>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</li><li>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。</li><li>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</li><li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。</li><li>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * T代表JavaBean类型</span><br><span class="line"> * P代表主键类型</span><br><span class="line"> */</span><br><span class="line">interface DAO&lt;T,P&gt;&#123;</span><br><span class="line">boolean add(T t);</span><br><span class="line">boolean deleteById(P id);</span><br><span class="line">boolean update(T t);</span><br><span class="line">T findById(P id);</span><br><span class="line">List&lt;T&gt; getAll();</span><br><span class="line">int getCount();</span><br><span class="line">&#125;</span><br><span class="line">class UserDAOImpl implements DAO&lt;User,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean add(User t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean deleteById(String id) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean update(User t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public User findById(String id) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;User&gt; getAll() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class GoodsDAOImpl implements DAO&lt;Goods,Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean add(Goods t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean deleteById(Integer id) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean update(Goods t) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Goods findById(Integer id) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;Goods&gt; getAll() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class User&#123;</span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line">public String getUsername() &#123;</span><br><span class="line">return username;</span><br><span class="line">&#125;</span><br><span class="line">public void setUsername(String username) &#123;</span><br><span class="line">this.username = username;</span><br><span class="line">&#125;</span><br><span class="line">public String getPassword() &#123;</span><br><span class="line">return password;</span><br><span class="line">&#125;</span><br><span class="line">public void setPassword(String password) &#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Goods&#123;</span><br><span class="line">private int gid;</span><br><span class="line">private String name;</span><br><span class="line">public int getGid() &#123;</span><br><span class="line">return gid;</span><br><span class="line">&#125;</span><br><span class="line">public void setGid(int gid) &#123;</span><br><span class="line">this.gid = gid;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、编写程序，在main方法中接收5个参数整数字符串；  </p><ul><li>创建TreeSet类型的集合（使用泛型），将5个字符串以整数形式添加到集合中；<br>增强型for循环遍历该集合，打印所有元素，并将所有元素之和打印出来。</li></ul><p>6、编写代码，存储丈夫与妻子，Map&lt;丈夫,妻子&gt;，并遍历输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;16-1-网络编程概述&quot;&gt;&lt;a href=&quot;#16-1-网络编程概述&quot; class=&quot;headerlink&quot; title=&quot;16.1 网络编程概述&quot;&gt;&lt;/a&gt;16.1 网络编程概述&lt;/h1&gt;&lt;h2 id=&quot;16-1-1-网络编程概述&quot;&gt;&lt;a href=&quot;#16-1
      
    
    </summary>
    
      <category term="JavaSE基础" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>15. JavaSE-多线程</title>
    <link href="http://yoursite.com/2017/02/19/15.%20JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/19/15. JavaSE-多线程/</id>
    <published>2017-02-18T16:00:00.000Z</published>
    <updated>2019-06-06T15:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="15-1-程序、进程、线程的概念"><a href="#15-1-程序、进程、线程的概念" class="headerlink" title="15.1 程序、进程、线程的概念"></a>15.1 程序、进程、线程的概念</h1><ul><li>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</li><li><p>进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。</p><ul><li>如：运行中的QQ，运行中的MP3播放器</li><li>程序是静态的，进程是动态的</li></ul></li><li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p><ul><li>若一个程序可同一时间执行多个线程，就是支持多线程的</li></ul></li></ul><h2 id="15-1-1-进程与多线程"><a href="#15-1-1-进程与多线程" class="headerlink" title="15.1.1 进程与多线程"></a>15.1.1 进程与多线程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154431.png" alt></p><h2 id="15-1-2-何时需要多线程"><a href="#15-1-2-何时需要多线程" class="headerlink" title="15.1.2 何时需要多线程"></a>15.1.2 何时需要多线程</h2><ul><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li><li>需要一些后台运行的程序时。</li></ul><h1 id="15-2-Java中多线程的创建和使用"><a href="#15-2-Java中多线程的创建和使用" class="headerlink" title="15.2 Java中多线程的创建和使用"></a>15.2 Java中多线程的创建和使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">public void method1(String str)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">public void method2(String str)&#123;</span><br><span class="line">method1(str);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Sample  s = new Sample();</span><br><span class="line">s.method2(&quot;hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-2-1-多线程的创建和启动"><a href="#15-2-1-多线程的创建和启动" class="headerlink" title="15.2.1 多线程的创建和启动"></a>15.2.1 多线程的创建和启动</h2><ul><li>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。</li><li>Thread类的特性<ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li><li>通过该Thread对象的start()方法来调用这个线程</li></ul></li></ul><h2 id="15-2-2-子线程的创建和启动过程"><a href="#15-2-2-子线程的创建和启动过程" class="headerlink" title="15.2.2 子线程的创建和启动过程"></a>15.2.2 子线程的创建和启动过程</h2><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154639.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603154701.png" alt></p><h2 id="15-2-3-Thread类"><a href="#15-2-3-Thread类" class="headerlink" title="15.2.3 Thread类"></a>15.2.3 Thread类</h2><ul><li>构造方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread()：创建新的Thread对象</span><br><span class="line">Thread(String threadname)：创建线程并指定线程实例名</span><br><span class="line">Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法</span><br><span class="line">Thread(Runnable target, String name)：创建新的Thread对象</span><br></pre></td></tr></table></figure><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><h4 id="一-继承Thread类"><a href="#一-继承Thread类" class="headerlink" title="一 继承Thread类"></a>一 继承Thread类</h4><p> 1)  定义子类继承Thread类。<br> 2)  子类中重写Thread类中的run方法。<br> 3)  创建Thread子类对象，即创建了线程对象。<br> 4)  调用线程对象start方法：启动线程，调用run方法  </p><h4 id="二-实现Runnable接口"><a href="#二-实现Runnable接口" class="headerlink" title="二 实现Runnable接口"></a>二 实现Runnable接口</h4><p>1）定义子类，实现Runnable接口。<br>2）子类中重写Runnable接口中的run方法。<br>3）通过Thread类含参构造器创建线程对象。<br>4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。<br>5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。  </p><h2 id="15-2-4-继承方式和实现方式的联系与区别"><a href="#15-2-4-继承方式和实现方式的联系与区别" class="headerlink" title="15.2.4 继承方式和实现方式的联系与区别"></a>15.2.4 继承方式和实现方式的联系与区别</h2><p>【区别】  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）继承Thread:       线程代码存放Thread子类run方法中。</span><br><span class="line">2）实现Runnable：线程代码存在接口的子类的run方法</span><br></pre></td></tr></table></figure><p>。<br>【实现方法的好处】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）避免了单继承的局限性</span><br><span class="line">2）多个线程可以共享同一个接口子类的对象，非常适合多个相同线程来处理同一份资源。</span><br></pre></td></tr></table></figure><h2 id="15-2-6-Thread类的有关方法-1"><a href="#15-2-6-Thread类的有关方法-1" class="headerlink" title="15.2.6 Thread类的有关方法(1)"></a>15.2.6 Thread类的有关方法(1)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   void start():  启动线程，并执行对象的run()方法</span><br><span class="line">run():  线程在被调度时执行的操作</span><br><span class="line">String getName():  返回线程的名称</span><br><span class="line">void setName(String name):设置该线程名称</span><br><span class="line">static currentThread(): 返回当前线程</span><br></pre></td></tr></table></figure><p>线程的调度</p><ul><li>调度策略<br>时间片</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155028.png" alt><br>抢占式：高优先级的线程抢占CPU </p><ul><li>Java的调度方法</li></ul><blockquote><ul><li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li><li>对高优先级，使用优先调度的抢占式策略</li></ul></blockquote><p>线程的优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   MAX_PRIORITY（10）;    </span><br><span class="line">MIN _PRIORITY （1）;  </span><br><span class="line">NORM_PRIORITY （5）;</span><br><span class="line">涉及的方法：</span><br><span class="line">getPriority() ：返回线程优先值 </span><br><span class="line">setPriority(int newPriority) ：改变线程的优先级</span><br><span class="line">线程创建时继承父线程的优先级</span><br></pre></td></tr></table></figure><h2 id="15-2-7-Thread类的有关方法-2"><a href="#15-2-7-Thread类的有关方法-2" class="headerlink" title="15.2.7 Thread类的有关方法(2)"></a>15.2.7 Thread类的有关方法(2)</h2><p>static  void  yield()：线程让步</p><blockquote><ul><li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li><li>若队列中没有同优先级的线程，忽略此方法</li></ul></blockquote><p>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止   </p><blockquote><ul><li>低优先级的线程也可以获得执行 </li></ul></blockquote><p>static  void  sleep(long millis)：(指定时间:毫秒)</p><blockquote><ul><li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</li><li>抛出InterruptedException异常</li></ul></blockquote><p>stop(): 强制线程生命期结束<br>boolean isAlive()：返回boolean，判断线程是否还活着</p><h2 id="15-2-8-使用多线程的优点"><a href="#15-2-8-使用多线程的优点" class="headerlink" title="15.2.8 使用多线程的优点"></a>15.2.8 使用多线程的优点</h2><p>背景：只使用单个线程完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？<br>多线程程序的优点：</p><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。  </li><li>提高计算机系统CPU的利用率  </li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改  </li></ol><h1 id="15-3-线程的生命周期"><a href="#15-3-线程的生命周期" class="headerlink" title="15.3 线程的生命周期"></a>15.3 线程的生命周期</h1><p>JDK中用Thread.State枚举表示了线程的几种状态</p><ul><li>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：<ul><li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件</li><li>运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能</li><li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了它的全部工作或线程被提前强制性地中止   </li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155642.png" alt></p><h1 id="15-4-线程的同步"><a href="#15-4-线程的同步" class="headerlink" title="15.4 线程的同步"></a>15.4 线程的同步</h1><p>问题的提出</p><ul><li>多个线程执行的不确定性引起执行结果的不稳定</li><li>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</li></ul><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155722.png" alt></p><h2 id="15-4-1例-题"><a href="#15-4-1例-题" class="headerlink" title="15.4.1例  题"></a>15.4.1例  题</h2><p>模拟火车站售票程序，开启三个窗口售票。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Ticket implements Runnable &#123;</span><br><span class="line">private int tick = 100;</span><br><span class="line"></span><br><span class="line">public void run()&#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (tick &gt; 0) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;售出车票，tick号为：&quot; + tick--);</span><br><span class="line">&#125; else</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Ticket t = new Ticket();</span><br><span class="line"></span><br><span class="line">Thread t1 = new Thread(t);</span><br><span class="line">Thread t2 = new Thread(t);</span><br><span class="line">Thread t3 = new Thread(t);</span><br><span class="line">t1.setName(&quot;t1窗口&quot;);</span><br><span class="line">t2.setName(&quot;t2窗口&quot;);</span><br><span class="line">t3.setName(&quot;t3窗口&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155810.png" alt></p><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603155831.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private int tick = 100;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (tick &gt; 0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;售出车票，tick号为：&quot; + tick--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）    多线程出现了安全问题<br>2）    问题的原因：<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。<br>3）    解决办法<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p><h2 id="15-4-2-Synchronized的使用方法"><a href="#15-4-2-Synchronized的使用方法" class="headerlink" title="15.4.2 Synchronized的使用方法"></a>15.4.2 Synchronized的使用方法</h2><ul><li>Java对于多线程的安全问题提供了专业的解决方式： 同步代码块</li></ul><p>1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象)&#123;</span><br><span class="line">          // 需要被同步的代码；</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>2）    synchronized还可以放在方法声明中，表示整个方法<br>      为同步方法。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void show (String name)&#123; </span><br><span class="line">            ….</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SomnambulistOfChina/photo_GitHub/master/photo/20190603160032.png" alt></p><h2 id="15-4-3-同步锁-Lock"><a href="#15-4-3-同步锁-Lock" class="headerlink" title="15.4.3 同步锁(Lock)"></a>15.4.3 同步锁(Lock)</h2><ul><li>从Java 5开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li><li>Lock是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li><li>在实现线程安全的控制中，比较常用的是ReentrantLock(可重入锁)，可以显式加锁、释放锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">private final ReentrantLock lock = new ReenTrantLock();</span><br><span class="line"></span><br><span class="line">public void m() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// 保证线程安全的代码;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-4-互斥锁"><a href="#15-4-4-互斥锁" class="headerlink" title="15.4.4 互斥锁"></a>15.4.4 互斥锁</h2><ul><li>在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。<ul><li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li><li>关键字synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。</li><li>同步的局限性：导致程序的执行效率要降低</li><li>同步方法（非静态的）的锁为this。</li><li>同步方法（静态的）的锁为当前类本身。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">private Singleton() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">synchronized (Singleton.class) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSingleton &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Singleton s1 = Singleton.getInstance();</span><br><span class="line">Singleton s2 = Singleton.getInstance();</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-6-小结：释放锁的操作"><a href="#15-4-6-小结：释放锁的操作" class="headerlink" title="15.4.6 小结：释放锁的操作"></a>15.4.6 小结：释放锁的操作</h2><ul><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li></ul><h2 id="15-4-7-线程的死锁问题"><a href="#15-4-7-线程的死锁问题" class="headerlink" title="15.4.7 线程的死锁问题"></a>15.4.7 线程的死锁问题</h2><ul><li><p>死锁</p><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li></ul></li><li><p>解决方法</p><ul><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestDeadLock &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final StringBuffer s1 = new StringBuffer();</span><br><span class="line">final StringBuffer s2 = new StringBuffer();</span><br><span class="line">new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (s1) &#123;</span><br><span class="line">s2.append(&quot;A&quot;);</span><br><span class="line">synchronized (s2) &#123;</span><br><span class="line">s2.append(&quot;B&quot;);</span><br><span class="line">System.out.print(s1);</span><br><span class="line">System.out.print(s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (s2) &#123;</span><br><span class="line">s2.append(&quot;C&quot;);</span><br><span class="line">synchronized (s1) &#123;</span><br><span class="line">s1.append(&quot;D&quot;);</span><br><span class="line">System.out.print(s2);</span><br><span class="line">System.out.print(s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-5-线程的通信"><a href="#15-5-线程的通信" class="headerlink" title="15.5 线程的通信"></a>15.5 线程的通信</h1><ul><li><p>wait() 与 notify() 和 notifyAll()</p><ul><li>wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问</li><li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li><li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.</li></ul></li><li><p>Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常</p></li></ul><h2 id="15-5-1-wait-方法"><a href="#15-5-1-wait-方法" class="headerlink" title="15.5.1 wait() 方法"></a>15.5.1 wait() 方法</h2><ul><li>在当前线程中调用方法：  对象名.wait()</li><li>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。</li><li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li><li>调用此方法后，当前线程将释放对象监控权  ，然后进入等待</li><li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li></ul><h2 id="15-5-2-notify-notifyAll"><a href="#15-5-2-notify-notifyAll" class="headerlink" title="15.5.2 notify()/notifyAll()"></a>15.5.2 notify()/notifyAll()</h2><ul><li>在当前线程中调用方法：  对象名.notify()</li><li>功能：唤醒等待该对象监控权的一个线程。</li><li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li></ul><h2 id="15-5-3-例-题"><a href="#15-5-3-例-题" class="headerlink" title="15.5.3 例 题"></a>15.5.3 例 题</h2><p>使用两个线程打印 1-100. 线程1, 线程2 交替打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Communication implements Runnable &#123;</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">notify();</span><br><span class="line">if (i &lt;= 100) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);</span><br><span class="line">&#125; else</span><br><span class="line">break;</span><br><span class="line">try &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典例题：生产者/消费者问题</p><ul><li><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p></li><li><p>这里可能出现两个问题：</p><ul><li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li><li>消费者比生产者快时，消费者会取相同的数据。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class TestProduct &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Clerk clerk = new Clerk();</span><br><span class="line">Thread productorThread = new Thread(new Productor(clerk));</span><br><span class="line">Thread consumerThread = new Thread(new Consumer(clerk));</span><br><span class="line">productorThread.start();</span><br><span class="line">consumerThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clerk &#123; // 售货员</span><br><span class="line">private int product = 0;</span><br><span class="line"></span><br><span class="line">public synchronized void addProduct() &#123;</span><br><span class="line">if (product &gt;= 20) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">product++;</span><br><span class="line">System.out.println(&quot;生产者生产了第&quot; + product + &quot;个产品&quot;);</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void getProduct() &#123;</span><br><span class="line">if (this.product &lt;= 0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;消费者取走了第&quot; + product + &quot;个产品&quot;);</span><br><span class="line">product--;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Productor implements Runnable &#123; // 生产者</span><br><span class="line">Clerk clerk;</span><br><span class="line"></span><br><span class="line">public Productor(Clerk clerk) &#123;</span><br><span class="line">this.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;生产者开始生产产品&quot;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep((int) Math.random() * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">clerk.addProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable &#123; // 消费者</span><br><span class="line">Clerk clerk;</span><br><span class="line"></span><br><span class="line">public Consumer(Clerk clerk) &#123;</span><br><span class="line">this.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;消费者开始取走产品&quot;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep((int) Math.random() * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">clerk.getProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>15.5.4 练习1<br>模拟银行取钱的问题<br>1.定义一个Account类<br>1）该Account类封装了账户编号（String）和余额（double）两个属性<br>2）设置相应属性的getter和setter方法<br>3）提供无参和有两个参数的构造器<br>4）系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写<br>2.提供一个取钱的线程类<br>1）提供了Account类的account属性和double类的取款额的属性<br>2）提供带线程名的构造方法<br>3）run()方法中提供取钱的操作<br>3.在主类中创建线程进行测试。考虑线程安全问题。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">private String accountId;</span><br><span class="line">private double balance;</span><br><span class="line"></span><br><span class="line">public Account() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Account(String accountId, double balance) &#123;</span><br><span class="line">this.accountId = accountId;</span><br><span class="line">this.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getAccountId() &#123;</span><br><span class="line">return accountId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAccountId(String accountId) &#123;</span><br><span class="line">this.accountId = accountId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getBalance() &#123;</span><br><span class="line">return balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setBalance(double balance) &#123;</span><br><span class="line">this.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Account [accountId=&quot; + accountId + &quot;, balance=&quot; + balance + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">final int prime = 31;</span><br><span class="line">int result = 1;</span><br><span class="line">result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());</span><br><span class="line">long temp;</span><br><span class="line">temp = Double.doubleToLongBits(balance);</span><br><span class="line">result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">if (this == obj)</span><br><span class="line">return true;</span><br><span class="line">if (obj == null)</span><br><span class="line">return false;</span><br><span class="line">if (getClass() != obj.getClass())</span><br><span class="line">return false;</span><br><span class="line">Account other = (Account) obj;</span><br><span class="line">if (accountId == null) &#123;</span><br><span class="line">if (other.accountId != null)</span><br><span class="line">return false;</span><br><span class="line">&#125; else if (!accountId.equals(other.accountId))</span><br><span class="line">return false;</span><br><span class="line">if (Double.doubleToLongBits(balance) != Double.doubleToLongBits(other.balance))</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WithDrawThread extends Thread &#123;</span><br><span class="line">Account account;</span><br><span class="line">// 要取款的额度</span><br><span class="line">double withDraw;</span><br><span class="line"></span><br><span class="line">public WithDrawThread(String name, Account account, double amt) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.account = account;</span><br><span class="line">this.withDraw = amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (account) &#123;</span><br><span class="line">if (account.getBalance() &gt; withDraw) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:取款成功，取现的金额为：&quot; + withDraw);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(50);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">account.setBalance(account.getBalance() - withDraw);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;取现额度超过账户余额，取款失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;现在账户的余额为：&quot; + account.getBalance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WithDrawThread extends Thread &#123;</span><br><span class="line">Account account;</span><br><span class="line">// 要取款的额度</span><br><span class="line">double withDraw;</span><br><span class="line"></span><br><span class="line">public WithDrawThread(String name, Account account, double amt) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.account = account;</span><br><span class="line">this.withDraw = amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (account) &#123;</span><br><span class="line">if (account.getBalance() &gt; withDraw) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:取款成功，取现的金额为：&quot; + withDraw);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(50);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">account.setBalance(account.getBalance() - withDraw);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;取现额度超过账户余额，取款失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;现在账户的余额为：&quot; + account.getBalance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;public class TestWithDrawThread &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Account account = new Account(&quot;1234567&quot;, 10000);</span><br><span class="line">Thread t1 = new WithDrawThread(&quot;小明&quot;, account, 8000);</span><br><span class="line">Thread t2 = new WithDrawThread(&quot;小明&apos;s wife&quot;, account, 2800);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-6-线程池"><a href="#15-6-线程池" class="headerlink" title="15.6 线程池"></a>15.6 线程池</h1><ul><li>系统启动一个新线程的成本是比较高的，因为它涉及与os交互。这种情况下，系统启动时即创建大量空闲的线程，就可以很好地提高性能，尤其是当程序需要创建大量生存期很短暂的线程时。</li><li>除此之外，使用线程池可以有效地控制系统中并发线程的数量。避免因并发创建的线程过多，导致系统性能下降，JVM崩溃。</li><li>Java 5以前，需要手动创建自己的线程池；Java 5开始，新增了Executors工厂类产生线程池。<br>使用线程池执行线程任务的步骤如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.调用Executors 类的静态方法newFixedThreadPool(int nThreads)，</span><br><span class="line">    创建一个可重用的、具有固定线程数的线程池ExecutorService对象  </span><br><span class="line">2.创建Runnable实例，作为线程执行任务  </span><br><span class="line">3.调用ExecutorService对象的submit()提交Runnable实例  </span><br><span class="line">4.调用ExecutorService对象的shutDown()方法关闭线程池。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;15-1-程序、进程、线程的概念&quot;&gt;&lt;a href=&quot;#15-1-程序、进程、线程的概念&quot; class=&quot;headerlink&quot; title=&quot;15.1 程序、进程、线程的概念&quot;&gt;&lt;/a&gt;15.1 程序、进程、线程的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;程序(progr
      
    
    </summary>
    
      <category term="JavaSE基础" scheme="http://yoursite.com/categories/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java SE" scheme="http://yoursite.com/tags/Java-SE/"/>
    
  </entry>
  
</feed>
